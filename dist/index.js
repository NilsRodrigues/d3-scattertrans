(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-ease'), require('d3-selection')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-ease', 'd3-selection'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
})(this, (function (exports, d3Ease, d3Selection) { 'use strict';

    let wasm;

    let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

    cachedTextDecoder.decode();

    let cachegetUint8Memory0 = null;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }

    function getStringFromWasm0(ptr, len) {
        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }

    const heap = new Array(32).fill(undefined);

    heap.push(undefined, null, true, false);

    let heap_next = heap.length;

    function addHeapObject(obj) {
        if (heap_next === heap.length) heap.push(heap.length + 1);
        const idx = heap_next;
        heap_next = heap[idx];

        heap[idx] = obj;
        return idx;
    }

    function getObject(idx) { return heap[idx]; }

    function dropObject(idx) {
        if (idx < 36) return;
        heap[idx] = heap_next;
        heap_next = idx;
    }

    function takeObject(idx) {
        const ret = getObject(idx);
        dropObject(idx);
        return ret;
    }

    let WASM_VECTOR_LEN = 0;

    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1);
        getUint8Memory0().set(arg, ptr / 1);
        WASM_VECTOR_LEN = arg.length;
        return ptr;
    }

    let cachegetInt32Memory0 = null;
    function getInt32Memory0() {
        if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
            cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
        }
        return cachegetInt32Memory0;
    }

    function getArrayU8FromWasm0(ptr, len) {
        return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
    }
    /**
    */
    class FuzzyCluster {

        static __wrap(ptr) {
            const obj = Object.create(FuzzyCluster.prototype);
            obj.ptr = ptr;

            return obj;
        }

        __destroy_into_raw() {
            const ptr = this.ptr;
            this.ptr = 0;

            return ptr;
        }

        free() {
            const ptr = this.__destroy_into_raw();
            wasm.__wbg_fuzzycluster_free(ptr);
        }
        /**
        * @param {number} eps_min
        * @param {number} eps_max
        * @param {number} pts_min
        * @param {number} pts_max
        */
        constructor(eps_min, eps_max, pts_min, pts_max) {
            var ret = wasm.fuzzycluster_new(eps_min, eps_max, pts_min, pts_max);
            return FuzzyCluster.__wrap(ret);
        }
        /**
        * @param {Uint8Array} packed_data
        * @param {number} dimensions
        * @returns {Uint8Array}
        */
        cluster(packed_data, dimensions) {
            try {
                const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
                var ptr0 = passArray8ToWasm0(packed_data, wasm.__wbindgen_malloc);
                var len0 = WASM_VECTOR_LEN;
                wasm.fuzzycluster_cluster(retptr, this.ptr, ptr0, len0, dimensions);
                var r0 = getInt32Memory0()[retptr / 4 + 0];
                var r1 = getInt32Memory0()[retptr / 4 + 1];
                var v1 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
                return v1;
            } finally {
                wasm.__wbindgen_add_to_stack_pointer(16);
            }
        }
    }

    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            if (typeof WebAssembly.instantiateStreaming === 'function') {
                try {
                    return await WebAssembly.instantiateStreaming(module, imports);

                } catch (e) {
                    if (module.headers.get('Content-Type') != 'application/wasm') {
                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                    } else {
                        throw e;
                    }
                }
            }

            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);

        } else {
            const instance = await WebAssembly.instantiate(module, imports);

            if (instance instanceof WebAssembly.Instance) {
                return { instance, module };

            } else {
                return instance;
            }
        }
    }

    async function init$1(input) {
        if (typeof input === 'undefined') {
            input = new URL('index_bg.wasm', (typeof document === 'undefined' && typeof location === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : typeof document === 'undefined' ? location.href : (document.currentScript && document.currentScript.src || new URL('index.js', document.baseURI).href)));
        }
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
            var ret = getStringFromWasm0(arg0, arg1);
            return addHeapObject(ret);
        };
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        };
        imports.wbg.__wbindgen_rethrow = function(arg0) {
            throw takeObject(arg0);
        };

        if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
            input = fetch(input);
        }



        const { instance, module } = await load(await input, imports);

        wasm = instance.exports;
        init$1.__wbindgen_wasm_module = module;

        return wasm;
    }

    var exports$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        FuzzyCluster: FuzzyCluster,
        'default': init$1
    });

    const base64codes = [62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];

                function getBase64Code(charCode) {
                    return base64codes[charCode - 43];
                }

                function base64_decode(str) {
                    let missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0;
                    let n = str.length;
                    let result = new Uint8Array(3 * (n / 4));
                    let buffer;

                    for (let i = 0, j = 0; i < n; i += 4, j += 3) {
                        buffer =
                            getBase64Code(str.charCodeAt(i)) << 18 |
                            getBase64Code(str.charCodeAt(i + 1)) << 12 |
                            getBase64Code(str.charCodeAt(i + 2)) << 6 |
                            getBase64Code(str.charCodeAt(i + 3));
                        result[j] = buffer >> 16;
                        result[j + 1] = (buffer >> 8) & 0xFF;
                        result[j + 2] = buffer & 0xFF;
                    }

                    return result.subarray(0, result.length - missingOctets);
                }
            

                        const wasm_code = base64_decode("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hHhxaEEDdiIKai0AACEICyAIQQFxIQgCQCAAKAIIDQAgCEUNACAEIABBASADEA0CQCAAQQRqKAIAIgUgACgCACIGIAdxIglqKAAAQYCBgoR4cSIDDQBBBCEKA0AgCSAKaiEJIApBBGohCiAFIAkgBnEiCWooAABBgIGChHhxIgNFDQALCyAFIANoQQN2IAlqIAZxIgpqLAAAQX9MDQAgBSgCAEGAgYKEeHFoQQN2IQoLIAUgCmogB0EZdiIJOgAAIApBfGogBnEgBWpBBGogCToAACAAIAAoAgggCGs2AgggACAAKAIMQQFqNgIMIAUgCkECdGsiCkF8aiACNgIAIARBEGokACAKC4cDAQN/AkACQAJAAkACQCABQQlJDQBBEEEIEGsgAUsNAQwCCyAAEAQhAgwCC0EQQQgQayEBC0EAIQJBABCRASEDIAMgA0EIEGtBFEEIEGtqQRBBCBBramtB+P97akF3cUF9aiIDQQBBEEEIEGtBAnRrIgQgBCADSxsgAWsgAE0NACABQRAgAEEEakEQQQgQa0F7aiAASxtBCBBrIgRqQRBBCBBrakF8ahAEIgNFDQAgAxCSASEAAkACQCABQX9qIgIgA3ENACAAIQEMAQsgAiADakEAIAFrcRCSASECQRBBCBBrIQMgABCHASACQQAgASACIABrIANLG2oiASAAayICayEDAkAgABB7DQAgASADEFggACACEFggACACEBoMAQsgACgCACEAIAEgAzYCBCABIAAgAmo2AgALIAEQew0BIAEQhwEiAEEQQQgQayAEak0NASABIAQQjwEhAiABIAQQWCACIAAgBGsiABBYIAIgABAaDAELIAIPCyABEJEBIQAgARB7GiAAC48DAQl/IAFBBGooAgAiBCABKAIAIgUgAqciBnEiB2ooAAAiCCAGQRl2QYGChAhsIglzIgZBf3MgBkH//ft3anFBgIGChHhxIQogAygCACELQQAhAwJAA0ACQAJAIApFDQAgCiEGDAELA0ACQCAIIAhBAXRxQYCBgoR4cUUNAEEAIQgMBAsgByADaiEIIANBBGohAyAEIAhBBGogBXEiB2ooAAAiCCAJcyIGQX9zIAZB//37d2pxQYCBgoR4cSIGRQ0ACwsgBkF/aiAGcSEKIAsgBCAGaEEDdiAHaiAFcUECdGsiBkF8aiIMKAIARw0AC0EB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AhALIAMgASACIANBEGoQPwJAIAMoAgBBAUcNACADQQhqKAIAIgBFDQEgAygCBCAAEIsBAAsgAygCBCEBIABBBGogA0EIaigCAEEEdjYCACAAIAE2AgAgA0EgaiQADwsQfwAL5QEBAn8jAEEgayIDJAACQCABIAJqIgIgAUkNACAAQQRqKAIAIgRBAXQiASACIAEgAksbIgFBBCABQQRLGyIBQf////8BcSABRkECdCECIAFBA3QhAQJAAkAgBEUNACADQRhqQQQ2AgAgAyAEQQN0NgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASACIANBEGoQPwJAIAMoAgBBAUcNACADQQhqKAIAIgBFDQEgAygCBCAAEIsBAAsgAygCBCEBIABBBGogA0EIaigCAEEDdjYCACAAIAE2AgAgA0EgaiQADwsQfwAL4wECA38BfQJAAkAgACgCBCICIAEoAgQiAyACIAMgAkkbIgRBBiAEQQZJGyIERg0AIAMgBEYNASAAKAIAIgIqAgAgASgCACIDKgIAkyIFIAWUu0QAAAAAAAAAAKAgAioCBCADKgIEkyIFIAWUu6AgAioCCCADKgIIkyIFIAWUu6AgAioCDCADKgIMkyIFIAWUu6AgAioCECADKgIQkyIFIAWUu6AgAioCFCADKgIUkyIFIAWUu6AgAioCGCADKgIYkyIFIAWUu6CfDwsgAiACQZCBwAAQRwALIAMgA0GggcAAEEcAC9kBAQN/IwBBIGsiAyQAAkAgASACaiICIAFJDQAgAEEEaigCACIEQQF0IgUgAiAFIAJLGyIBQQQgAUEESxsiASABaiICIAFPQQF0IQECQAJAIARFDQAgA0EYakECNgIAIAMgBTYCFCADIAAoAgA2AhAMAQsgA0EANgIQCyADIAIgASADQRBqED8CQCADKAIAQQFHDQAgA0EIaigCACIARQ0BIAMoAgQgABCLAQALIAMoAgQhASAAQQRqIANBCGooAgBBAXY2AgAgACABNgIAIANBIGokAA8LEH8AC+0BAgd/AX0CQAJAAkACQCAAKAIAIgIgACgCBCIDRg0AIABBGGooAgAhBCAAQRRqKAIAIQUgAEEQaigCACEGIAAoAgwhByAAKAIIIQADQAJAIAAgBygCACIIRg0AIAggBU8NAyACQQRqKAIARQ0EIAYgCEEDdGoiCCgCBEUNBSACKAIAKgIAIAgoAgAqAgCTIgkgCZS7RAAAAAAAAAAAoJ8gBCsDCGVFDQAgASAAEBMaCyAAQQFqIQAgAkEIaiICIANHDQALCw8LIAggBUH4gsAAEEcAC0EAQQBBkIHAABBHAAtBAEEAQaCBwAAQRwAL+AEBA38jAEEgayIEJABBASEFQQBBACgC8ItAIgZBAWo2AvCLQAJAAkBBACgC2I9AQQFHDQBBACgC3I9AQQFqIQUMAQtBAEEBNgLYj0ALQQAgBTYC3I9AAkACQCAGQQBIDQAgBUECSw0AIAQgAzYCHCAEIAI2AhhBACgC5ItAIgZBf0wNAEEAIAZBAWoiBjYC5ItAAkBBACgC7ItAIgJFDQBBACgC6ItAIQYgBEEIaiAAIAEoAhARBQAgBCAEKQMINwMQIAYgBEEQaiACKAIUEQUAQQAoAuSLQCEGC0EAIAZBf2o2AuSLQCAFQQFNDQELAAsgACABEF0AC9EBAgN/AX0CQAJAIAAoAgQiAiABKAIEIgMgAiADIAJJGyIEQQUgBEEFSRsiBEYNACADIARGDQEgACgCACICKgIAIAEoAgAiAyoCAJMiBSAFlLtEAAAAAAAAAACgIAIqAgQgAyoCBJMiBSAFlLugIAIqAgggAyoCCJMiBSAFlLugIAIqAgwgAyoCDJMiBSAFlLugIAIqAhAgAyoCEJMiBSAFlLugIAIqAhQgAyoCFJMiBSAFlLugnw8LIAIgAkGQgcAAEEcACyADIANBoIHAABBHAAvWAQEGfwJAAkACQAJAIAEoAgAiAg0AIAEoAgwhAyABKAIIIQQDQCAEIANPDQMgASAEQQRqIgU2AgggASABKAIEQXBqIgY2AgQgASAEKAIAQYCBgoR4cSIHQYCBgoR4cyICNgIAIAUhBCAHQYCBgoR4Rg0ACyABIAJBf2ogAnE2AgAMAQsgASACQX9qIAJxNgIAIAEoAgQiBkUNAQsgASABKAIQQX9qNgIQIAYgAmhBA3ZBf3NBAnRqKAIAIQRBASEBDAELQQAhAQsgACAENgIEIAAgATYCAAu7AQEEfwJAIAJFDQAgAkEDcSEDQQAhBAJAIAJBf2pBA0kNACACQXxxIQVBACEEA0AgACAEaiICIAEgBGoiBi0AADoAACACQQFqIAZBAWotAAA6AAAgAkECaiAGQQJqLQAAOgAAIAJBA2ogBkEDai0AADoAACAFIARBBGoiBEcNAAsLIANFDQAgASAEaiECIAAgBGohBANAIAQgAi0AADoAACACQQFqIQIgBEEBaiEEIANBf2oiAw0ACwsgAAu4AQEDfwJAIAJFDQAgAkEHcSEDQQAhBAJAIAJBf2pBB0kNACACQXhxIQVBACEEA0AgACAEaiICIAE6AAAgAkEHaiABOgAAIAJBBmogAToAACACQQVqIAE6AAAgAkEEaiABOgAAIAJBA2ogAToAACACQQJqIAE6AAAgAkEBaiABOgAAIAUgBEEIaiIERw0ACwsgA0UNACAAIARqIQIDQCACIAE6AAAgAkEBaiECIANBf2oiAw0ACwsgAAu4AQECfyMAQSBrIgMkAAJAIAEgAmoiAiABSQ0AIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEIIAJBCEsbIQICQAJAIAFFDQAgA0EQakEIakEBNgIAIAMgATYCFCADIAAoAgA2AhAMAQsgA0EANgIQCyADIAJBASADQRBqEEACQCADKAIAQQFHDQAgA0EIaigCACIARQ0BIAMoAgQgABCLAQALIAAgAykCBDcCACADQSBqJAAPCxB/AAu4AQECfyMAQSBrIgMkAAJAIAEgAmoiAiABSQ0AIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEIIAJBCEsbIQICQAJAIAFFDQAgA0EQakEIakEBNgIAIAMgATYCFCADIAAoAgA2AhAMAQsgA0EANgIQCyADIAJBASADQRBqEEECQCADKAIAQQFHDQAgA0EIaigCACIARQ0BIAMoAgQgABCLAQALIAAgAykCBDcCACADQSBqJAAPCxB/AAu5AQECfyMAQTBrIgIkACABQQRqIQMCQCABKAIEDQAgASgCACEBIAJCADcCDCACQQAoAsCEQDYCCCACIAJBCGo2AhQgAkEYakEQaiABQRBqKQIANwMAIAJBGGpBCGogAUEIaikCADcDACACIAEpAgA3AxggAkEUakH8g8AAIAJBGGoQFhogA0EIaiACQQhqQQhqKAIANgIAIAMgAikDCDcCAAsgAEGshcAANgIEIAAgAzYCACACQTBqJAALqAEBAn8CQAJAAkACQAJAAkACQAJAAkAgAkUNAEEBIQQgAUEASA0BIAMoAgAiBUUNAiADKAIEIgMNBCABRQ0DDAULIAAgATYCBEEBIQQLQQAhAQwGCyABDQILIAIhAwwCCyAFIAMgAiABEGwiAw0BDAILIAEgAhBxIgNFDQELIAAgAzYCBEEAIQQMAQsgACABNgIEIAIhAQsgACAENgIAIABBCGogATYCAAuoAQECfwJAAkACQAJAAkACQAJAIAJFDQBBASEEIAFBAEgNASADKAIAIgVFDQMgAygCBCIDDQIgAQ0EIAIhAwwFCyAAIAE2AgRBASEEC0EAIQEMBAsgBSADIAIgARBsIQMMAgsgAQ0AIAIhAwwBCyABIAIQcSEDCwJAIANFDQAgACADNgIEQQAhBAwBCyAAIAE2AgQgAiEBCyAAIAQ2AgAgAEEIaiABNgIAC6gBAQJ/AkACQAJAAkACQAJAAkAgAkUNAEEBIQQgAUEASA0BIAMoAgAiBUUNAyADKAIEIgMNAiABDQQgAiEDDAULIAAgATYCBEEBIQQLQQAhAQwECyAFIAMgAiABEGwhAwwCCyABDQAgAiEDDAELIAEgAhBxIQMLAkAgA0UNACAAIAM2AgRBACEEDAELIAAgATYCBCACIQELIAAgBDYCACAAQQhqIAE2AgALnAEBB38CQAJAIAAoAgAiAiAAKAIEIgNGDQAgAEEYaigCACEEIABBFGooAgAhBSAAQRBqKAIAIQYgACgCDCEHIAAoAgghAANAAkAgACAHKAIAIghGDQAgCCAFTw0DIAIgBiAIQQN0ahA4IAQrAwhlRQ0AIAEgABATGgsgAEEBaiEAIAJBCGoiAiADRw0ACwsPCyAIIAVB+ILAABBHAAucAQEHfwJAAkAgACgCACICIAAoAgQiA0YNACAAQRhqKAIAIQQgAEEUaigCACEFIABBEGooAgAhBiAAKAIMIQcgACgCCCEAA0ACQCAAIAcoAgAiCEYNACAIIAVPDQMgAiAGIAhBA3RqEDQgBCsDCGVFDQAgASAAEBMaCyAAQQFqIQAgAkEIaiICIANHDQALCw8LIAggBUH4gsAAEEcAC5oBAQZ/IAEoAgAiAkEBaiEDIAFBBGooAgAiBCgCACEFIAEoAgwhAQJAAkAgAg0AQQAhBgwBCyAEIANBAnQiB2shBiACIAdqQQVqIQILIAAgBjYCFCAAIAE2AhAgACAENgIEIABBHGpBBDYCACAAQRhqIAI2AgAgACAEIANqNgIMIAAgBEEEajYCCCAAIAVBf3NBgIGChHhxNgIAC5YBAQJ/IwBBEGsiAyQAIABBFGooAgAhBAJAAkACQAJAIABBBGooAgAOAgABAwsgBA0CQZSEwAAhAEEAIQQMAQsgBA0BIAAoAgAiACgCBCEEIAAoAgAhAAsgAyAENgIEIAMgADYCACADQZiFwAAgARCXASACEDcACyADQQA2AgQgAyAANgIAIANBhIXAACABEJcBIAIQNwALfgEBfyMAQcAAayIFJAAgBSABNgIMIAUgADYCCCAFIAM2AhQgBSACNgIQIAVBLGpBAjYCACAFQTxqQRY2AgAgBUICNwIcIAVB6IjAADYCGCAFQRc2AjQgBSAFQTBqNgIoIAUgBUEQajYCOCAFIAVBCGo2AjAgBUEYaiAEEFoAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEUNgIAIANCAjcCDCADQdSIwAA2AgggA0EUNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhBaAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBFDYCACADQgI3AgwgA0H0isAANgIIIANBFDYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQWgALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQRQ2AgAgA0ICNwIMIANBqIvAADYCCCADQRQ2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEFoAC2QBAn8jAEEgayICJAAgAEEcaigCACEDIAAoAhghACACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCAAIAMgAkEIahAWIQEgAkEgaiQAIAELYwEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakH8g8AAIAJBCGoQFiEBIAJBIGokACABC2MBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBzIbAACACQQhqEBYhASACQSBqJAAgAQtQAQJ/AkAgACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACTw0AIAMgACACEDwgBCgCACEACyADKAIAIABqIAEgAhA6GiAEIAAgAmo2AgBBAAtQAQJ/AkAgACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACTw0AIAMgACACED0gBCgCACEACyADKAIAIABqIAEgAhA6GiAEIAAgAmo2AgBBAAtUAQF/AkACQAJAIAFBgIDEAEYNAEEBIQQgACgCGCABIABBHGooAgAoAhARBgANAQsgAg0BQQAhBAsgBA8LIAAoAhggAiADIABBHGooAgAoAgwRCQALRwEBfyMAQSBrIgMkACADQRRqQQA2AgAgA0GQiMAANgIQIANCATcCBCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQWgALRgEBfyMAQSBrIgIkACACQRxqQQA2AgAgAkGEgcAANgIYIAJCATcCDCACQdSCwAA2AgggASACQQhqEEohASACQSBqJAAgAQtGAQJ/IAEoAgQhAiABKAIAIQMCQEEIQQQQcSIBDQBBCEEEEIsBAAsgASACNgIEIAEgAzYCACAAQbyFwAA2AgQgACABNgIACzkBAX8gAkEQdkAAIQMgAEEANgIIIABBACACQYCAfHEgA0F/RiICGzYCBCAAQQAgA0EQdCACGzYCAAs+AQF/AkBBKEEIEHEiBA0AQShBCBCLAQALIAQgAzkCICAEIAI5AhggBCABOQIQIAQgADkCCCAEQQA2AgAgBAs+AQN/IwBBEGsiASQAIAAQmAFB5ITAABBqIQIgABCXARBpIQMgASACNgIIIAEgADYCBCABIAM2AgAgARBuAAsuAAJAIABBfEsNAAJAIAANAEEEDwsgACAAQX1JQQJ0EHEiAEUNACAADwsQkwEACzIAAkAgACABECMiAUUNAAJAQZCMwAAQowFFDQAgARCSARB7DQELIAFBACAAEDsaCyABCyoAIAAgACgCBEEBcSABckECcjYCBCABIABqQQRqIgAgACgCAEEBcjYCAAssAAJAAkAgAEUNACAAKAIADQEgAEEANgIAIABBKEEIEHkPCxCFAQALEIYBAAs0AQF/IwBBEGsiAiQAIAIgATYCDCACIAA2AgggAkGQiMAANgIEIAJBkIjAADYCACACEFUA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c21fYmluZGdlbjo6X193YmluZGdlbl9zdHJpbmdfbmV3OjpoODI3ZDhmMGU0NjMwYTdjMQExd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoYzQ2MzcwMDFiYmI4YzQ4ZAIzd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3JldGhyb3c6OmhkODQ1NmQxYTRmOWY5ZTgwAxRmdXp6eWNsdXN0ZXJfY2x1c3RlcgQ6ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoZWViNjkzYzcyM2Q3N2ZhMAVAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoM2MzNzAxZDBlNGNhMmNmOQZAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoNDFkM2M0MWVhN2NhYmIyMAdAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoMTBjMmM0MmM5YzUzMjVmNghAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoMzk4N2JjMjU4YmIxMDU3MQlAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoZWU5ZTQwOWIxYjcyNzFjYwpAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoOGViMjVmYjE3MmYwYzllZgtAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoY2VmMzAzZTA5NWY1MzJmYgxAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpjbHVzdGVyOjpoZWI3YTk4ZmZkOWVmNzkyZQ1AaGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT46OnJlc2VydmVfcmVoYXNoOjpoZTU3ODkzMzE2ZGNhODY4Yw4sY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDcyY2NjNDIxOWMxZDA5ZjAPOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6OmhiMDdlZWZkMzFlYWNkODRjEDVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoOGM3NjYwMGQxMWEyYzRiMRFAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoZDcyODA4OWJhMzNjZmVlNxINX19yZGxfcmVhbGxvYxM7aGFzaGJyb3duOjptYXA6Okhhc2hNYXA8SyxWLFMsQT46Omluc2VydDo6aGQ4NDI5ZTY2OWY5NzJkODMUK2Qzc3Rfd2FzbTo6cGFja19jbHVzdGVyczo6aGJmZjk4NDk5MzZlMzAwYTUVTWNvcmU6Omhhc2g6OmltcGxzOjo8aW1wbCBjb3JlOjpoYXNoOjpIYXNoIGZvciB1c2l6ZT46Omhhc2g6OmhmMzA1MzQ3MDY4ZTJjOTkwFiNjb3JlOjpmbXQ6OndyaXRlOjpoYjM2M2E1Y2MzN2RiNzRhZhdAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoMDc1OTk1OWRlMWIwMTM1YxhAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoYzc1OTU1Y2ViMTg3MDY2NxlAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoZTgyZTY5MGQwZTE3YTM1OBpBZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6ZGlzcG9zZV9jaHVuazo6aDNlZTgxMWIzMmUzM2RkYjQbJWFsbG9jOjpmbXQ6OmZvcm1hdDo6aDJhYjNmZDdkODE3MzYwY2UcQGQzc3Rfd2FzbTo6ZnV6enlfZGJzY2FuOjpGdXp6eURCU0NBTjo6ZGVuc2l0eTo6aDhiZTU1ZjIwYzM4OGM2ZDQdQGQzc3Rfd2FzbTo6ZnV6enlfZGJzY2FuOjpGdXp6eURCU0NBTjo6ZGVuc2l0eTo6aDY3ZWJmOGNmMzFjMmIwMTYeQWhhc2hicm93bjo6bWFwOjpIYXNoTWFwPEssVixTLEE+OjpyZW1vdmVfZW50cnk6OmgzZGU2YTA5ZDNmYjAyODFiH2g8Y29yZTo6aXRlcjo6YWRhcHRlcnM6Om1hcDo6TWFwPEksRj4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+Ojpmb2xkOjpoZTViZGJjNjc1NTU4MmNjMyBAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoMWYwYzBiMzY1NjE1YTU1MSFAZDNzdF93YXNtOjpmdXp6eV9kYnNjYW46OkZ1enp5REJTQ0FOOjpkZW5zaXR5OjpoYjVlMzk0MDAyOTc4MjgwYyI4aGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT46Omluc2VydDo6aDQyZjlkNGFlNTRiMDlmZTkjMGRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoYmQyYjJhNTYxZTBlZjY3MCQ+aGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT46OnJlbW92ZV9lbnRyeTo6aGVkMzQzOTQyMjJlMzI3YWIlB21lbW1vdmUmOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg5ZjBlNzYyOWRiYTFiYzFlJy5hbGxvYzo6c3RyaW5nOjpTdHJpbmc6OnB1c2g6OmgzNTIwMzA1Y2E1NjFkY2Y3KGg8Y29yZTo6aXRlcjo6YWRhcHRlcnM6Om1hcDo6TWFwPEksRj4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+Ojpmb2xkOjpoOGIzYzY2MGQ4ZTBlYjRhOCkvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDRkOGMyNmMzNjIzY2I5OGIqaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6Omg4ODZlNTRhNzY4Y2RkMjU2K0ZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjppbnNlcnRfbGFyZ2VfY2h1bms6OmgyZDdhYjRjZDIxYjliMWU4LEZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojp1bmxpbmtfbGFyZ2VfY2h1bms6OmhiMDc5MjVmMDMyY2M4NjQ4LWg8Y29yZTo6aXRlcjo6YWRhcHRlcnM6Om1hcDo6TWFwPEksRj4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjppdGVyYXRvcjo6SXRlcmF0b3I+Ojpmb2xkOjpoOWNiNGY5MzFmY2FiODg0Ny5LZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6cmVsZWFzZV91bnVzZWRfc2VnbWVudHM6OmgxNWE0NDU2MmYyZmYyMjI4L2g8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMDIxM2Y4YTU0N2M3ZTdiYjBoPGNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjptYXA6Ok1hcDxJLEY+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6Zm9sZDo6aDU2YTljY2Q0ZmFjZTVjNTkxTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoNjJjZjQ5ZDMyOTc5ZTM5OTJOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmhkM2QyY2MwYmE3MTA5NGZlM05hbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmU6OmRvX3Jlc2VydmVfYW5kX2hhbmRsZTo6aDAzZDAxOTBmZWFkNDBjMTU0XjxkM3N0X3dhc206OkRhdGFQb2ludDxfPiBhcyBkM3N0X3dhc206OmZ1enp5X2Ric2Nhbjo6TWV0cmljU3BhY2U+OjpkaXN0YW5jZTo6aDUyMzU3NjQ4ZDE0MTQ4ZmQ1TmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoMjNhYThiMWNjZmRjNDkyMTZoPGNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjptYXA6Ok1hcDxJLEY+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6Zm9sZDo6aDJjOTU3MjkxNjk3ODJhNzg3N3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdGhfaG9vazo6aDM2NDk3NGU3MTdlZDU5ZWM4XjxkM3N0X3dhc206OkRhdGFQb2ludDxfPiBhcyBkM3N0X3dhc206OmZ1enp5X2Ric2Nhbjo6TWV0cmljU3BhY2U+OjpkaXN0YW5jZTo6aDgyZTQxMzVmNTI1MjY4OTU5ZTxoYXNoYnJvd246OnJhdzo6UmF3SW50b0l0ZXI8VCxBPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmgyYWRkOTI2NmYyOGFiMTllOgZtZW1jcHk7Bm1lbXNldDxOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6Omg0OTI0ZWFkMDJlNGI3OTQwPU5hbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmU6OmRvX3Jlc2VydmVfYW5kX2hhbmRsZTo6aDcyYjVmYzlhMmIwNzc3ODE+YzxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6UGFuaWNQYXlsb2FkIGFzIGNvcmU6OnBhbmljOjpCb3hNZVVwPjo6Z2V0OjpoMDIzZTgwMjE2MzUxZGRlNT8uYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoMmY1YjkwN2ZlY2ZmMGJlYkAuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoM2YyNzQ1YTU5NTIzYjI0ZkEuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoMWUxNzg4MTE4MTcxYjBlZUJoPGNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjptYXA6Ok1hcDxJLEY+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6Zm9sZDo6aDVlNzU4ZTY2OWRkM2U3MjhDaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6Omg5ODEyODZkY2UyZDU4OGEzRGo8aGFzaGJyb3duOjpyYXc6OlJhd1RhYmxlPFQsQT4gYXMgY29yZTo6aXRlcjo6dHJhaXRzOjpjb2xsZWN0OjpJbnRvSXRlcmF0b3I+OjppbnRvX2l0ZXI6Omg1ZDZlZjllMGEwNjg1YmNiRUNzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06Omg5YzY3NTE2ODdiZmM1NTIxRi5jb3JlOjpyZXN1bHQ6OnVud3JhcF9mYWlsZWQ6Omg2OTRkYjEzYTQ1YWE2NzQwRzZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aDFkODQ1MTllYzQ2ZWQ0OGNIP2NvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsOjpoZTAwMDUzMzIyZDRkN2FhNEk9Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoZTM4OGQwM2IyODI4YjRlYkoyY29yZTo6Zm10OjpGb3JtYXR0ZXI6OndyaXRlX2ZtdDo6aDE3NTEwYmQ1ZmE2ODdkMTFLOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDRlNjNiZTk3MDc5NzNkNTFMOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGJkMTA1Njg4NGEyMjlkYjFNOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGJiOWQ2MDlmYTZjYTIyNjVOOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDZmNjI5MTY0NmNmNDEyY2ZPQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWRfaW50ZWdyYWw6OndyaXRlX3ByZWZpeDo6aDU4NWM0ZjcyZTFkODRjMWFQKWNvcmU6OnBhbmlja2luZzo6cGFuaWM6OmhjZWFlMGM3OWIwMjQ3Zjk4UUc8ZDNzdF93YXNtOjpDbHVzdGVyRXJyb3IgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDNiYWI5NzJlY2IzZmE4N1JrPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpTdHJQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+Ojp0YWtlX2JveDo6aDhjNWRjODY3ZjBhNjk5NDFTSDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmFsbG9jOjpoZWVjZTRhYmEwNmMxNDgyN1QQZnV6enljbHVzdGVyX25ld1URcnVzdF9iZWdpbl91bndpbmRWEV9fd2JpbmRnZW5fbWFsbG9jVxJfX3JkbF9hbGxvY196ZXJvZWRYN2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9pbnVzZTo6aGEyZjljZjllYTQ0YzY1NWRZF19fd2JnX2Z1enp5Y2x1c3Rlcl9mcmVlWi1jb3JlOjpwYW5pY2tpbmc6OnBhbmljX2ZtdDo6aGY2OWM4YjA4YmM5ZDJlZTVb0AFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjplcnJvcjo6PGltcGwgY29yZTo6Y29udmVydDo6RnJvbTxhbGxvYzo6c3RyaW5nOjpTdHJpbmc+IGZvciBhbGxvYzo6Ym94ZWQ6OkJveDxkeW4gc3RkOjplcnJvcjo6RXJyb3IrY29yZTo6bWFya2VyOjpTZW5kK2NvcmU6Om1hcmtlcjo6U3luYz4+Ojpmcm9tOjpTdHJpbmdFcnJvcj46Omg0NTIzZGIyMmQ4MTk2NzMyXF5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlBhbmljUGF5bG9hZD46OmhkOWFiNjUwNTI0OTJiNTJhXQpydXN0X3BhbmljXjVkbG1hbGxvYzo6ZGxtYWxsb2M6OlNlZ21lbnQ6OmhvbGRzOjpoMDc0MjIyNDFmNTBiNjY2Ml9CZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2V0X2ludXNlX2FuZF9waW51c2U6Omg3NWMyZjgzN2NiNzYyZjI2YEJkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzZXRfZnJlZV93aXRoX3BpbnVzZTo6aGRlNjQ0MTA3MjFjZDU1OGZhOWhhc2hicm93bjo6cmF3OjpGYWxsaWJpbGl0eTo6YWxsb2NfZXJyOjpoNmFhMzQ0YzdkOTNmMzQwNGJBaGFzaGJyb3duOjpyYXc6OkZhbGxpYmlsaXR5OjpjYXBhY2l0eV9vdmVyZmxvdzo6aGY1Y2YzYzI2ZmE5ZGQzNmJjQGRsbWFsbG9jOjpkbG1hbGxvYzo6VHJlZUNodW5rOjpsZWZ0bW9zdF9jaGlsZDo6aDQ4ZjI1MDJmY2RjZmEwYTJkBGZtaW5lCHJ1c3Rfb29tZj9kbG1hbGxvYzo6ZGxtYWxsb2M6OmxlZnRzaGlmdF9mb3JfdHJlZV9pbmRleDo6aDYyZGFjZjI4Y2NiZTAxYmVnT2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9zaXplX2FuZF9waW51c2Vfb2ZfZnJlZV9jaHVuazo6aDk0Y2ViMDgyMzkxZjg5OWRoPjxjb3JlOjpmbXQ6OkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjMmVmNmEyNTE0MmU1MTRhaTJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoMjViYjI0M2U1ZmRjZjY1NGoyY29yZTo6b3B0aW9uOjpPcHRpb248VD46OnVud3JhcDo6aGNjYzVkNDVjYTc5YTI4M2RrL2RsbWFsbG9jOjpkbG1hbGxvYzo6YWxpZ25fdXA6Omg0NzcyYzYyNDRhZWM2NzEzbA5fX3J1c3RfcmVhbGxvY20PX193YmluZGdlbl9mcmVlbklzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg0MzhlY2VhZjQ5ZDYyOWNkbzBkbG1hbGxvYzo6ZGxtYWxsb2M6OmxlZnRfYml0czo6aGZiZjMxMzhlNzVhNTZmZTlwMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZTBmYjBlYzU1NmE2YWI0YXEMX19ydXN0X2FsbG9jchNfX3J1c3RfYWxsb2NfemVyb2Vkc2Y8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmdldDo6aGI1Y2JmNzBiNTNhNzJmMWV0PnN0ZDo6c3lzOjp3YXNtOjpjb21tb246Omhhc2htYXBfcmFuZG9tX2tleXM6OmhjZTExZmY0ZmMxMWNkZjNmdTRkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpjaW51c2U6Omg1ZTg3OWQwNDMzMDIyODk1djpkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpjbGVhcl9waW51c2U6OmgxZTg0YjJmMjgzYWQ4ZTg5dzNkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjppbnVzZTo6aDhjZmM2NjY1YWFlOWIyODd4MjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhhODIwZDMzNzlkZTNjODIzeQ5fX3J1c3RfZGVhbGxvY3owZGxtYWxsb2M6OmRsbWFsbG9jOjpsZWFzdF9iaXQ6OmhmMWFjN2ZiYjBjOWFmY2Y2ezVkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjptbWFwcGVkOjpoNDMzZDA0OGU5OTNiMzk2ZXxQZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2V0X3NpemVfYW5kX3BpbnVzZV9vZl9pbnVzZV9jaHVuazo6aGIzY2RhN2VlMWJlNTE5Yjh9M2RsbWFsbG9jOjpkbG1hbGxvYzo6U2VnbWVudDo6dG9wOjpoN2JhNGNiMzViMmFiNzhiM347PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aGRmNjkwZDIxN2VmYjQyMWV/NGFsbG9jOjpyYXdfdmVjOjpjYXBhY2l0eV9vdmVyZmxvdzo6aDU2YzhkMjBkOWVlZmM5M2SAATljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDY2ZDU1MmM5MTcyMDk1NjiBAU5jb3JlOjpmbXQ6Om51bTo6aW1wOjo8aW1wbCBjb3JlOjpmbXQ6OkRpc3BsYXkgZm9yIHUzMj46OmZtdDo6aDNkZjMwN2NmOWJiMGY1NjCCAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVygwEaX19ydXN0X2FsbG9jX2Vycm9yX2hhbmRsZXKEASp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aDk5ODhlYWI2MzQ5ZjIyZTKFATF3YXNtX2JpbmRnZW46Ol9fcnQ6OnRocm93X251bGw6OmhhNWEyMTQ1Mjk2NzJiNThlhgEyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aGY2NGRmMTI0ODYxZDkwY2aHATJkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzaXplOjpoNDc3MTgyMDE5Y2NiNDY4N4gBNGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnBpbnVzZTo6aDQ5ZDgzZmU0ODZhOGM0MjaJATlkbG1hbGxvYzo6ZGxtYWxsb2M6OlNlZ21lbnQ6OmlzX2V4dGVybjo6aGNiOTMzMjIxOTVlZmJjY2WKATlkbG1hbGxvYzo6ZGxtYWxsb2M6OlNlZ21lbnQ6OnN5c19mbGFnczo6aGJhMDlkZjEwZjRkMTlkNmWLATNhbGxvYzo6YWxsb2M6OmhhbmRsZV9hbGxvY19lcnJvcjo6aDQ1YTcxNDkwMGQyOWJlZjWMAQhfX3JnX29vbY0BKndhc21fYmluZGdlbjo6dGhyb3dfdmFsOjpoYzMyOTY4NDdlODA0MzA1Zo4BC19fcmRsX2FsbG9jjwE5ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6cGx1c19vZmZzZXQ6OmhhMjgxYzhmMzdkZTljYjY1kAE6ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6bWludXNfb2Zmc2V0OjpoOTU2YTRlMmFkZjNlZWZjYpEBNGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnRvX21lbTo6aDk1NWI5NjNhN2E4MzQzMDGSATZkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpmcm9tX21lbTo6aGVlNmMxOWIyZmYwMjhiNWOTATV3YXNtX2JpbmRnZW46Ol9fcnQ6Om1hbGxvY19mYWlsdXJlOjpoYWVmMWNmNDgyMGIzYjAzZpQBDV9fcmRsX2RlYWxsb2OVATZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6bmV4dDo6aDExNWRjZTczMzNlNWZjMmOWATZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6cHJldjo6aDA2ZDU4YTg1NTBhZGZiMzaXAT5jb3JlOjpwYW5pYzo6cGFuaWNfaW5mbzo6UGFuaWNJbmZvOjptZXNzYWdlOjpoMzY3MDJkM2QwMDRhNmRlZZgBP2NvcmU6OnBhbmljOjpwYW5pY19pbmZvOjpQYW5pY0luZm86OmxvY2F0aW9uOjpoNmY1NjdkZmJlOGNkODJhZpkBMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGJmYmNhNGZiMzVlOWJkNmSaATE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmhlZjJiNDkyYzVhMTk5MWY3mwEmc3RkOjpwcm9jZXNzOjphYm9ydDo6aGIwZGQ1ZDM2OTFkMTgwY2KcARJfX3J1c3Rfc3RhcnRfcGFuaWOdATxkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpmZW5jZXBvc3RfaGVhZDo6aDhmODM1ZTBkYmYzNmNhYzSeATdkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6Y2h1bms6OmgwNDU3MjY1MzJhMWUwYzhknwFIPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6cmVtYXA6OmgyZmYwMDA2Njg0NmVhOTIxoAFMPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6ZnJlZV9wYXJ0OjpoZTBhNmVmMGMwMWI5MzRjYqEBRzxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmZyZWU6OmhiNWEwNzRkZDM5M2NkOTBhogFTPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6Y2FuX3JlbGVhc2VfcGFydDo6aGJhZGNhOWFlZjQ0MjYyM2SjAVI8ZGxtYWxsb2M6OnN5czo6U3lzdGVtIGFzIGRsbWFsbG9jOjpBbGxvY2F0b3I+OjphbGxvY2F0ZXNfemVyb3M6OmhjZjIwMjExMWZjYmE0MDhkpAFMPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6cGFnZV9zaXplOjpoMmMyOWJmOGIzMTU2NmU2M6UBP2hhc2hicm93bjo6cmF3OjpnZW5lcmljOjpHcm91cDo6c3RhdGljX2VtcHR5OjpoNjJkYjI2NjM1MmU2ZDgzOaYBMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aDUwOWE4MmYyOThiMTIxYmOnAWljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm11dCBzdGQ6OmlvOjpXcml0ZTo6d3JpdGVfZm10OjpBZGFwdGVyPGFsbG9jOjp2ZWM6OlZlYzx1OD4+Pjo6aGJiMDVmNDI3YzNmYWFjYWOoATdzdGQ6OmFsbG9jOjpkZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6OmhjODU0MWY3YzFlYzMyYWZlqQEwY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZ1OD46Omg4OTRhZTY2NGNlOTM5MzJkqgFvY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZjb3JlOjppdGVyOjphZGFwdGVyczo6Y29waWVkOjpDb3BpZWQ8Y29yZTo6c2xpY2U6Oml0ZXI6Okl0ZXI8dTg+Pj46OmhhYTRlMDBjMTg2ZjdiMDE0APuAgIAACXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS41Ni4xICg1OWVlZDhhMmEgMjAyMS0xMS0wMSkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjc4ICg3ZjgyMGRiNGIp");

                        var d3stWasm = async () => {
                            await init$1(wasm_code);
                            return exports$1;
                        };

    // @ts-ignore
    function getClusterMean(data, dimKeys, cluster) {
        if (!cluster.length)
            throw new Error('empty cluster');
        const mean = {};
        for (const key of dimKeys) {
            let dimSum = 0;
            for (const i of cluster) {
                dimSum += data[i][key];
            }
            mean[key] = dimSum / cluster.length;
        }
        return mean;
    }
    function eucDistFinite(dimKeys, a, b) {
        let sqSum = 0;
        for (const key of dimKeys) {
            const dimDist = Math.abs(a[key] - b[key]);
            if (Number.isFinite(dimDist))
                sqSum += dimDist * dimDist;
        }
        return Math.sqrt(sqSum);
    }
    function hierarchicalClusterStep(data, dimKeys, clusters) {
        const clusterMeans = clusters.map(cluster => getClusterMean(data, dimKeys, cluster));
        let shortestPair = null;
        for (let i = 0; i < clusters.length; i++) {
            for (let j = 0; j < clusters.length; j++) {
                if (i === j)
                    break; // don't need to check reverse pairs (also ensures i < j)
                const distance = eucDistFinite(dimKeys, clusterMeans[i], clusterMeans[j]);
                if (!shortestPair || distance < shortestPair[0]) {
                    shortestPair = [distance, i, j];
                }
            }
        }
        if (shortestPair) {
            const [, i, j] = shortestPair;
            const newClusters = clusters.slice();
            newClusters[i] = newClusters[i].concat(newClusters.splice(j, 1)[0]);
            return newClusters;
        }
        return null;
    }
    function isClusteringDone(data, dimKeys, clusters, params) {
        if (params.targetCount && clusters.length > params.targetCount)
            return false;
        if (params.targetRadius) {
            // ensure half of all clusters fulfill the radius requirement
            let passingClusters = 0;
            for (const cluster of clusters) {
                const mean = getClusterMean(data, dimKeys, cluster);
                let distanceSum = 0;
                for (const i of cluster) {
                    distanceSum += eucDistFinite(dimKeys, mean, data[i]);
                }
                if (distanceSum / cluster.length > params.targetRadius) {
                    passingClusters++;
                }
            }
            if (passingClusters < clusters.length / 2)
                return false;
        }
        return true;
    }
    /**
     * Simple hierarchical clustering.
     */
    const hierarchicalCluster = async function hierarchicalCluster(data, dimensions, params) {
        if (!data.length)
            return [];
        const dimKeys = dimensions.map(dim => dim.name);
        let clusters = [];
        // start with every data point in its own cluster
        for (let i = 0; i < data.length; i++)
            clusters.push([i]);
        // iterate
        do {
            const newClusters = hierarchicalClusterStep(data, dimKeys, clusters);
            if (newClusters)
                clusters = newClusters;
            else
                break;
        } while (!isClusteringDone(data, dimKeys, clusters, params));
        return clusters;
    };
    const fuzzyCluster = async function fuzzyCluster(data, dimensions, params) {
        const d3st = await d3stWasm();
        const clustering = new d3st.FuzzyCluster(params.epsMin, params.epsMax, params.ptsMin, params.ptsMax);
        const dimensionCount = dimensions.length;
        const packedData = new Float32Array(data.length * dimensionCount);
        for (let i = 0; i < data.length; i++) {
            let offset = i * dimensionCount;
            for (const dim of dimensions) {
                packedData[offset] = dim.normalize(data[i][dim.name]);
                offset++;
            }
        }
        const result = clustering.cluster(new Uint8Array(packedData.buffer), dimensionCount);
        const packedClusters = new Uint16Array(result.buffer);
        const clusters = [];
        const noise = [];
        let cursor = 0;
        while (cursor < packedClusters.length) {
            const pointCount = packedClusters[cursor++];
            const cluster = [];
            for (let i = 0; i < pointCount; i++) {
                const id = packedClusters[cursor++];
                const category = id >> 14;
                const index = id & 0x3FFF;
                packedClusters[cursor++];
                if (category === 2) {
                    // noise gets to be in its own cluster
                    noise.push(index);
                }
                else {
                    cluster.push(index);
                }
            }
            if (cluster.length > 0) {
                clusters.push(cluster);
            }
        }
        if (noise.length > 0) {
            clusters.push(noise);
        }
        //const counts = clusters.map(c => c.length).join(", ");
        //console.info(`Found ${clusters.length} clusters: ${counts}`);
        //console.info(`${noise.length} points in noise cluster.`);
        return clusters;
    };

    function lerp$1(a, b, t) {
        return (b - a) * t + a;
    }
    function clamp(x, l, h) {
        return Math.max(l, Math.min(x, h));
    }

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        lerp: lerp$1,
        clamp: clamp,
        hierarchicalCluster: hierarchicalCluster,
        fuzzyCluster: fuzzyCluster
    });

    /**
     * Common utilities
     * @module glMatrix
     */
    // Configuration Constants
    var EPSILON = 0.000001;
    var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
    if (!Math.hypot) Math.hypot = function () {
      var y = 0,
          i = arguments.length;

      while (i--) {
        y += arguments[i] * arguments[i];
      }

      return Math.sqrt(y);
    };

    /**
     * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
     * @module mat4
     */

    /**
     * Creates a new identity mat4
     *
     * @returns {mat4} a new 4x4 matrix
     */

    function create$2() {
      var out = new ARRAY_TYPE(16);

      if (ARRAY_TYPE != Float32Array) {
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
      }

      out[0] = 1;
      out[5] = 1;
      out[10] = 1;
      out[15] = 1;
      return out;
    }
    /**
     * Multiplies two mat4s
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the first operand
     * @param {ReadonlyMat4} b the second operand
     * @returns {mat4} out
     */

    function multiply(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7];
      var a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11];
      var a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15]; // Cache only the current line of the second matrix

      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }
    /**
     * Translate a mat4 by the given vector
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to translate
     * @param {ReadonlyVec3} v vector to translate by
     * @returns {mat4} out
     */

    function translate(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2];
      var a00, a01, a02, a03;
      var a10, a11, a12, a13;
      var a20, a21, a22, a23;

      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }

      return out;
    }
    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to rotate
     * @param {Number} rad the angle to rotate the matrix by
     * @param {ReadonlyVec3} axis the axis to rotate around
     * @returns {mat4} out
     */

    function rotate(out, a, rad, axis) {
      var x = axis[0],
          y = axis[1],
          z = axis[2];
      var len = Math.hypot(x, y, z);
      var s, c, t;
      var a00, a01, a02, a03;
      var a10, a11, a12, a13;
      var a20, a21, a22, a23;
      var b00, b01, b02;
      var b10, b11, b12;
      var b20, b21, b22;

      if (len < EPSILON) {
        return null;
      }

      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11]; // Construct the elements of the rotation matrix

      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

      out[0] = a00 * b00 + a10 * b01 + a20 * b02;
      out[1] = a01 * b00 + a11 * b01 + a21 * b02;
      out[2] = a02 * b00 + a12 * b01 + a22 * b02;
      out[3] = a03 * b00 + a13 * b01 + a23 * b02;
      out[4] = a00 * b10 + a10 * b11 + a20 * b12;
      out[5] = a01 * b10 + a11 * b11 + a21 * b12;
      out[6] = a02 * b10 + a12 * b11 + a22 * b12;
      out[7] = a03 * b10 + a13 * b11 + a23 * b12;
      out[8] = a00 * b20 + a10 * b21 + a20 * b22;
      out[9] = a01 * b20 + a11 * b21 + a21 * b22;
      out[10] = a02 * b20 + a12 * b21 + a22 * b22;
      out[11] = a03 * b20 + a13 * b21 + a23 * b22;

      if (a !== out) {
        // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }

      return out;
    }
    /**
     * Creates a matrix from a vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, dest, vec);
     *
     * @param {mat4} out mat4 receiving operation result
     * @param {ReadonlyVec3} v Translation vector
     * @returns {mat4} out
     */

    function fromTranslation(out, v) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = v[0];
      out[13] = v[1];
      out[14] = v[2];
      out[15] = 1;
      return out;
    }
    /**
     * Generates a perspective projection matrix with the given bounds.
     * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
     * which matches WebGL/OpenGL's clip volume.
     * Passing null/undefined/no value for far will generate infinite projection matrix.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum, can be null or Infinity
     * @returns {mat4} out
     */

    function perspectiveNO(out, fovy, aspect, near, far) {
      var f = 1.0 / Math.tan(fovy / 2),
          nf;
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[15] = 0;

      if (far != null && far !== Infinity) {
        nf = 1 / (near - far);
        out[10] = (far + near) * nf;
        out[14] = 2 * far * near * nf;
      } else {
        out[10] = -1;
        out[14] = -2 * near;
      }

      return out;
    }
    /**
     * Alias for {@link mat4.perspectiveNO}
     * @function
     */

    var perspective = perspectiveNO;
    /**
     * Generates a orthogonal projection matrix with the given bounds.
     * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
     * which matches WebGL/OpenGL's clip volume.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */

    function orthoNO(out, left, right, bottom, top, near, far) {
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      out[0] = -2 * lr;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = -2 * bt;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 2 * nf;
      out[11] = 0;
      out[12] = (left + right) * lr;
      out[13] = (top + bottom) * bt;
      out[14] = (far + near) * nf;
      out[15] = 1;
      return out;
    }
    /**
     * Alias for {@link mat4.orthoNO}
     * @function
     */

    var ortho = orthoNO;
    /**
     * Multiply each element of the matrix by a scalar.
     *
     * @param {mat4} out the receiving matrix
     * @param {ReadonlyMat4} a the matrix to scale
     * @param {Number} b amount to scale the matrix's elements by
     * @returns {mat4} out
     */

    function multiplyScalar(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      out[3] = a[3] * b;
      out[4] = a[4] * b;
      out[5] = a[5] * b;
      out[6] = a[6] * b;
      out[7] = a[7] * b;
      out[8] = a[8] * b;
      out[9] = a[9] * b;
      out[10] = a[10] * b;
      out[11] = a[11] * b;
      out[12] = a[12] * b;
      out[13] = a[13] * b;
      out[14] = a[14] * b;
      out[15] = a[15] * b;
      return out;
    }
    /**
     * Adds two mat4's after multiplying each element of the second operand by a scalar value.
     *
     * @param {mat4} out the receiving vector
     * @param {ReadonlyMat4} a the first operand
     * @param {ReadonlyMat4} b the second operand
     * @param {Number} scale the amount to scale b's elements by before adding
     * @returns {mat4} out
     */

    function multiplyScalarAndAdd(out, a, b, scale) {
      out[0] = a[0] + b[0] * scale;
      out[1] = a[1] + b[1] * scale;
      out[2] = a[2] + b[2] * scale;
      out[3] = a[3] + b[3] * scale;
      out[4] = a[4] + b[4] * scale;
      out[5] = a[5] + b[5] * scale;
      out[6] = a[6] + b[6] * scale;
      out[7] = a[7] + b[7] * scale;
      out[8] = a[8] + b[8] * scale;
      out[9] = a[9] + b[9] * scale;
      out[10] = a[10] + b[10] * scale;
      out[11] = a[11] + b[11] * scale;
      out[12] = a[12] + b[12] * scale;
      out[13] = a[13] + b[13] * scale;
      out[14] = a[14] + b[14] * scale;
      out[15] = a[15] + b[15] * scale;
      return out;
    }
    /**
     * Alias for {@link mat4.multiply}
     * @function
     */

    var mul = multiply;

    /**
     * 4 Dimensional Vector
     * @module vec4
     */

    /**
     * Creates a new, empty vec4
     *
     * @returns {vec4} a new 4D vector
     */

    function create$1() {
      var out = new ARRAY_TYPE(4);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
      }

      return out;
    }
    /**
     * Transforms the vec4 with a mat4.
     *
     * @param {vec4} out the receiving vector
     * @param {ReadonlyVec4} a the vector to transform
     * @param {ReadonlyMat4} m matrix to transform with
     * @returns {vec4} out
     */

    function transformMat4(out, a, m) {
      var x = a[0],
          y = a[1],
          z = a[2],
          w = a[3];
      out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
      out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
      out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
      out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
      return out;
    }
    /**
     * Perform some operation over an array of vec4s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */

    (function () {
      var vec = create$1();
      return function (a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 4;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          vec[3] = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
          a[i + 3] = vec[3];
        }

        return a;
      };
    })();

    /**
     * 2 Dimensional Vector
     * @module vec2
     */

    /**
     * Creates a new, empty vec2
     *
     * @returns {vec2} a new 2D vector
     */

    function create() {
      var out = new ARRAY_TYPE(2);

      if (ARRAY_TYPE != Float32Array) {
        out[0] = 0;
        out[1] = 0;
      }

      return out;
    }
    /**
     * Performs a linear interpolation between two vec2's
     *
     * @param {vec2} out the receiving vector
     * @param {ReadonlyVec2} a the first operand
     * @param {ReadonlyVec2} b the second operand
     * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
     * @returns {vec2} out
     */

    function lerp(out, a, b, t) {
      var ax = a[0],
          ay = a[1];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      return out;
    }
    /**
     * Perform some operation over an array of vec2s.
     *
     * @param {Array} a the array of vectors to iterate over
     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
     * @param {Number} offset Number of elements to skip at the beginning of the array
     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
     * @param {Function} fn Function to call for each vector in the array
     * @param {Object} [arg] additional argument to pass to fn
     * @returns {Array} a
     * @function
     */

    (function () {
      var vec = create();
      return function (a, stride, offset, count, fn, arg) {
        var i, l;

        if (!stride) {
          stride = 2;
        }

        if (!offset) {
          offset = 0;
        }

        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }

        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
        }

        return a;
      };
    })();

    // Perspective or orthographic rotation
    /**
     * A rotation transition can swap out a single dimension.
     * It uses depth to add the new dimension and rotates the entire view to the new dimension pair.
     * If perspective is used, it will first "zoom out" from orthographic to perspective projection.
     */
    class RotationTransition {
        constructor(views, params) {
            this.views = views;
            this.params = params;
            this.hasMeaningfulIntermediates = true;
            this.isReady = true;
            this.transitions = [];
            for (let i = 0; i < views.length - 1; i++) {
                this.transitions.push(new SingleRotationTransition(views[i], views[i + 1], params));
            }
        }
        async prepare() { }
        getX(t, point) {
            t *= this.views.length - 1;
            const transIndex = Math.min(Math.floor(t), this.transitions.length - 1);
            return this.transitions[transIndex].getX(t - transIndex, point);
        }
        getY(t, point) {
            t *= this.views.length - 1;
            const transIndex = Math.min(Math.floor(t), this.transitions.length - 1);
            return this.transitions[transIndex].getY(t - transIndex, point);
        }
    }
    RotationTransition.requiresCommonDimensions = true;
    RotationTransition.canSwapDimensions = false;
    RotationTransition.params = {
        perspective: {
            type: 'number',
            domain: [0, 1],
            default: 0,
            round: false
        },
        perspFov: {
            shouldShow: (params) => (params.perspective || 0) > 0,
            type: 'number',
            domain: [0, 90],
            default: 60,
            round: true
        },
        cameraDistance: {
            shouldShow: (params) => (params.perspective || 0) > 0,
            type: 'number',
            domain: [0, 5],
            default: 1.5,
            round: false
        },
        staged: {
            shouldShow: (params) => (params.perspective || 0) > 0,
            type: 'bool',
            default: false
        },
        ease: {
            shouldShow: (params) => params.staged || false,
            type: 'enum',
            variants: [
                { label: 'linear', value: (t) => t },
                { label: 'quad', value: d3Ease.easeQuad },
                { label: 'cubic', value: d3Ease.easeCubic },
                { label: 'exp', value: d3Ease.easeExp }
            ],
            default: 1
        },
        zoomTime: {
            shouldShow: (params) => params.staged || false,
            type: 'number',
            domain: [0, 0.5],
            default: 0.2,
            round: false
        }
    };
    class SingleRotationTransition {
        constructor(startView, endView, params) {
            this.startView = startView;
            this.endView = endView;
            this.params = params;
            this.params.perspective = this.params.perspective || 0;
            this.params.perspFov = this.params.perspFov || 60;
            this.params.cameraDistance = this.params.cameraDistance || 1.5;
            this.rotAxis = startView.x === endView.x ? 'x' : 'y';
        }
        getRotAxisAsVector() {
            if (this.rotAxis === 'x')
                return [1, 0, 0];
            if (this.rotAxis === 'y')
                return [0, 1, 0];
            if (this.rotAxis === 'z')
                return [0, 0, 1];
            throw new Error('invalid axis');
        }
        ease(t) {
            if (this.params.ease) {
                return this.params.ease(t);
            }
            return d3Ease.easeQuad(t);
        }
        cacheData(t) {
            this.cachedT = t;
            let rotation = 0;
            let perspFactor = 0;
            const perspTransTime = (this.params.zoomTime || 0.2) * this.params.perspective * (this.params.staged ? 1 : 0);
            if (t < perspTransTime) {
                perspFactor = this.ease(t / perspTransTime);
            }
            else if (t < 1 - perspTransTime) {
                const uneased = (t - perspTransTime) / (1 - 2 * perspTransTime);
                const eased = this.params.staged ? this.ease(uneased) : uneased; // don't need to ease if there's no staging
                rotation = lerp$1(uneased, eased, this.params.perspective);
                perspFactor = 1;
            }
            else {
                rotation = 1;
                perspFactor = perspTransTime ? 1 - this.ease((t - 1 + perspTransTime) / perspTransTime) : 0;
            }
            if (!this.params.staged) {
                // ease in sync with rotation (sort of)
                // perspFactor = Math.sin(Math.acos(2 * t - 1));
                // scaled solution to (x)^2 + (y+1)^2 = 2; a small circle segment
                perspFactor = 2.41 * (Math.sqrt(2 - (2 * t - 1) ** 2) - 1);
            }
            // TODO: allow user to specify direction
            if (this.rotAxis === 'x')
                rotation *= -1; // FIXME: why
            this.cachedRotation = create$2();
            // rotate around center
            translate(this.cachedRotation, this.cachedRotation, [0.5, 0.5, 0.5]);
            rotate(this.cachedRotation, this.cachedRotation, rotation * Math.PI / 2, this.getRotAxisAsVector());
            translate(this.cachedRotation, this.cachedRotation, [-0.5, -0.5, -0.5]);
            const ortho$1 = ortho(create$2(), -0.5, 0.5, -0.5, 0.5, 0.1, 1.5);
            const persp = perspective(create$2(), this.params.perspFov / 180 * Math.PI, 1, 0.1, 1.5);
            const viewOffset = fromTranslation(create$2(), [-0.5, -0.5, -this.params.cameraDistance]);
            this.cachedProjection = multiplyScalar(create$2(), ortho$1, 1 - perspFactor * this.params.perspective);
            this.cachedProjection = multiplyScalarAndAdd(this.cachedProjection, this.cachedProjection, persp, perspFactor * this.params.perspective);
            mul(this.cachedProjection, this.cachedProjection, viewOffset);
        }
        getProjection(t) {
            if (t !== this.cachedT)
                this.cacheData(t);
            return this.cachedProjection;
        }
        getRotation(t) {
            if (t !== this.cachedT)
                this.cacheData(t);
            return this.cachedRotation;
        }
        projectPoint(t, point) {
            const proj = this.getProjection(t);
            const rot = this.getRotation(t);
            const p = create$1();
            p[3] = 1;
            if (this.rotAxis === 'x') {
                p[0] = this.startView.getX(point);
                p[1] = this.startView.getY(point);
                p[2] = this.endView.getY(point);
            }
            else if (this.rotAxis === 'y') {
                p[0] = this.startView.getX(point);
                p[1] = this.startView.getY(point);
                p[2] = this.endView.getX(point);
            }
            transformMat4(p, p, rot);
            transformMat4(p, p, proj);
            p[0] /= p[3];
            p[1] /= p[3];
            p[2] /= p[3];
            p[3] = 1;
            return p;
        }
        getX(t, point) {
            return this.projectPoint(t, point)[0] / 2 + 0.5;
        }
        getY(t, point) {
            return this.projectPoint(t, point)[1] / 2 + 0.5;
        }
    }

    class StraightTransition {
        constructor(views) {
            this.views = views;
            this.hasMeaningfulIntermediates = true;
            this.isReady = true;
        }
        async prepare() { }
        getX(t, point) {
            t *= this.views.length - 1;
            const startView = this.views[Math.floor(t)];
            const endView = this.views[Math.floor(t + 1)] || startView;
            return lerp$1(startView.getX(point), endView.getX(point), t - Math.floor(t));
        }
        getY(t, point) {
            t *= this.views.length - 1;
            const startView = this.views[Math.floor(t)];
            const endView = this.views[Math.floor(t + 1)] || startView;
            return lerp$1(startView.getY(point), endView.getY(point), t - Math.floor(t));
        }
    }
    StraightTransition.requiresCommonDimensions = false;
    StraightTransition.canSwapDimensions = true;
    StraightTransition.params = {};

    // Common data types for spline and spline-worker
    /** Evaluates a bzier curve. */
    function bezierEval(bezier, t) {
        if (bezier.length <= 1) {
            return bezier[0];
        }
        else {
            const newBezier = [];
            for (let i = 0; i < bezier.length - 1; i++) {
                newBezier.push(lerp(create(), bezier[i], bezier[i + 1], t));
            }
            return bezierEval(newBezier, t);
        }
    }

    var WorkerClass = null;

    try {
        var WorkerThreads =
            typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
            typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
            typeof require === 'function' && require('worker_threads');
        WorkerClass = WorkerThreads.Worker;
    } catch(e) {} // eslint-disable-line

    function decodeBase64$1(base64, enableUnicode) {
        return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
    }

    function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64$1(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        return function WorkerFactory(options) {
            return new WorkerClass(body, Object.assign({}, options, { eval: true }));
        };
    }

    function decodeBase64(base64, enableUnicode) {
        var binaryString = atob(base64);
        if (enableUnicode) {
            var binaryView = new Uint8Array(binaryString.length);
            for (var i = 0, n = binaryString.length; i < n; ++i) {
                binaryView[i] = binaryString.charCodeAt(i);
            }
            return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
        }
        return binaryString;
    }

    function createURL(base64, sourcemapArg, enableUnicodeArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
        var source = decodeBase64(base64, enableUnicode);
        var start = source.indexOf('\n', 10) + 1;
        var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
        var blob = new Blob([body], { type: 'application/javascript' });
        return URL.createObjectURL(blob);
    }

    function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
        var url;
        return function WorkerFactory(options) {
            url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
            return new Worker(url, options);
        };
    }

    var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

    function isNodeJS() {
        return kIsNodeJS;
    }

    function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
        if (isNodeJS()) {
            return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
        }
        return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
    }

    var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLyoqCiAgICogQ29tbW9uIHV0aWxpdGllcwogICAqIEBtb2R1bGUgZ2xNYXRyaXgKICAgKi8KICB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7CiAgaWYgKCFNYXRoLmh5cG90KSBNYXRoLmh5cG90ID0gZnVuY3Rpb24gKCkgewogICAgdmFyIHkgPSAwLAogICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoOwoKICAgIHdoaWxlIChpLS0pIHsKICAgICAgeSArPSBhcmd1bWVudHNbaV0gKiBhcmd1bWVudHNbaV07CiAgICB9CgogICAgcmV0dXJuIE1hdGguc3FydCh5KTsKICB9OwoKICAvKioKICAgKiAyIERpbWVuc2lvbmFsIFZlY3RvcgogICAqIEBtb2R1bGUgdmVjMgogICAqLwoKICAvKioKICAgKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyCiAgICoKICAgKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yCiAgICovCgogIGZ1bmN0aW9uIGNyZWF0ZSgpIHsKICAgIHZhciBvdXQgPSBuZXcgQVJSQVlfVFlQRSgyKTsKCiAgICBpZiAoQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHsKICAgICAgb3V0WzBdID0gMDsKICAgICAgb3V0WzFdID0gMDsKICAgIH0KCiAgICByZXR1cm4gb3V0OwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzCiAgICoKICAgKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudAogICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50CiAgICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvcgogICAqLwoKICBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHsKICAgIHZhciBvdXQgPSBuZXcgQVJSQVlfVFlQRSgyKTsKICAgIG91dFswXSA9IHg7CiAgICBvdXRbMV0gPSB5OwogICAgcmV0dXJuIG91dDsKICB9CiAgLyoqCiAgICogQWRkcyB0d28gdmVjMidzCiAgICoKICAgKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvcgogICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kCiAgICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kCiAgICogQHJldHVybnMge3ZlYzJ9IG91dAogICAqLwoKICBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7CiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTsKICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdOwogICAgcmV0dXJuIG91dDsKICB9CiAgLyoqCiAgICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGEKICAgKgogICAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yCiAgICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmQKICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmQKICAgKiBAcmV0dXJucyB7dmVjMn0gb3V0CiAgICovCgogIGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikgewogICAgb3V0WzBdID0gYVswXSAtIGJbMF07CiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTsKICAgIHJldHVybiBvdXQ7CiAgfQogIC8qKgogICAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyCiAgICoKICAgKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvcgogICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGUKICAgKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieQogICAqIEByZXR1cm5zIHt2ZWMyfSBvdXQKICAgKi8KCiAgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7CiAgICBvdXRbMF0gPSBhWzBdICogYjsKICAgIG91dFsxXSA9IGFbMV0gKiBiOwogICAgcmV0dXJuIG91dDsKICB9CiAgLyoqCiAgICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzIncwogICAqCiAgICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmQKICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmQKICAgKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGIKICAgKi8KCiAgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikgewogICAgdmFyIHggPSBiWzBdIC0gYVswXSwKICAgICAgICB5ID0gYlsxXSAtIGFbMV07CiAgICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5KTsKICB9CiAgLyoqCiAgICogTm9ybWFsaXplIGEgdmVjMgogICAqCiAgICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3IKICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplCiAgICogQHJldHVybnMge3ZlYzJ9IG91dAogICAqLwoKICBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7CiAgICB2YXIgeCA9IGFbMF0sCiAgICAgICAgeSA9IGFbMV07CiAgICB2YXIgbGVuID0geCAqIHggKyB5ICogeTsKCiAgICBpZiAobGVuID4gMCkgewogICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlPwogICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7CiAgICB9CgogICAgb3V0WzBdID0gYVswXSAqIGxlbjsKICAgIG91dFsxXSA9IGFbMV0gKiBsZW47CiAgICByZXR1cm4gb3V0OwogIH0KICAvKioKICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzIncwogICAqCiAgICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3IKICAgKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZAogICAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZAogICAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHMKICAgKiBAcmV0dXJucyB7dmVjMn0gb3V0CiAgICovCgogIGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7CiAgICB2YXIgYXggPSBhWzBdLAogICAgICAgIGF5ID0gYVsxXTsKICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpOwogICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7CiAgICByZXR1cm4gb3V0OwogIH0KICAvKioKICAgKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9CiAgICogQGZ1bmN0aW9uCiAgICovCgogIHZhciBzdWIgPSBzdWJ0cmFjdDsKICAvKioKICAgKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuCiAgICoKICAgKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlcgogICAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkCiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheQogICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5CiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5CiAgICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmbgogICAqIEByZXR1cm5zIHtBcnJheX0gYQogICAqIEBmdW5jdGlvbgogICAqLwoKICAoZnVuY3Rpb24gKCkgewogICAgdmFyIHZlYyA9IGNyZWF0ZSgpOwogICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHsKICAgICAgdmFyIGksIGw7CgogICAgICBpZiAoIXN0cmlkZSkgewogICAgICAgIHN0cmlkZSA9IDI7CiAgICAgIH0KCiAgICAgIGlmICghb2Zmc2V0KSB7CiAgICAgICAgb2Zmc2V0ID0gMDsKICAgICAgfQoKICAgICAgaWYgKGNvdW50KSB7CiAgICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbCA9IGEubGVuZ3RoOwogICAgICB9CgogICAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkgewogICAgICAgIHZlY1swXSA9IGFbaV07CiAgICAgICAgdmVjWzFdID0gYVtpICsgMV07CiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7CiAgICAgICAgYVtpXSA9IHZlY1swXTsKICAgICAgICBhW2kgKyAxXSA9IHZlY1sxXTsKICAgICAgfQoKICAgICAgcmV0dXJuIGE7CiAgICB9OwogIH0pKCk7CgogIHZhciBEaW1lbnNpb25NYXBwaW5nVHlwZTsNCiAgKGZ1bmN0aW9uIChEaW1lbnNpb25NYXBwaW5nVHlwZSkgew0KICAgICAgRGltZW5zaW9uTWFwcGluZ1R5cGVbIkxpbmVhciJdID0gImxpbmVhciI7DQogICAgICBEaW1lbnNpb25NYXBwaW5nVHlwZVsiTG9nIl0gPSAibG9nIjsNCiAgfSkoRGltZW5zaW9uTWFwcGluZ1R5cGUgfHwgKERpbWVuc2lvbk1hcHBpbmdUeXBlID0ge30pKTsNCiAgY29uc3QgbWFwcGluZ3MgPSB7DQogICAgICBbRGltZW5zaW9uTWFwcGluZ1R5cGUuTGluZWFyXTogew0KICAgICAgICAgIHRvTm9ybWFsaXplZChbbWluLCBtYXhdLCB2YWx1ZSkgew0KICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pOw0KICAgICAgICAgIH0sDQogICAgICAgICAgdG9Eb21haW4oW21pbiwgbWF4XSwgdmFsdWUpIHsNCiAgICAgICAgICAgICAgcmV0dXJuIG1pbiArIHZhbHVlICogKG1heCAtIG1pbik7DQogICAgICAgICAgfQ0KICAgICAgfSwNCiAgICAgIFtEaW1lbnNpb25NYXBwaW5nVHlwZS5Mb2ddOiB7DQogICAgICAgICAgdG9Ob3JtYWxpemVkKFttaW4sIG1heF0sIHZhbHVlKSB7DQogICAgICAgICAgICAgIGNvbnN0IGEgPSB2YWx1ZSAtIG1pbjsNCiAgICAgICAgICAgICAgY29uc3QgYiA9IG1heCAtIG1pbjsNCiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKGEgKyAxKSAvIE1hdGgubG9nKGIgKyAxKTsNCiAgICAgICAgICB9LA0KICAgICAgICAgIHRvRG9tYWluKFttaW4sIG1heF0sIHZhbHVlKSB7DQogICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBNYXRoLmxvZyhtYXggLSBtaW4gKyAxKTsNCiAgICAgICAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguZXhwKHZhbHVlKSAtIDE7DQogICAgICAgICAgfQ0KICAgICAgfQ0KICB9Ow0KICAvKioNCiAgICogQSBkYXRhIGRpbWVuc2lvbi4NCiAgICoNCiAgICogSW4gZ2VuZXJhbCwgZGltZW5zaW9ucyBhcmUgYXNzdW1lZCB0byBiZSB1c2FibGUgYXMgYSBkaW1lbnNpb24gaW4gZXVjbGlkZWFuIHNwYWNlLg0KICAgKi8NCiAgY2xhc3MgRGltZW5zaW9uIHsNCiAgICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRvbWFpbiwgbWFwcGluZyA9IERpbWVuc2lvbi5MaW5lYXIpIHsNCiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOw0KICAgICAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluOw0KICAgICAgICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmc7DQogICAgICB9DQogICAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGZyb20gdGhpcyBkaW1lbnNpb24ncyBkb21haW4gdG8gMC4uMS4gICovDQogICAgICBub3JtYWxpemUodmFsdWUpIHsNCiAgICAgICAgICByZXR1cm4gbWFwcGluZ3NbdGhpcy5tYXBwaW5nXS50b05vcm1hbGl6ZWQodGhpcy5kb21haW4sIHZhbHVlKTsNCiAgICAgIH0NCiAgICAgIC8qKiBFeHBhbmRzIGEgbm9ybWFsaXplZCB2YWx1ZSBbMC4uMV0gdG8gYSB2YWx1ZSBpbiB0aGUgcmVndWxhciBkb21haW4gcmFuZ2UuICovDQogICAgICBleHBhbmQodmFsdWUpIHsNCiAgICAgICAgICByZXR1cm4gbWFwcGluZ3NbdGhpcy5tYXBwaW5nXS50b0RvbWFpbih0aGlzLmRvbWFpbiwgdmFsdWUpOw0KICAgICAgfQ0KICAgICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG9iamVjdCBlcXVhbHMgdGhlIG90aGVyIG9iamVjdC4gKi8NCiAgICAgIGVxKG90aGVyKSB7DQogICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSAmJiB0aGlzLmRvbWFpblswXSA9PT0gb3RoZXIuZG9tYWluWzBdICYmIHRoaXMuZG9tYWluWzFdID09PSBvdGhlci5kb21haW5bMV07DQogICAgICB9DQogICAgICAvKioNCiAgICAgICAqIENyZWF0ZXMgYSBuZXcgZGltZW5zaW9uIGZyb20gdGhlIGdpdmVuIGRhdGEuDQogICAgICAgKg0KICAgICAgICogQHBhcmFtIGtleSB0aGUga2V5IGluIHRoZSBEYXRhUG9pbnRzIHRoYXQgY29udGFpbnMgdGhpcyBkaW1lbnNpb24ncyBkYXRhDQogICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSB3aXRoIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgZG9tYWluDQogICAgICAgKiBAcGFyYW0gcGFkZGluZyBhZGRpdGlvbmFsIHBhZGRpbmcgKG11bHRpcGxpY2F0aXZlOiB0aGUgZG9tYWluIHdpbGwgYmUgc2NhbGVkIGJ5IHBhZGRpbmcgKyAxKQ0KICAgICAgICovDQogICAgICBzdGF0aWMgZnJvbURhdGEoa2V5LCBkYXRhLCBwYWRkaW5nID0gMCkgew0KICAgICAgICAgIGxldCBtaW4gPSBJbmZpbml0eTsNCiAgICAgICAgICBsZXQgbWF4ID0gLUluZmluaXR5Ow0KICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZGF0YSkgew0KICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvaW50W2tleV07DQogICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikNCiAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlOw0KICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpDQogICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTsNCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWluKSkNCiAgICAgICAgICAgICAgbWluID0gMDsNCiAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtYXgpKQ0KICAgICAgICAgICAgICBtYXggPSAwOw0KICAgICAgICAgIGlmIChwYWRkaW5nKSB7DQogICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluOw0KICAgICAgICAgICAgICBtaW4gLT0gcmFuZ2UgKiBwYWRkaW5nIC8gMjsNCiAgICAgICAgICAgICAgbWF4ICs9IHJhbmdlICogcGFkZGluZyAvIDI7DQogICAgICAgICAgfQ0KICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKGtleSwgW21pbiwgbWF4XSk7DQogICAgICB9DQogIH0NCiAgRGltZW5zaW9uLkxpbmVhciA9IERpbWVuc2lvbk1hcHBpbmdUeXBlLkxpbmVhcjsNCiAgRGltZW5zaW9uLkxvZyA9IERpbWVuc2lvbk1hcHBpbmdUeXBlLkxvZzsKCiAgLyoqDQogICAqIFJlcHJlc2VudHMgYSB2aWV3IG9mIHR3byBkYXRhIGRpbWVuc2lvbnMgYXMgYSBzY2F0dGVyIHBsb3QuDQogICAqLw0KICBjbGFzcyBTY2F0dGVyVmlldyB7DQogICAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7DQogICAgICAgICAgdGhpcy54ID0geDsNCiAgICAgICAgICB0aGlzLnkgPSB5Ow0KICAgICAgfQ0KICAgICAgLyoqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgWCBwb3NpdGlvbiBvZiBhIHBvaW50IChpbiAwLi4xKS4gKi8NCiAgICAgIGdldFgocG9pbnQpIHsNCiAgICAgICAgICByZXR1cm4gdGhpcy54Lm5vcm1hbGl6ZShwb2ludFt0aGlzLngubmFtZV0pOw0KICAgICAgfQ0KICAgICAgLyoqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgWSBwb3NpdGlvbiBvZiBhIHBvaW50IChpbiAwLi4xKS4gKi8NCiAgICAgIGdldFkocG9pbnQpIHsNCiAgICAgICAgICByZXR1cm4gdGhpcy55Lm5vcm1hbGl6ZShwb2ludFt0aGlzLnkubmFtZV0pOw0KICAgICAgfQ0KICAgICAgdG9TdHJpbmcoKSB7DQogICAgICAgICAgcmV0dXJuIGBTY2F0dGVyVmlldyh4OiAke3RoaXMueC5uYW1lLnRvU3RyaW5nKCl9LCB5OiAke3RoaXMueS5uYW1lLnRvU3RyaW5nKCl9KWA7DQogICAgICB9DQogICAgICAvKioNCiAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyB2aWV3IGNhbiBiZSB0cmFuc2l0aW9uZWQgdG8gdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNpdGlvbi4NCiAgICAgICogSWYgbm90LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXJyb3IuDQogICAgICAqLw0KICAgICAgdmFsaWRhdGVUcmFuc2l0aW9uVG8odmlldywgd2l0aFR5cGUpIHsNCiAgICAgICAgICBjb25zdCB0cmFuc1R5cGUgPSB3aXRoVHlwZTsNCiAgICAgICAgICBpZiAodHJhbnNUeXBlLnJlcXVpcmVzQ29tbW9uRGltZW5zaW9ucykgew0KICAgICAgICAgICAgICBpZiAoIXRoaXMueC5lcSh2aWV3LngpICYmICF0aGlzLnguZXEodmlldy55KSAmJiAhdGhpcy55LmVxKHZpZXcueCkgJiYgIXRoaXMueS5lcSh2aWV3LnkpKSB7DQogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHZpZXcgJHt0aGlzLnRvU3RyaW5nKCl9IGFuZCAke3ZpZXcudG9TdHJpbmcoKX0gd2l0aCAke3RyYW5zVHlwZS5uYW1lfTogbm8gY29tbW9uIGRpbWVuc2lvbnNgKTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICBpZiAoIXRyYW5zVHlwZS5jYW5Td2FwRGltZW5zaW9ucykgew0KICAgICAgICAgICAgICBpZiAodGhpcy54LmVxKHZpZXcueSkgfHwgdGhpcy55LmVxKHZpZXcueCkpIHsNCiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHRyYW5zaXRpb25zIGJldHdlZW4gdmlldyAke3RoaXMudG9TdHJpbmcoKX0gYW5kICR7dmlldy50b1N0cmluZygpfSB3aXRoICR7dHJhbnNUeXBlLm5hbWV9OiBzd2FwcGluZyBpcyBub3Qgc3VwcG9ydGVkYCk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICB9DQogICAgICAvKioNCiAgICAgICAqIFRyYW5zaXRpb25zIHRoaXMgdmlldyB3aXRoIHRoZSBnaXZlbiB0cmFuc2l0aW9uIHR5cGUgYW5kIHBhcmFtZXRlcnMgdG8gdGhlIGxhc3QgdmlldyBhY3Jvc3MNCiAgICAgICAqIGFsbCBpbnRlcm1lZGlhdGUgdmlld3MuDQogICAgICAgKg0KICAgICAgICogQHBhcmFtIHdpdGhUeXBlIHRoZSB0cmFuc2l0aW9uIHR5cGUNCiAgICAgICAqIEBwYXJhbSBwYXJhbXMgcGFyYW1ldGVycyBmb3IgdGhlIHRyYW5zaXRpb24NCiAgICAgICAqIEBwYXJhbSB2aWV3cyBpbnRlcm1lZGlhdGUgdmlld3MgYW5kIGEgZmluYWwgdmlldy4gVGhlIGZpbmFsIHZpZXcgaXMgcmVxdWlyZWQNCiAgICAgICAqLw0KICAgICAgdHJhbnNpdGlvblRvKHdpdGhUeXBlLCBwYXJhbXMsIC4uLnZpZXdzKSB7DQogICAgICAgICAgaWYgKCF2aWV3cy5sZW5ndGgpDQogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHRyYW5zaXRpb24gdG8gbm90aGluZycpOw0KICAgICAgICAgIGNvbnN0IHRyYW5zVHlwZSA9IHdpdGhUeXBlOw0KICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25WaWV3cyA9IFt0aGlzLCAuLi52aWV3c107DQogICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aW9uVmlld3MubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgIHRyYW5zaXRpb25WaWV3c1tpXS52YWxpZGF0ZVRyYW5zaXRpb25Ubyh0cmFuc2l0aW9uVmlld3NbaSArIDFdLCB0cmFuc1R5cGUpOw0KICAgICAgICAgIH0NCiAgICAgICAgICByZXR1cm4gbmV3IHRyYW5zVHlwZSh0cmFuc2l0aW9uVmlld3MsIHBhcmFtcyk7DQogICAgICB9DQogIH0KCiAgLy8gQ29tbW9uIGRhdGEgdHlwZXMgZm9yIHNwbGluZSBhbmQgc3BsaW5lLXdvcmtlcg0KICAvKiogRXZhbHVhdGVzIGEgYsOpemllciBjdXJ2ZS4gKi8NCiAgZnVuY3Rpb24gYmV6aWVyRXZhbChiZXppZXIsIHQpIHsNCiAgICAgIGlmIChiZXppZXIubGVuZ3RoIDw9IDEpIHsNCiAgICAgICAgICByZXR1cm4gYmV6aWVyWzBdOw0KICAgICAgfQ0KICAgICAgZWxzZSB7DQogICAgICAgICAgY29uc3QgbmV3QmV6aWVyID0gW107DQogICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZXppZXIubGVuZ3RoIC0gMTsgaSsrKSB7DQogICAgICAgICAgICAgIG5ld0Jlemllci5wdXNoKGxlcnAoY3JlYXRlKCksIGJlemllcltpXSwgYmV6aWVyW2kgKyAxXSwgdCkpOw0KICAgICAgICAgIH0NCiAgICAgICAgICByZXR1cm4gYmV6aWVyRXZhbChuZXdCZXppZXIsIHQpOw0KICAgICAgfQ0KICB9CgogIGxldCB3YXNtOwoKICBsZXQgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pOwoKICBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoKTsKCiAgbGV0IGNhY2hlZ2V0VWludDhNZW1vcnkwID0gbnVsbDsKICBmdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7CiAgICAgIGlmIChjYWNoZWdldFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWdldFVpbnQ4TWVtb3J5MC5idWZmZXIgIT09IHdhc20ubWVtb3J5LmJ1ZmZlcikgewogICAgICAgICAgY2FjaGVnZXRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpOwogICAgICB9CiAgICAgIHJldHVybiBjYWNoZWdldFVpbnQ4TWVtb3J5MDsKICB9CgogIGZ1bmN0aW9uIGdldFN0cmluZ0Zyb21XYXNtMChwdHIsIGxlbikgewogICAgICByZXR1cm4gY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKGdldFVpbnQ4TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgbGVuKSk7CiAgfQoKICBjb25zdCBoZWFwID0gbmV3IEFycmF5KDMyKS5maWxsKHVuZGVmaW5lZCk7CgogIGhlYXAucHVzaCh1bmRlZmluZWQsIG51bGwsIHRydWUsIGZhbHNlKTsKCiAgbGV0IGhlYXBfbmV4dCA9IGhlYXAubGVuZ3RoOwoKICBmdW5jdGlvbiBhZGRIZWFwT2JqZWN0KG9iaikgewogICAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7CiAgICAgIGNvbnN0IGlkeCA9IGhlYXBfbmV4dDsKICAgICAgaGVhcF9uZXh0ID0gaGVhcFtpZHhdOwoKICAgICAgaGVhcFtpZHhdID0gb2JqOwogICAgICByZXR1cm4gaWR4OwogIH0KCiAgZnVuY3Rpb24gZ2V0T2JqZWN0KGlkeCkgeyByZXR1cm4gaGVhcFtpZHhdOyB9CgogIGZ1bmN0aW9uIGRyb3BPYmplY3QoaWR4KSB7CiAgICAgIGlmIChpZHggPCAzNikgcmV0dXJuOwogICAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7CiAgICAgIGhlYXBfbmV4dCA9IGlkeDsKICB9CgogIGZ1bmN0aW9uIHRha2VPYmplY3QoaWR4KSB7CiAgICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpOwogICAgICBkcm9wT2JqZWN0KGlkeCk7CiAgICAgIHJldHVybiByZXQ7CiAgfQoKICBsZXQgV0FTTV9WRUNUT1JfTEVOID0gMDsKCiAgZnVuY3Rpb24gcGFzc0FycmF5OFRvV2FzbTAoYXJnLCBtYWxsb2MpIHsKICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiAxKTsKICAgICAgZ2V0VWludDhNZW1vcnkwKCkuc2V0KGFyZywgcHRyIC8gMSk7CiAgICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7CiAgICAgIHJldHVybiBwdHI7CiAgfQoKICBsZXQgY2FjaGVnZXRJbnQzMk1lbW9yeTAgPSBudWxsOwogIGZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHsKICAgICAgaWYgKGNhY2hlZ2V0SW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZ2V0SW50MzJNZW1vcnkwLmJ1ZmZlciAhPT0gd2FzbS5tZW1vcnkuYnVmZmVyKSB7CiAgICAgICAgICBjYWNoZWdldEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7CiAgICAgIH0KICAgICAgcmV0dXJuIGNhY2hlZ2V0SW50MzJNZW1vcnkwOwogIH0KCiAgZnVuY3Rpb24gZ2V0QXJyYXlVOEZyb21XYXNtMChwdHIsIGxlbikgewogICAgICByZXR1cm4gZ2V0VWludDhNZW1vcnkwKCkuc3ViYXJyYXkocHRyIC8gMSwgcHRyIC8gMSArIGxlbik7CiAgfQogIC8qKgogICovCiAgY2xhc3MgRnV6enlDbHVzdGVyIHsKCiAgICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7CiAgICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKEZ1enp5Q2x1c3Rlci5wcm90b3R5cGUpOwogICAgICAgICAgb2JqLnB0ciA9IHB0cjsKCiAgICAgICAgICByZXR1cm4gb2JqOwogICAgICB9CgogICAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7CiAgICAgICAgICBjb25zdCBwdHIgPSB0aGlzLnB0cjsKICAgICAgICAgIHRoaXMucHRyID0gMDsKCiAgICAgICAgICByZXR1cm4gcHRyOwogICAgICB9CgogICAgICBmcmVlKCkgewogICAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTsKICAgICAgICAgIHdhc20uX193YmdfZnV6enljbHVzdGVyX2ZyZWUocHRyKTsKICAgICAgfQogICAgICAvKioKICAgICAgKiBAcGFyYW0ge251bWJlcn0gZXBzX21pbgogICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlcHNfbWF4CiAgICAgICogQHBhcmFtIHtudW1iZXJ9IHB0c19taW4KICAgICAgKiBAcGFyYW0ge251bWJlcn0gcHRzX21heAogICAgICAqLwogICAgICBjb25zdHJ1Y3RvcihlcHNfbWluLCBlcHNfbWF4LCBwdHNfbWluLCBwdHNfbWF4KSB7CiAgICAgICAgICB2YXIgcmV0ID0gd2FzbS5mdXp6eWNsdXN0ZXJfbmV3KGVwc19taW4sIGVwc19tYXgsIHB0c19taW4sIHB0c19tYXgpOwogICAgICAgICAgcmV0dXJuIEZ1enp5Q2x1c3Rlci5fX3dyYXAocmV0KTsKICAgICAgfQogICAgICAvKioKICAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBhY2tlZF9kYXRhCiAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpbWVuc2lvbnMKICAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0KICAgICAgKi8KICAgICAgY2x1c3RlcihwYWNrZWRfZGF0YSwgZGltZW5zaW9ucykgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTsKICAgICAgICAgICAgICB2YXIgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHBhY2tlZF9kYXRhLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTsKICAgICAgICAgICAgICB2YXIgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjsKICAgICAgICAgICAgICB3YXNtLmZ1enp5Y2x1c3Rlcl9jbHVzdGVyKHJldHB0ciwgdGhpcy5wdHIsIHB0cjAsIGxlbjAsIGRpbWVuc2lvbnMpOwogICAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTsKICAgICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07CiAgICAgICAgICAgICAgdmFyIHYxID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7CiAgICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUocjAsIHIxICogMSk7CiAgICAgICAgICAgICAgcmV0dXJuIHYxOwogICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpOwogICAgICAgICAgfQogICAgICB9CiAgfQoKICBhc3luYyBmdW5jdGlvbiBsb2FkKG1vZHVsZSwgaW1wb3J0cykgewogICAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7CiAgICAgICAgICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7CgogICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT0gJ2FwcGxpY2F0aW9uL3dhc20nKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XG4iLCBlKTsKCiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7CiAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpOwoKICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTsKCiAgICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkgewogICAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTsKCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsKICAgICAgICAgIH0KICAgICAgfQogIH0KCiAgYXN5bmMgZnVuY3Rpb24gaW5pdChpbnB1dCkgewogICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgaW5wdXQgPSBuZXcgVVJMKCdpbmRleF9iZy53YXNtJywgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgbmV3IFVSTCgnc3BsaW5lLXdvcmtlci5qcycsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWYpKTsKICAgICAgfQogICAgICBjb25zdCBpbXBvcnRzID0ge307CiAgICAgIGltcG9ydHMud2JnID0ge307CiAgICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fc3RyaW5nX25ldyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHsKICAgICAgICAgIHZhciByZXQgPSBnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSk7CiAgICAgICAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpOwogICAgICB9OwogICAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3Rocm93ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKSk7CiAgICAgIH07CiAgICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fcmV0aHJvdyA9IGZ1bmN0aW9uKGFyZzApIHsKICAgICAgICAgIHRocm93IHRha2VPYmplY3QoYXJnMCk7CiAgICAgIH07CgogICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFVSTCkpIHsKICAgICAgICAgIGlucHV0ID0gZmV0Y2goaW5wdXQpOwogICAgICB9CgoKCiAgICAgIGNvbnN0IHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgbG9hZChhd2FpdCBpbnB1dCwgaW1wb3J0cyk7CgogICAgICB3YXNtID0gaW5zdGFuY2UuZXhwb3J0czsKICAgICAgaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlOwoKICAgICAgcmV0dXJuIHdhc207CiAgfQoKICB2YXIgZXhwb3J0cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoewogICAgX19wcm90b19fOiBudWxsLAogICAgRnV6enlDbHVzdGVyOiBGdXp6eUNsdXN0ZXIsCiAgICAnZGVmYXVsdCc6IGluaXQKICB9KTsKCiAgY29uc3QgYmFzZTY0Y29kZXMgPSBbNjIsMCwwLDAsNjMsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDAsMCwwLDAsMCwwLDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxXTsKCiAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QmFzZTY0Q29kZShjaGFyQ29kZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTY0Y29kZXNbY2hhckNvZGUgLSA0M107CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKHN0cikgewogICAgICAgICAgICAgICAgICBsZXQgbWlzc2luZ09jdGV0cyA9IHN0ci5lbmRzV2l0aCgiPT0iKSA/IDIgOiBzdHIuZW5kc1dpdGgoIj0iKSA/IDEgOiAwOwogICAgICAgICAgICAgICAgICBsZXQgbiA9IHN0ci5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzICogKG4gLyA0KSk7CiAgICAgICAgICAgICAgICAgIGxldCBidWZmZXI7CgogICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBuOyBpICs9IDQsIGogKz0gMykgewogICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0KICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCYXNlNjRDb2RlKHN0ci5jaGFyQ29kZUF0KGkpKSA8PCAxOCB8CiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpICsgMSkpIDw8IDEyIHwKICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCYXNlNjRDb2RlKHN0ci5jaGFyQ29kZUF0KGkgKyAyKSkgPDwgNiB8CiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpICsgMykpOwogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2pdID0gYnVmZmVyID4+IDE2OwogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ogKyAxXSA9IChidWZmZXIgPj4gOCkgJiAweEZGOwogICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ogKyAyXSA9IGJ1ZmZlciAmIDB4RkY7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3ViYXJyYXkoMCwgcmVzdWx0Lmxlbmd0aCAtIG1pc3NpbmdPY3RldHMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhc21fY29kZSA9IGJhc2U2NF9kZWNvZGUoIkFHRnpiUUVBQUFBQmpJR0FnQUFWWUFBQVlBQUJmMkFCZndCZ0FYOEJmMkFCZndGK1lBSi9md0JnQW45L0FYOWdBbjkvQVh4Z0EzOS9md0JnQTM5L2Z3Ri9ZQVIvZjM5L0FHQUVmMzkvZndGL1lBVi9mMzkvZndCZ0JYOS9mMzkvQVg5Z0JuOS9mMzkvZndGL1lBUi9mMzUvQUdBRWYzNS9md0YvWUFOK2YzOEJmMkFDZkh3QmZHQUdmSHgvZjM5L0FYeGdCSHg4Zkh3QmZ3TE5nSUNBQUFNRGQySm5GVjlmZDJKcGJtUm5aVzVmYzNSeWFXNW5YMjVsZHdBR0EzZGlaeEJmWDNkaWFXNWtaMlZ1WDNSb2NtOTNBQVVEZDJKbkVsOWZkMkpwYm1SblpXNWZjbVYwYUhKdmR3QUNBNnFCZ0lBQXFBRU1Bd29LQ2dvS0Nnb0tDZ2tDRGhNTEJnZ0ZDUk1URXdVRkV4TUlCUk1URUFZUENRWUZCUkVGQlFJRkFRVUZDQWdJQndnRkNnY0ZDUWtJQ0FVS0Nnb0ZCUVVJREFnSUNBWUdCZ2tKQ3dnR0JRZ1VBZ01HQlFJRkFnSUZCZ1VJQ2dVREVnVURCUVlEQmdZTEJRSURCZ1lHQlFJREFnTUdDQU1EQlFNR0FBWUdBd1VGQUFBREF3TURCUVVDQmdZR0F3TUFDQU1EQXdNRUJBQURBUU1OQ3drR0F3TUJCQUlGQWdJRWhZQ0FnQUFCY0FFYUdnV0RnSUNBQUFFQUVRYUpnSUNBQUFGL0FVR0FnTUFBQ3dlWGdZQ0FBQWNHYldWdGIzSjVBZ0FYWDE5M1ltZGZablY2ZW5samJIVnpkR1Z5WDJaeVpXVUFXUkJtZFhwNmVXTnNkWE4wWlhKZmJtVjNBRlFVWm5WNmVubGpiSFZ6ZEdWeVgyTnNkWE4wWlhJQUF4OWZYM2RpYVc1a1oyVnVYMkZrWkY5MGIxOXpkR0ZqYTE5d2IybHVkR1Z5QUlJQkVWOWZkMkpwYm1SblpXNWZiV0ZzYkc5akFGWVBYMTkzWW1sdVpHZGxibDltY21WbEFHMEpxSUNBZ0FBQkFFRUJDeGxScUFHbkFVMG1TMXd2UGxKelc1b0JtUUdwQVU1K1RHaUJBWUFCY0hpcUFhWUJDcWZpZzRBQXFBSHZIZ0lLZndGK0l3QkJ3QUJySWdVa0FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCUlEwQUlBRW9BZ0FpQmtGL1JnMEJJQUVnQmtFQmFqWUNBQ0FCUVFocUlRY0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQVJCZjJvT0J3RUNBd1FGQmdjQUN5QURRUU54RFN3Z0JFVU5HQ0FEUVFKMklnZ2dDQ0FFYmlJR0lBUnNhdzBzSUFnZ0JFa05CeUFHUVF4c0lnbEJCQkJ4SWdwRkRTTkJBQ0VMSUFWQkFEWUNJQ0FGSUFvMkFoZ2dCU0FHTmdJY0lBWkJBU0FHUVFGTEd5RU1JQVJCQW5RaERTQUNJUXBCQUNFR1FRQWhDUU5BSUFRZ0Myb2lEaUFFU1EwYUlBNGdDRXNOR3lBSlFRRnFJUWtDUUNBR0lBVW9BaHhIRFFBZ0JVRVlhaUFHUVFFUU1TQUZLQUlnSVFZTElBVW9BaGdnQmtFTWJHb2lCaUFFTmdJSUlBWWdCRFlDQkNBR0lBbzJBZ0FnQlNBRktBSWdRUUZxSWdZMkFpQWdDaUFOYWlFS0lBNGhDeUFKSUF4SERRQUxJQVVvQWhnaURrVU5MQ0FGS1FJY0lROE1DQXNnQTBFRGNRMHJJQU5CQW5ZaUJrSC8vLy8vQVhFZ0JrY05IQ0FHUVFOMElncEJBRWdOSEFKQUFrQWdDZzBBUVFRaERnd0JDeUFLUVFRUWNTSU9SUTBiQzBFQUlRUWdCVUVBTmdJZ0lBVWdEallDR0NBRklBcEJBM1lpQ1RZQ0hBSkFJQVpGRFFBZ0JrRi9haUVHSUFJaENnTkFBa0FnQkNBSlJ3MEFJQVZCR0dvZ0NVRUJFRE1nQlNnQ0lDRUVDeUFGS0FJWUlBUkJBM1JxSWdSQkFUWUNCQ0FFSUFvMkFnQWdCU0FGS0FJZ1FRRnFJZ1EyQWlBQ1FDQUdSUTBBSUFaQmYyb2hCaUFLUVFScUlRb2dCU2dDSENFSkRBRUxDeUFGS0FJWUlRNExJQTRORkF3ckN5QURRUU54RFNvZ0EwRUNkaUlPUVFGeERTb2dEa0VCZGlJR1FRTjBJZ1JCQUVnTkd5QU9RUUpKRFJFZ0JFRUVFSEVpQ2tVTklrRUFJUVFnQlVFQU5nSWdJQVVnQ2pZQ0dDQUZJQVkyQWh3Z0JrRUJJQVpCQVVzYklRbEJBaUVHSUFJaENnTkFJQVlnRGtzTkd3SkFJQVFnQlNnQ0hFY05BQ0FGUVJocUlBUkJBUkF6SUFVb0FpQWhCQXNnQlNnQ0dDQUVRUU4wYWlJRVFRSTJBZ1FnQkNBS05nSUFJQVVnQlNnQ0lFRUJhaUlFTmdJZ0lBWkJBbW9oQmlBS1FRaHFJUW9nQ1VGL2FpSUpEUUFMSUFVb0FoZ2lEa1VOS2lBRktRSWNJUThNRWdzZ0EwRURjUTBwSUFOQkFuWWlEaUFPUVFOdUlnWkJBMnhyRFNrZ0JrRURkQ0lFUVFCSURSb2dEa0VEU1EwT0lBUkJCQkJ4SWdwRkRTSkJBQ0VFSUFWQkFEWUNJQ0FGSUFvMkFoZ2dCU0FHTmdJY0lBWkJBU0FHUVFGTEd5RUpRUU1oQmlBQ0lRb0RRQ0FHSUE1TERSd0NRQ0FFSUFVb0FoeEhEUUFnQlVFWWFpQUVRUUVRTXlBRktBSWdJUVFMSUFVb0FoZ2dCRUVEZEdvaUJFRUROZ0lFSUFRZ0NqWUNBQ0FGSUFVb0FpQkJBV29pQkRZQ0lDQUdRUU5xSVFZZ0NrRU1haUVLSUFsQmYyb2lDUTBBQ3lBRktBSVlJZzVGRFNrZ0JTa0NIQ0VQREE4TElBTkJBM0VOS0NBRFFRSjJJZ3RCQTNFTktDQUxRUUoySVFaQkJDRU9JQXRCQkVrTkN5QUdRUU4wSWdSQkJCQnhJZ3BGRFNKQkFDRUVJQVZCQURZQ0lDQUZJQW8yQWhnZ0JTQUdOZ0ljSUFaQkFTQUdRUUZMR3lFSlFRUWhCaUFDSVFvRFFDQUdJQXRMRFJ3Q1FDQUVJQVVvQWh4SERRQWdCVUVZYWlBRVFRRVFNeUFGS0FJZ0lRUUxJQVVvQWhnZ0JFRURkR29pQkVFRU5nSUVJQVFnQ2pZQ0FDQUZJQVVvQWlCQkFXb2lCRFlDSUNBR1FRUnFJUVlnQ2tFUWFpRUtJQWxCZjJvaUNRMEFDeUFGS0FJWUlnNUZEU2dNREFzZ0EwRURjUTBuSUFOQkFuWWlEaUFPUVFWdUlnWkJCV3hyRFNjZ0RrRUZTUTBJSUFaQkEzUWlCRUVFRUhFaUNrVU5Ja0VBSVFRZ0JVRUFOZ0lnSUFVZ0NqWUNHQ0FGSUFZMkFod2dCa0VCSUFaQkFVc2JJUWxCQlNFR0lBSWhDZ05BSUFZZ0Rrc05IQUpBSUFRZ0JTZ0NIRWNOQUNBRlFSaHFJQVJCQVJBeklBVW9BaUFoQkFzZ0JTZ0NHQ0FFUVFOMGFpSUVRUVUyQWdRZ0JDQUtOZ0lBSUFVZ0JTZ0NJRUVCYWlJRU5nSWdJQVpCQldvaEJpQUtRUlJxSVFvZ0NVRi9haUlKRFFBTElBVW9BaGdpRGtVTkp5QUZLUUljSVE4TUNRc2dBMEVEY1EwbUlBTkJBbllpRGlBT1FRWnVJZ1pCQm14ckRTWWdEa0VHU1EwRklBWkJBM1FpQkVFRUVIRWlDa1VOSWtFQUlRUWdCVUVBTmdJZ0lBVWdDallDR0NBRklBWTJBaHdnQmtFQklBWkJBVXNiSVFsQkJpRUdJQUloQ2dOQUlBWWdEa3NOSEFKQUlBUWdCU2dDSEVjTkFDQUZRUmhxSUFSQkFSQXpJQVVvQWlBaEJBc2dCU2dDR0NBRVFRTjBhaUlFUVFZMkFnUWdCQ0FLTmdJQUlBVWdCU2dDSUVFQmFpSUVOZ0lnSUFaQkJtb2hCaUFLUVJocUlRb2dDVUYvYWlJSkRRQUxJQVVvQWhnaURrVU5KaUFGS1FJY0lROE1CZ3NnQTBFRGNRMGxJQU5CQW5ZaURpQU9RUWR1SWdaQkIyeHJEU1VnRGtFSFNRMENJQVpCQTNRaUJFRUVFSEVpQ2tVTklrRUFJUVFnQlVFQU5nSWdJQVVnQ2pZQ0dDQUZJQVkyQWh3Z0JrRUJJQVpCQVVzYklRbEJCeUVHSUFJaENnTkFJQVlnRGtzTkhBSkFJQVFnQlNnQ0hFY05BQ0FGUVJocUlBUkJBUkF6SUFVb0FpQWhCQXNnQlNnQ0dDQUVRUU4wYWlJRVFRYzJBZ1FnQkNBS05nSUFJQVVnQlNnQ0lFRUJhaUlFTmdJZ0lBWkJCMm9oQmlBS1FSeHFJUW9nQ1VGL2FpSUpEUUFMSUFVb0FoZ2lEa1VOSlNBRktRSWNJUThNQXdzZ0JVRUFOZ0lnSUFVZ0JqWUNIQ0FGS1FJY0lROUJCQ0VPQ3lBRlFSaHFJQWNnRGlBUFFpQ0lweEFGSUFWQkNHb2dCU2dDR0NJSklBVW9BaUFpQkJBVUFrQWdCRVVOQUNBRVFReHNJUVlnQ1NFRUEwQUNRQ0FFUVFScUtBSUFJZ3BGRFFBZ0NrRUVkQ0lLUlEwQUlBUW9BZ0FnQ2tFSUVIa0xJQVJCREdvaEJDQUdRWFJxSWdZTkFBc0xBa0FnQlNnQ0hDSUVSUTBBSUFSQkRHd2lCRVVOQUNBSklBUkJCQkI1Q3lBUHB5SUVSUTBpSUFSQkRHd2lCRVVOSWd3aEN5QUZRUUEyQWlBZ0JTQUdOZ0ljSUFVcEFod2hEMEVFSVE0TElBVkJHR29nQnlBT0lBOUNJSWluRUFzZ0JVRUlhaUFGS0FJWUlna2dCU2dDSUNJRUVCUUNRQ0FFUlEwQUlBUkJER3doQmlBSklRUURRQUpBSUFSQkJHb29BZ0FpQ2tVTkFDQUtRUVIwSWdwRkRRQWdCQ2dDQUNBS1FRZ1FlUXNnQkVFTWFpRUVJQVpCZEdvaUJnMEFDd3NDUUNBRktBSWNJZ1JGRFFBZ0JFRU1iQ0lFUlEwQUlBa2dCRUVFRUhrTElBK25JZ1JGRFNBZ0JFRURkQ0lFRFI4TUlBc2dCVUVBTmdJZ0lBVWdCallDSENBRktRSWNJUTlCQkNFT0N5QUZRUmhxSUFjZ0RpQVBRaUNJcHhBTUlBVkJDR29nQlNnQ0dDSUpJQVVvQWlBaUJCQVVBa0FnQkVVTkFDQUVRUXhzSVFZZ0NTRUVBMEFDUUNBRVFRUnFLQUlBSWdwRkRRQWdDa0VFZENJS1JRMEFJQVFvQWdBZ0NrRUlFSGtMSUFSQkRHb2hCQ0FHUVhScUlnWU5BQXNMQWtBZ0JTZ0NIQ0lFUlEwQUlBUkJER3dpQkVVTkFDQUpJQVJCQkJCNUN5QVBweUlFUlEwZUlBUkJBM1FpQkEwZERCNExJQVZCQURZQ0lDQUZJQVkyQWh3Z0JTa0NIQ0VQUVFRaERnc2dCVUVZYWlBSElBNGdEMElnaUtjUUJpQUZRUWhxSUFVb0FoZ2lDU0FGS0FJZ0lnUVFGQUpBSUFSRkRRQWdCRUVNYkNFR0lBa2hCQU5BQWtBZ0JFRUVhaWdDQUNJS1JRMEFJQXBCQkhRaUNrVU5BQ0FFS0FJQUlBcEJDQkI1Q3lBRVFReHFJUVFnQmtGMGFpSUdEUUFMQ3dKQUlBVW9BaHdpQkVVTkFDQUVRUXhzSWdSRkRRQWdDU0FFUVFRUWVRc2dENmNpQkVVTkhDQUVRUU4wSWdRTkd3d2NDeUFGUVFBMkFpQWdCU0FHTmdJY0N5QUZRUmhxSUFjZ0RpQUZLUUljSWc5Q0lJaW5FQWNnQlVFSWFpQUZLQUlZSWdrZ0JTZ0NJQ0lFRUJRQ1FDQUVSUTBBSUFSQkRHd2hCaUFKSVFRRFFBSkFJQVJCQkdvb0FnQWlDa1VOQUNBS1FRUjBJZ3BGRFFBZ0JDZ0NBQ0FLUVFnUWVRc2dCRUVNYWlFRUlBWkJkR29pQmcwQUN3c0NRQ0FGS0FJY0lnUkZEUUFnQkVFTWJDSUVSUTBBSUFrZ0JFRUVFSGtMSUErbklnUkZEUm9nQkVFRGRDSUVEUmtNR2dzZ0JVRUFOZ0lnSUFVZ0JqWUNIQ0FGS1FJY0lROUJCQ0VPQ3lBRlFSaHFJQWNnRGlBUFFpQ0lweEFJSUFWQkNHb2dCU2dDR0NJSklBVW9BaUFpQkJBVUFrQWdCRVVOQUNBRVFReHNJUVlnQ1NFRUEwQUNRQ0FFUVFScUtBSUFJZ3BGRFFBZ0NrRUVkQ0lLUlEwQUlBUW9BZ0FnQ2tFSUVIa0xJQVJCREdvaEJDQUdRWFJxSWdZTkFBc0xBa0FnQlNnQ0hDSUVSUTBBSUFSQkRHd2lCRVVOQUNBSklBUkJCQkI1Q3lBUHB5SUVSUTBZSUFSQkEzUWlCQTBYREJnTElBVkJBRFlDSUNBRklBWTJBaHdnQlNrQ0hDRVBRUVFoRGdzZ0JVRVlhaUFISUE0Z0QwSWdpS2NRQ1NBRlFRaHFJQVVvQWhnaUNTQUZLQUlnSWdRUUZBSkFJQVJGRFFBZ0JFRU1iQ0VHSUFraEJBTkFBa0FnQkVFRWFpZ0NBQ0lLUlEwQUlBcEJCSFFpQ2tVTkFDQUVLQUlBSUFwQkNCQjVDeUFFUVF4cUlRUWdCa0YwYWlJR0RRQUxDd0pBSUFVb0Fod2lCRVVOQUNBRVFReHNJZ1JGRFFBZ0NTQUVRUVFRZVFzZ0Q2Y2lCRVVORmlBRVFRTjBJZ1FORlF3V0N5QUZRUmhxSUFjZ0RpQUZLUUljSWc5Q0lJaW5FQW9nQlVFSWFpQUZLQUlZSWdrZ0JTZ0NJQ0lFRUJRQ1FDQUVSUTBBSUFSQkRHd2hCaUFKSVFRRFFBSkFJQVJCQkdvb0FnQWlDa1VOQUNBS1FRUjBJZ3BGRFFBZ0JDZ0NBQ0FLUVFnUWVRc2dCRUVNYWlFRUlBWkJkR29pQmcwQUN3c0NRQ0FGS0FJY0lnUkZEUUFnQkVFTWJDSUVSUTBBSUFrZ0JFRUVFSGtMSUErbklnUkZEUlVnQkVFRGRDSUVEUlFNRlFzUWhRRUFDeENHQVFBTFFkQ0J3QUJCT1VHY2dzQUFFRkFBQ3lBTElBUWdDMnBCcklMQUFCQkpBQXNnQkNBTGFpQUlRYXlDd0FBUVNBQUxJQXBCQkJDTEFRQUxJQVlnRGtHTWdzQUFFRWdBQ3hCL0FBc2dCaUFPUVl5Q3dBQVFTQUFMSUFZZ0MwR01nc0FBRUVnQUN5QUdJQTVCaklMQUFCQklBQXNnQmlBT1FZeUN3QUFRU0FBTElBWWdEa0dNZ3NBQUVFZ0FDeUFKUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFFUVFRUWl3RUFDeUFPSUFSQkJCQjVDeUFGS1FJTUlROGdCU2dDQ0NFRURBRUxRUUFoQkFzQ1FDQURSUTBBSUFJZ0EwRUJFSGtMQWtBZ0JBMEFJQVZCTEdwQkFUWUNBQ0FGUWdFM0Fod2dCVUhjZ3NBQU5nSVlJQVZCQVRZQ05DQUZJQVZCTUdvMkFpZ2dCU0FGUVRocU5nSXdJQVZCQ0dvZ0JVRVlhaEFiSUFVb0FnZ2lCQ0FGS0FJUUVBQWhBd0pBSUFVb0Fnd2lCVVVOQUNBRUlBVkJBUkI1Q3lBQklBRW9BZ0JCZjJvMkFnQWdBeENOQVFBTElBRWdBU2dDQUVGL2FqWUNBQUpBQWtBZ0Q2Y2lBeUFQUWlDSXB5SUJUUTBBQWtBZ0FRMEFJQVFnQTBFQkVIbEJBU0VFREFFTElBUWdBMEVCSUFFUWJDSUVSUTBCQ3lBQUlBRTJBZ1FnQUNBRU5nSUFJQVZCd0FCcUpBQVBDeUFCUVFFUWl3RUFDK1FnQWhCL0FYNGpBRUVRYXlJQkpBQUNRQUpBQWtBZ0FFSDFBVWtOQUVFQUlRSkJBQkNSQVNFRElBTWdBMEVJRUd0QkZFRUlFR3RxUVJCQkNCQnJhbXRCK1A5N2FrRjNjVUY5YWlJRFFRQkJFRUVJRUd0QkFuUnJJZ1FnQkNBRFN4c2dBRTBOQWlBQVFRUnFRUWdRYXlFRFFRQW9BcFNNUUVVTkFVRUFJUVVDUUNBRFFZQUNTUTBBUVI4aEJTQURRZi8vL3dkTERRQWdBMEVHSUFOQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUZDMEVBSUFOcklRSUNRQUpBQWtBZ0JVRUNkRUdnanNBQWFpZ0NBQ0lBUlEwQUlBTWdCUkJtZENFR1FRQWhCMEVBSVFRRFFBSkFJQUFRbmdFUWh3RWlDQ0FEU1EwQUlBZ2dBMnNpQ0NBQ1R3MEFJQWdoQWlBQUlRUWdDQTBBUVFBaEFpQUFJUVFNQXdzZ0FFRVVhaWdDQUNJSUlBY2dDQ0FBSUFaQkhYWkJCSEZxUVJCcUtBSUFJZ0JIR3lBSElBZ2JJUWNnQmtFQmRDRUdJQUFOQUFzQ1FDQUhSUTBBSUFjaEFBd0NDeUFFRFFJTFFRQWhCRUVCSUFWMEVHOUJBQ2dDbEl4QWNTSUFSUTBESUFBUWVtaEJBblJCb0k3QUFHb29BZ0FpQUVVTkF3c0RRQ0FBSUFRZ0FCQ2VBUkNIQVNJSElBTlBJQWNnQTJzaUJ5QUNTWEVpQmhzaEJDQUhJQUlnQmhzaEFpQUFFR01pQUEwQUN5QUVSUTBDQ3dKQVFRQW9BcUNQUUNJQUlBTkpEUUFnQWlBQUlBTnJUdzBDQ3lBRUVKNEJJZ0FnQXhDUEFTRUhJQVFRTEFKQUFrQWdBa0VRUVFnUWEwa05BQ0FBSUFNUWZDQUhJQUlRWndKQUlBSkJnQUpKRFFBZ0J5QUNFQ3NNQWdzZ0FrRURkaUlFUVFOMFFaaU13QUJxSVFJQ1FBSkFRUUFvQXBDTVFDSUdRUUVnQkhRaUJIRkZEUUFnQWlnQ0NDRUVEQUVMUVFBZ0JpQUVjallDa0l4QUlBSWhCQXNnQWlBSE5nSUlJQVFnQnpZQ0RDQUhJQUkyQWd3Z0J5QUVOZ0lJREFFTElBQWdBaUFEYWhCZkN5QUFFSkVCSWdKRkRRRU1BZ3RCRUNBQVFRUnFRUkJCQ0JCclFYdHFJQUJMRzBFSUVHc2hBd0pBQWtBQ1FBSkFBa0FDUUFKQVFRQW9BcENNUUNJSElBTkJBM1lpQW5ZaUFFRURjUTBBSUFOQkFDZ0NvSTlBVFEwSElBQU5BVUVBS0FLVWpFQWlBRVVOQnlBQUVIcG9RUUowUWFDT3dBQnFLQUlBSWdRUW5nRVFod0VnQTJzaEFnSkFJQVFRWXlJQVJRMEFBMEFnQUJDZUFSQ0hBU0FEYXlJSElBSWdCeUFDU1NJSEd5RUNJQUFnQkNBSEd5RUVJQUFRWXlJQURRQUxDeUFFRUo0QklnQWdBeENQQVNFSElBUVFMQ0FDUVJCQkNCQnJTUTBGSUFjUW5nRWhCeUFBSUFNUWZDQUhJQUlRWjBFQUtBS2dqMEFpQkVVTkJDQUVRUU4ySWdoQkEzUkJtSXpBQUdvaEJrRUFLQUtvajBBaEJFRUFLQUtRakVBaUJVRUJJQWgwSWdoeFJRMENJQVlvQWdnaENBd0RDd0pBQWtBZ0FFRi9jMEVCY1NBQ2FpSURRUU4wSWdSQm9JekFBR29vQWdBaUFFRUlhaWdDQUNJQ0lBUkJtSXpBQUdvaUJFWU5BQ0FDSUFRMkFnd2dCQ0FDTmdJSURBRUxRUUFnQjBGK0lBTjNjVFlDa0l4QUN5QUFJQU5CQTNRUVh5QUFFSkVCSVFJTUJ3c0NRQUpBUVFFZ0FrRWZjU0lDZEJCdklBQWdBblJ4RUhwb0lnSkJBM1FpQjBHZ2pNQUFhaWdDQUNJQVFRaHFLQUlBSWdRZ0IwR1lqTUFBYWlJSFJnMEFJQVFnQnpZQ0RDQUhJQVEyQWdnTUFRdEJBRUVBS0FLUWpFQkJmaUFDZDNFMkFwQ01RQXNnQUNBREVId2dBQ0FERUk4QklnUWdBa0VEZENBRGF5SUhFR2NDUUVFQUtBS2dqMEFpQTBVTkFDQURRUU4ySWdaQkEzUkJtSXpBQUdvaEFrRUFLQUtvajBBaEF3SkFBa0JCQUNnQ2tJeEFJZ2hCQVNBR2RDSUdjVVVOQUNBQ0tBSUlJUVlNQVF0QkFDQUlJQVp5TmdLUWpFQWdBaUVHQ3lBQ0lBTTJBZ2dnQmlBRE5nSU1JQU1nQWpZQ0RDQURJQVkyQWdnTFFRQWdCRFlDcUk5QVFRQWdCellDb0k5QUlBQVFrUUVoQWd3R0MwRUFJQVVnQ0hJMkFwQ01RQ0FHSVFnTElBWWdCRFlDQ0NBSUlBUTJBZ3dnQkNBR05nSU1JQVFnQ0RZQ0NBdEJBQ0FITmdLb2owQkJBQ0FDTmdLZ2owQU1BUXNnQUNBQ0lBTnFFRjhMSUFBUWtRRWlBZzBCQ3dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQkJBQ2dDb0k5QUlnSWdBMDhOQUVFQUtBS2tqMEFpQUNBRFN3MEVRUUFoQWlBQlFaQ013QUFnQTBFQUVKRUJJZ0JySUFCQkNCQnJha0VVUVFnUWEycEJFRUVJRUd0cVFRaHFRWUNBQkJCckVGTWdBU2dDQUNJR1JRMExJQUVvQWdnaENVRUFRUUFvQXJDUFFDQUJLQUlFSWdocUlnQTJBckNQUUVFQVFRQW9BclNQUUNJQ0lBQWdBaUFBU3hzMkFyU1BRRUVBS0FLc2owQkZEUUZCdUkvQUFDRUFBMEFnQmlBQUVIMUdEUU1nQUNnQ0NDSUFEUUFNQkFzTFFRQW9BcWlQUUNFQUFrQWdBaUFEYXlJQ1FSQkJDQkJyVHcwQVFRQkJBRFlDcUk5QVFRQW9BcUNQUUNFRFFRQkJBRFlDb0k5QUlBQWdBeEJmSUFBUWtRRWhBZ3dMQ3lBQUlBTVFqd0VoQkVFQUlBSTJBcUNQUUVFQUlBUTJBcWlQUUNBRUlBSVFaeUFBSUFNUWZDQUFFSkVCSVFJTUNndEJBQ2dDekk5QUlnQkZEUU1nQmlBQVNRMEREQWNMSUFBUWlRRU5BQ0FBRUlvQklBbEhEUUFnQUVFQUtBS3NqMEFRWGcwREMwRUFRUUFvQXN5UFFDSUFJQVlnQmlBQVN4czJBc3lQUUNBR0lBaHFJUUpCdUkvQUFDRUFBa0FDUUFKQUEwQWdBQ2dDQUNBQ1JnMEJJQUFvQWdnaUFBMEFEQUlMQ3lBQUVJa0JEUUFnQUJDS0FTQUpSZzBCQzBFQUtBS3NqMEFoQkVHNGo4QUFJUUFDUUFOQUFrQWdBQ2dDQUNBRVN3MEFJQUFRZlNBRVN3MENDeUFBS0FJSUlnQU5BQXRCQUNFQUN5QUFFSDBpQjBFVVFRZ1FheUlLYTBGcGFpRUFJQVFnQUNBQUVKRUJJZ0pCQ0JCcklBSnJhaUlBSUFBZ0JFRVFRUWdRYTJwSkd5SUZFSkVCSVFJZ0JTQUtFSThCSVFCQkFCQ1JBU0lMUVFnUWF5RU1RUlJCQ0JCcklRMUJFRUVJRUdzaERrRUFJQVlnQmhDUkFTSVBRUWdRYXlBUGF5SVFFSThCSWc4MkFxeVBRRUVBSUFnZ0Myb2dEaUFNSUExcWFpQVFhbXNpQ3pZQ3BJOUFJQThnQzBFQmNqWUNCRUVBRUpFQklneEJDQkJySVExQkZFRUlFR3NoRGtFUVFRZ1FheUVRSUE4Z0N4Q1BBU0FRSUE0Z0RTQU1hMnBxTmdJRVFRQkJnSUNBQVRZQ3lJOUFJQVVnQ2hCOFFRQXBBcmlQUUNFUklBSkJDR3BCQUNrQ3dJOUFOd0lBSUFJZ0VUY0NBRUVBSUFrMkFzU1BRRUVBSUFnMkFyeVBRRUVBSUFZMkFyaVBRRUVBSUFJMkFzQ1BRQU5BSUFCQkJCQ1BBU0VDSUFBUW5RRTJBZ1FnQWlFQUlBY2dBa0VFYWtzTkFBc2dCU0FFUmcwSElBVWdCR3NoQUNBRUlBQWdCQ0FBRUk4QkVHQUNRQ0FBUVlBQ1NRMEFJQVFnQUJBckRBZ0xJQUJCQTNZaUFrRURkRUdZak1BQWFpRUFBa0FDUUVFQUtBS1FqRUFpQjBFQklBSjBJZ0p4UlEwQUlBQW9BZ2doQWd3QkMwRUFJQWNnQW5JMkFwQ01RQ0FBSVFJTElBQWdCRFlDQ0NBQ0lBUTJBZ3dnQkNBQU5nSU1JQVFnQWpZQ0NBd0hDeUFBS0FJQUlRY2dBQ0FHTmdJQUlBQWdBQ2dDQkNBSWFqWUNCQ0FHRUpFQklnQkJDQkJySVFJZ0J4Q1JBU0lJUVFnUWF5RUZJQVlnQWlBQWEyb2lBaUFERUk4QklRUWdBaUFERUh3Z0J5QUZJQWhyYWlJQUlBTWdBbXBySVFNQ1FFRUFLQUtzajBBZ0FFWU5BRUVBS0FLb2owQWdBRVlOQkNBQUVIY05CUUpBQWtBZ0FCQ0hBU0lIUVlBQ1NRMEFJQUFRTEF3QkN3SkFJQUJCREdvb0FnQWlCaUFBUVFocUtBSUFJZ2hHRFFBZ0NDQUdOZ0lNSUFZZ0NEWUNDQXdCQzBFQVFRQW9BcENNUUVGK0lBZEJBM1ozY1RZQ2tJeEFDeUFISUFOcUlRTWdBQ0FIRUk4QklRQU1CUXRCQUNBRU5nS3NqMEJCQUVFQUtBS2tqMEFnQTJvaUFEWUNwSTlBSUFRZ0FFRUJjallDQkNBQ0VKRUJJUUlNQnd0QkFDQUFJQU5ySWdJMkFxU1BRRUVBUVFBb0FxeVBRQ0lBSUFNUWp3RWlCRFlDckk5QUlBUWdBa0VCY2pZQ0JDQUFJQU1RZkNBQUVKRUJJUUlNQmd0QkFDQUdOZ0xNajBBTUF3c2dBQ0FBS0FJRUlBaHFOZ0lFUVFBb0FxU1BRQ0VDUVFBb0FxeVBRQ0VBSUFBZ0FCQ1JBU0lFUVFnUWF5QUVheUlFRUk4QklRQkJBQ0FDSUFocUlBUnJJZ0kyQXFTUFFFRUFJQUEyQXF5UFFDQUFJQUpCQVhJMkFnUkJBQkNSQVNJRVFRZ1FheUVIUVJSQkNCQnJJUVpCRUVFSUVHc2hDQ0FBSUFJUWp3RWdDQ0FHSUFjZ0JHdHFhallDQkVFQVFZQ0FnQUUyQXNpUFFBd0RDMEVBSUFRMkFxaVBRRUVBUVFBb0FxQ1BRQ0FEYWlJQU5nS2dqMEFnQkNBQUVHY2dBaENSQVNFQ0RBTUxJQVFnQXlBQUVHQUNRQ0FEUVlBQ1NRMEFJQVFnQXhBcklBSVFrUUVoQWd3REN5QURRUU4ySWdOQkEzUkJtSXpBQUdvaEFBSkFBa0JCQUNnQ2tJeEFJZ2RCQVNBRGRDSURjVVVOQUNBQUtBSUlJUU1NQVF0QkFDQUhJQU55TmdLUWpFQWdBQ0VEQ3lBQUlBUTJBZ2dnQXlBRU5nSU1JQVFnQURZQ0RDQUVJQU0yQWdnZ0FoQ1JBU0VDREFJTFFRQkIveDgyQXRDUFFFRUFJQWsyQXNTUFFFRUFJQWcyQXJ5UFFFRUFJQVkyQXJpUFFFRUFRWmlNd0FBMkFxU01RRUVBUWFDTXdBQTJBcXlNUUVFQVFaaU13QUEyQXFDTVFFRUFRYWlNd0FBMkFyU01RRUVBUWFDTXdBQTJBcWlNUUVFQVFiQ013QUEyQXJ5TVFFRUFRYWlNd0FBMkFyQ01RRUVBUWJpTXdBQTJBc1NNUUVFQVFiQ013QUEyQXJpTVFFRUFRY0NNd0FBMkFzeU1RRUVBUWJpTXdBQTJBc0NNUUVFQVFjaU13QUEyQXRTTVFFRUFRY0NNd0FBMkFzaU1RRUVBUWRDTXdBQTJBdHlNUUVFQVFjaU13QUEyQXRDTVFFRUFRZGlNd0FBMkF1U01RRUVBUWRDTXdBQTJBdGlNUUVFQVFkaU13QUEyQXVDTVFFRUFRZUNNd0FBMkF1eU1RRUVBUWVDTXdBQTJBdWlNUUVFQVFlaU13QUEyQXZTTVFFRUFRZWlNd0FBMkF2Q01RRUVBUWZDTXdBQTJBdnlNUUVFQVFmQ013QUEyQXZpTVFFRUFRZmlNd0FBMkFvU05RRUVBUWZpTXdBQTJBb0NOUUVFQVFZQ053QUEyQW95TlFFRUFRWUNOd0FBMkFvaU5RRUVBUVlpTndBQTJBcFNOUUVFQVFZaU53QUEyQXBDTlFFRUFRWkNOd0FBMkFweU5RRUVBUVpDTndBQTJBcGlOUUVFQVFaaU53QUEyQXFTTlFFRUFRYUNOd0FBMkFxeU5RRUVBUVppTndBQTJBcUNOUUVFQVFhaU53QUEyQXJTTlFFRUFRYUNOd0FBMkFxaU5RRUVBUWJDTndBQTJBcnlOUUVFQVFhaU53QUEyQXJDTlFFRUFRYmlOd0FBMkFzU05RRUVBUWJDTndBQTJBcmlOUUVFQVFjQ053QUEyQXN5TlFFRUFRYmlOd0FBMkFzQ05RRUVBUWNpTndBQTJBdFNOUUVFQVFjQ053QUEyQXNpTlFFRUFRZENOd0FBMkF0eU5RRUVBUWNpTndBQTJBdENOUUVFQVFkaU53QUEyQXVTTlFFRUFRZENOd0FBMkF0aU5RRUVBUWVDTndBQTJBdXlOUUVFQVFkaU53QUEyQXVDTlFFRUFRZWlOd0FBMkF2U05RRUVBUWVDTndBQTJBdWlOUUVFQVFmQ053QUEyQXZ5TlFFRUFRZWlOd0FBMkF2Q05RRUVBUWZpTndBQTJBb1NPUUVFQVFmQ053QUEyQXZpTlFFRUFRWUNPd0FBMkFveU9RRUVBUWZpTndBQTJBb0NPUUVFQVFZaU93QUEyQXBTT1FFRUFRWUNPd0FBMkFvaU9RRUVBUVpDT3dBQTJBcHlPUUVFQVFZaU93QUEyQXBDT1FFRUFRWkNPd0FBMkFwaU9RRUVBRUpFQklnSkJDQkJySVFSQkZFRUlFR3NoQjBFUVFRZ1FheUVGUVFBZ0JpQUdFSkVCSWdCQkNCQnJJQUJySWdrUWp3RWlBRFlDckk5QVFRQWdDQ0FDYWlBRklBUWdCMnBxSUFscWF5SUNOZ0trajBBZ0FDQUNRUUZ5TmdJRVFRQVFrUUVpQkVFSUVHc2hCMEVVUVFnUWF5RUdRUkJCQ0JCcklRZ2dBQ0FDRUk4QklBZ2dCaUFISUFScmFtbzJBZ1JCQUVHQWdJQUJOZ0xJajBBTFFRQWhBa0VBS0FLa2owQWlBQ0FEVFEwQVFRQWdBQ0FEYXlJQ05nS2tqMEJCQUVFQUtBS3NqMEFpQUNBREVJOEJJZ1EyQXF5UFFDQUVJQUpCQVhJMkFnUWdBQ0FERUh3Z0FCQ1JBU0VDQ3lBQlFSQnFKQUFnQWd2MEdRUVhmd0orQVgwRGZDTUFRYkFDYXlJRUpBQWdCRUlBTndKRUlBUkJBQ2dDaUlCQU5nSkFJQVJDQURjQ1ZDQUVRUUFvQW9DQVFDSUZOZ0pRQWtBQ1FBSkFBa0FnQTBFQVNBMEFJQU1OQVVFQklRWU1BZ3NRZndBTElBTkJBUkJ5SWdaRkRRRUxBa0FDUUFKQUlBTU5BQ0FBSUFRcEEwQTNBZ0FnQUVFSWFpQUVRY0FBYWtFSWFpZ0NBRFlDQUF3QkN5QUNJQU5CREd4cUlRY2dCRUdBQW1wQkVHb2hDQ0FCUVJocUlRa2dBVUVJYWlFS1FRQWhDd05BQWtBZ0JpQUxhaUlNTFFBQURRQWdERUVCT2dBQUlBUWdDellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0ViUVFBcEE0Q01RQ0VjUVlDTXdBQWhEQXdCQ3lBRVFUQnFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTTRJaHMzQTRpTVFFR0FqTUFBSVF3Z0JDa0RNQ0VjQ3lBTUlCeENBWHczQXdBUXBRRWhEQ0FFUWdBM0EzZ2dCQ0FNTmdKMElBUkJBRFlDY0NBRUlCczNBMmdnQkNBY053TmdJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQjRBQnFFQjhnQVNzREFDQUtLd01BSUFzZ0JFSGdBR29nQWlBREVCRWhIaUFCUVJCcUlRMUVBQUFBQUFBQThEOGhId0pBQWtBQ1FDQUpLd01BSWlBZ0htVU5BQ0FOS3dNQUloOGdIbVFOQVNBZUlCK2hJQ0FnSDZHakloOUVBQUFBQUFBQUFBQmhEUUVMSUFSQmtBRnFRUmhxSUFSQjRBQnFRUmhxS1FNQU53TUFJQVJCa0FGcVFSQnFJQVJCNEFCcVFSQnFLUU1BTndNQUlBUkJrQUZxUVFocUlBUkI0QUJxUVFocUtRTUFOd01BSUFRZ0JDa0RZRGNEa0FFQ1FFRVFRUWdRY1NJTVJRMEFJQXhCQURvQURDQU1JQXMyQWdnZ0RDQWZPUU1BSUFSQ2dZQ0FnQkEzQW9RQklBUWdERFlDZ0FFZ0JFSUFOd0swQVNBRUlBVTJBckFCQWtBZ0EwRUJFSElpRGtVTkFBSkFBa0FnQkNnQ3BBRWlEeWdDQUVHQWdZS0VlSEVpREVHQWdZS0VlRVlOQUNBTVFZQ0Jnb1I0Y3lFTURBRUxJQVFvQXFBQklBOXFRUUZxSVJBZ0QwRUVhaUVNQTBBZ0RDQVFUdzBGSUE5QmNHb2hEeUFNS0FJQUlSRWdERUVFYWlFTUlCRkJnSUdDaEhoeEloRkJnSUdDaEhoR0RRQUxJQkZCZ0lHQ2hIaHpJUXdMSUFRZ0R5QU1hRUVEZGtGL2MwRUNkR29vQWdBMkFvQUNJQVJCS0dvZ0JFR1FBV29nQkVHQUFtb1FIaUFFS0FJb1JRMERJQVFvQWl3aER3TkFBa0FnRHlBRFNRMEFJQThnQTBIRWdNQUFFRWNBQ3lBR0lBOXFRUUU2QUFBZ0RpQVBha0VCT2dBQUlBUWdEellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0ViUVFBcEE0Q01RQ0VjUVlDTXdBQWhEQXdCQ3lBRVFSaHFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTWdJaHMzQTRpTVFFR0FqTUFBSVF3Z0JDa0RHQ0VjQ3lBTUlCeENBWHczQXdBUXBRRWhEQ0FFUWdBM0E5Z0JJQVFnRERZQzFBRWdCRUVBTmdMUUFTQUVJQnMzQThnQklBUWdIRGNEd0FFZ0JDQUROZ0tVQWlBRUlBSTJBcEFDSUFSQkFEWUNpQUlnQkNBSE5nS0VBaUFFSUFJMkFvQUNJQVFnQVRZQ21BSWdCQ0FFUWVBQmFqWUNqQUlnQkVHQUFtb2dCRUhBQVdvUUh5QUJLd01BSUFvckF3QWdEeUFFUWNBQmFpQUNJQU1RRVNFZVJBQUFBQUFBQVBBL0lSOENRQUpBSUFrckF3QWlJQ0FlWlEwQUFrQWdEU3NEQUNJZklCNWtEUUFnSGlBZm9TQWdJQitob3lJZlJBQUFBQUFBQUFBQVpBMEJDd0pBSUFRb0FyUUJJQVFvQXJnQklneEhEUUFnQkVHd0FXb2dERUVCRURJZ0JDZ0N1QUVoREFzZ0JDZ0NzQUVnREVFRWRHb2lERUVCT2dBTUlBd2dEellDQ0NBTVF2Ly8vLy8vLy8vMy93QTNBd0FnQkNBRUtBSzRBVUVCYWpZQ3VBRWdCQ2dDMEFFaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBTFVBU0FQYXlBTVFRUVFlUXdCQ3lBRVFZQUNha0VZYWlJTUlBUkJ3QUZxUVJocUtRTUFOd01BSUFnZ0JFSEFBV3BCRUdvcEF3QTNBd0FnQkVHQUFtcEJDR29pRVNBRVFjQUJha0VJYWlrREFEY0RBQ0FFSUFRcEE4QUJOd09BQWlBRVFhQUNha0VJYWlBSVFRaHFLUUlBTndNQUlBUWdDQ2tDQURjRG9BSWdCRUhnQVdvZ0JFR2dBbW9RUkNBTUlBUkI0QUZxUVJocUtRTUFOd01BSUFnZ0JFSGdBV3BCRUdvcEF3QTNBd0FnRVNBRVFlQUJha0VJYWlrREFEY0RBQ0FFSUFRcEErQUJOd09BQWlBRVFSQnFJQVJCZ0FKcUVEa0NRQ0FFS0FJUVJRMEFJQVFvQWhRaERBTkFBa0FDUUNBTUlBTlBEUUFnRGlBTWFpMEFBQTBCSUFSQmtBRnFJQXdRRXhvTUFRc2dEQ0FEUWRTQXdBQVFSd0FMSUFSQkNHb2dCRUdBQW1vUU9TQUVLQUlNSVF3Z0JDZ0NDQTBBQ3dzQ1FDQUVLQUtVQWlJTVJRMEFJQVFvQXBnQ0loRkZEUUFnRENBUklBUW9BcHdDRUhrTEFrQWdCQ2dDaEFFZ0JDZ0NpQUVpREVjTkFDQUVRWUFCYWlBTVFRRVFNaUFFS0FLSUFTRU1DeUFFS0FLQUFTQU1RUVIwYWlJTVFRQTZBQXdnRENBUE5nSUlJQXdnSHprREFDQUVJQVFvQW9nQlFRRnFOZ0tJQVFzQ1FBSkFJQVFvQXFRQklnOG9BZ0JCZ0lHQ2hIaHhJZ3hCZ0lHQ2hIaEdEUUFnREVHQWdZS0VlSE1oREF3QkN5QUVLQUtnQVNBUGFrRUJhaUVRSUE5QkJHb2hEQU5BSUF3Z0VFOE5CaUFQUVhCcUlROGdEQ2dDQUNFUklBeEJCR29oRENBUlFZQ0Jnb1I0Y1NJUlFZQ0Jnb1I0UmcwQUN5QVJRWUNCZ29SNGN5RU1DeUFFSUE4Z0RHaEJBM1pCZjNOQkFuUnFLQUlBTmdLQUFpQUVJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NCQ0VQSUFRb0FnQU5BQXdFQ3dzZ0EwRUJFSXNCQUF0QkVFRUlFSXNCQUFzQ1FDQUVLQUpVSUFRb0FsZ2lERWNOQUNBRVFkQUFhaUFNUVFFUU1pQUVLQUpZSVF3TElBUW9BbEFnREVFRWRHb2lERUVDT2dBTUlBd2dDellDQ0NBTVFvQ0FnSUNBZ0lENFB6Y0RBQ0FFSUFRb0FsaEJBV28yQWxnZ0JDZ0NjQ0lNUlEwQklBd2dERUVDZEVFRWFpSVBha0VGYWlJTVJRMEJJQVFvQW5RZ0Qyc2dERUVFRUhrTUFRc2dCQ2dDc0FFaEVnSkFJQVFvQXJnQklneEJCSFFpRDBVTkFDQVNJQTlxSVJNRFFBSkFJQVFvQW9nQlFRUjBJZzlGRFFBQ1FDQVNLQUlJSWhFZ0EwOE5BQ0FFS0FLQUFTSU1JQTlxSVJRZ0FpQVJRUXhzYWlJVlFRUnFJUllnRlVFSWFpRVhBMEFDUUFKQUFrQUNRQ0FNSWcwb0FnZ2lFU0FEVHcwQUFrQWdGeWdDQUNJTURRQkVBQUFBQUFBQUFBQWhIZ3dFQ3dKQUFrQWdGaWdDQUNJUElBSWdFVUVNYkdvaUdDZ0NCQ0lSSUE4Z0VTQVBTUnNpR1NBTVFYOXFJaEFnR1NBUVNSc2lHVVlOQUNBUklCbEdEUUVnR0NnQ0FDRVlJQlVvQWdBaEdTQU1RUUZ4SVJvZ0VBMERRUUFoRVVRQUFBQUFBQUFBQUNFZURBUUxJQThnRDBHd2djQUFFRWNBQ3lBUklCRkJ3SUhBQUJCSEFBc2dFU0FEUWJTQXdBQVFSd0FMSUF4QmZuRWhFRUVBSVJGRUFBQUFBQUFBQUFBaEhpQVlJUXdnR1NFUEEwQWdIaUFQS2dJQUlBd3FBZ0NUSWgwZ0haUzdvQ0FQUVFScUtnSUFJQXhCQkdvcUFnQ1RJaDBnSFpTN29DRWVJQXhCQ0dvaERDQVBRUWhxSVE4Z0VDQVJRUUpxSWhGSERRQUxDeUFhUlEwQUlCNGdHU0FSUVFKMElneHFLZ0lBSUJnZ0RHb3FBZ0NUSWgwZ0haUzdvQ0VlQ3lBTlFSQnFJUXhFQUFBQUFBQUE4RDhoSHdKQUFrQWdIcDhpSGlBQkt3TUFJaUJsRFFBZ0hpQUtLd01BSWg5a0RRRWdIeUFlb1NBZklDQ2hveUlmUkFBQUFBQUFBQUFBWkVVTkFRc2dFaXNEQUNFZUlCSWdEU3NEQUNBZkVHUWdIaEJrT1FNQUN5QU1JQlJHRFFJTUFBc0xJQkVnQTBHa2dNQUFFRWNBQ3lBU1FSQnFJaElnRTBjTkFBc2dCQ2dDdUFFaERDQUVLQUt3QVNFU0N3SkFJQVFvQW9RQklBUW9Bb2dCSWc5cklBeFBEUUFnQkVHQUFXb2dEeUFNRURJZ0JDZ0NpQUVoRHdzZ0JDZ0NnQUVnRDBFRWRHb2dFaUFNUVFSMEVEb2FJQVJCQURZQ3VBRWdCQ0FFS0FLSUFTQU1hallDaUFFZ0RpQURRUUVRZVFKQUlBUW9BclFCSWd4RkRRQWdERUVFZENJTVJRMEFJQVFvQXJBQklBeEJDQkI1Q3dKQUlBUW9BcUFCSWd4RkRRQWdEQ0FNUVFKMFFRUnFJZzlxUVFWcUlneEZEUUFnQkNnQ3BBRWdEMnNnREVFRUVIa0xBa0FnQkNnQ1JDQUVLQUpJSWd4SERRQWdCRUhBQUdvZ0RFRUJFREVnQkNnQ1NDRU1DeUFFS0FKQUlBeEJER3hxSWd3Z0JDa0RnQUUzQWdBZ0RFRUlhaUFFUVlBQmFrRUlhaWdDQURZQ0FDQUVJQVFvQWtoQkFXbzJBa2dMSUF0QkFXb2lDeUFEUncwQUN3SkFJQVFvQWxoRkRRQWdCRUdBQW1wQkNHb2lEeUFFUWRBQWFrRUlhaWdDQURZQ0FDQUVJQVFwQTFBM0E0QUNBa0FnQkNnQ1JDQUVLQUpJSWd4SERRQWdCRUhBQUdvZ0RFRUJFREVnQkNnQ1NDRU1DeUFFS0FKQUlBeEJER3hxSWd3Z0JDa0RnQUkzQWdBZ0RFRUlhaUFQS0FJQU5nSUFJQVJCd0FCcVFRaHFJZ3dnRENnQ0FFRUJhaUlNTmdJQUlBQkJDR29nRERZQ0FDQUFJQVFwQTBBM0FnQWdBMFVOQWlBR0lBTkJBUkI1REFJTElBQWdCQ2tEUURjQ0FDQUFRUWhxSUFSQndBQnFRUWhxS0FJQU5nSUFJQU5GRFFBZ0JpQURRUUVRZVFzZ0JDZ0NWQ0lNUlEwQUlBeEJCSFFpREVVTkFDQUVLQUpRSUF4QkNCQjVDeUFFUWJBQ2FpUUFEd3NnQTBFQkVJc0JBQXYzR0FRVGZ3SitBWDBEZkNNQVFiQUNheUlFSkFBZ0JFSUFOd0pFSUFSQkFDZ0NpSUJBTmdKQUlBUkNBRGNDVkNBRVFRQW9Bb0NBUUNJRk5nSlFBa0FDUUFKQUFrQWdBMEVBU0EwQUlBTU5BVUVCSVFZTUFnc1Fmd0FMSUFOQkFSQnlJZ1pGRFFFTEFrQUNRQUpBSUFNTkFDQUFJQVFwQTBBM0FnQWdBRUVJYWlBRVFjQUFha0VJYWlnQ0FEWUNBQXdCQ3lBQ0lBTkJBM1JxSVFjZ0JFR0FBbXBCRUdvaENDQUJRUmhxSVFrZ0FVRUlhaUVLUVFBaEN3TkFBa0FnQmlBTGFpSU1MUUFBRFFBZ0RFRUJPZ0FBSUFRZ0N6WUM0QUVDUUFKQVFRQXBBL2lMUUVJQlVnMEFRUUFwQTRpTVFDRVhRUUFwQTRDTVFDRVlRWUNNd0FBaERBd0JDeUFFUVRCcUVIUkJBRUlCTndQNGkwQkJBQ0FFS1FNNEloYzNBNGlNUUVHQWpNQUFJUXdnQkNrRE1DRVlDeUFNSUJoQ0FYdzNBd0FRcFFFaERDQUVRZ0EzQTNnZ0JDQU1OZ0owSUFSQkFEWUNjQ0FFSUJjM0EyZ2dCQ0FZTndOZ0lBUWdBellDbEFJZ0JDQUNOZ0tRQWlBRVFRQTJBb2dDSUFRZ0J6WUNoQUlnQkNBQ05nS0FBaUFFSUFFMkFwZ0NJQVFnQkVIZ0FXbzJBb3dDSUFSQmdBSnFJQVJCNEFCcUVDZ2dBU3NEQUNBS0t3TUFJQXNnQkVIZ0FHb2dBaUFERUJjaEdpQUJRUkJxSVExRUFBQUFBQUFBOEQ4aEd3SkFBa0FDUUNBSkt3TUFJaHdnR21VTkFDQU5Ld01BSWhzZ0dtUU5BU0FhSUJ1aElCd2dHNkdqSWh0RUFBQUFBQUFBQUFCaERRRUxJQVJCa0FGcVFSaHFJQVJCNEFCcVFSaHFLUU1BTndNQUlBUkJrQUZxUVJCcUlBUkI0QUJxUVJCcUtRTUFOd01BSUFSQmtBRnFRUWhxSUFSQjRBQnFRUWhxS1FNQU53TUFJQVFnQkNrRFlEY0RrQUVDUUVFUVFRZ1FjU0lNUlEwQUlBeEJBRG9BRENBTUlBczJBZ2dnRENBYk9RTUFJQVJDZ1lDQWdCQTNBb1FCSUFRZ0REWUNnQUVnQkVJQU53SzBBU0FFSUFVMkFyQUJBa0FnQTBFQkVISWlEa1VOQUFKQUFrQWdCQ2dDcEFFaUR5Z0NBRUdBZ1lLRWVIRWlERUdBZ1lLRWVFWU5BQ0FNUVlDQmdvUjRjeUVNREFFTElBUW9BcUFCSUE5cVFRRnFJUkFnRDBFRWFpRU1BMEFnRENBUVR3MEZJQTlCY0dvaER5QU1LQUlBSVJFZ0RFRUVhaUVNSUJGQmdJR0NoSGh4SWhGQmdJR0NoSGhHRFFBTElCRkJnSUdDaEhoeklRd0xJQVFnRHlBTWFFRURka0YvYzBFQ2RHb29BZ0EyQW9BQ0lBUkJLR29nQkVHUUFXb2dCRUdBQW1vUUhpQUVLQUlvUlEwRElBUW9BaXdoRHdOQUFrQWdEeUFEU1EwQUlBOGdBMEhFZ01BQUVFY0FDeUFHSUE5cVFRRTZBQUFnRGlBUGFrRUJPZ0FBSUFRZ0R6WUM0QUVDUUFKQVFRQXBBL2lMUUVJQlVnMEFRUUFwQTRpTVFDRVhRUUFwQTRDTVFDRVlRWUNNd0FBaERBd0JDeUFFUVJocUVIUkJBRUlCTndQNGkwQkJBQ0FFS1FNZ0loYzNBNGlNUUVHQWpNQUFJUXdnQkNrREdDRVlDeUFNSUJoQ0FYdzNBd0FRcFFFaERDQUVRZ0EzQTlnQklBUWdERFlDMUFFZ0JFRUFOZ0xRQVNBRUlCYzNBOGdCSUFRZ0dEY0R3QUVnQkNBRE5nS1VBaUFFSUFJMkFwQUNJQVJCQURZQ2lBSWdCQ0FITmdLRUFpQUVJQUkyQW9BQ0lBUWdBVFlDbUFJZ0JDQUVRZUFCYWpZQ2pBSWdCRUdBQW1vZ0JFSEFBV29RS0NBQkt3TUFJQW9yQXdBZ0R5QUVRY0FCYWlBQ0lBTVFGeUVhUkFBQUFBQUFBUEEvSVJzQ1FBSkFJQWtyQXdBaUhDQWFaUTBBQWtBZ0RTc0RBQ0liSUJwa0RRQWdHaUFib1NBY0lCdWhveUliUkFBQUFBQUFBQUFBWkEwQkN3SkFJQVFvQXJRQklBUW9BcmdCSWd4SERRQWdCRUd3QVdvZ0RFRUJFRElnQkNnQ3VBRWhEQXNnQkNnQ3NBRWdERUVFZEdvaURFRUJPZ0FNSUF3Z0R6WUNDQ0FNUXYvLy8vLy8vLy8zL3dBM0F3QWdCQ0FFS0FLNEFVRUJhallDdUFFZ0JDZ0MwQUVpREVVTkFTQU1JQXhCQW5SQkJHb2lEMnBCQldvaURFVU5BU0FFS0FMVUFTQVBheUFNUVFRUWVRd0JDeUFFUVlBQ2FrRVlhaUlNSUFSQndBRnFRUmhxS1FNQU53TUFJQWdnQkVIQUFXcEJFR29wQXdBM0F3QWdCRUdBQW1wQkNHb2lFU0FFUWNBQmFrRUlhaWtEQURjREFDQUVJQVFwQThBQk53T0FBaUFFUWFBQ2FrRUlhaUFJUVFocUtRSUFOd01BSUFRZ0NDa0NBRGNEb0FJZ0JFSGdBV29nQkVHZ0Ftb1FSQ0FNSUFSQjRBRnFRUmhxS1FNQU53TUFJQWdnQkVIZ0FXcEJFR29wQXdBM0F3QWdFU0FFUWVBQmFrRUlhaWtEQURjREFDQUVJQVFwQStBQk53T0FBaUFFUVJCcUlBUkJnQUpxRURrQ1FDQUVLQUlRUlEwQUlBUW9BaFFoREFOQUFrQUNRQ0FNSUFOUERRQWdEaUFNYWkwQUFBMEJJQVJCa0FGcUlBd1FFeG9NQVFzZ0RDQURRZFNBd0FBUVJ3QUxJQVJCQ0dvZ0JFR0FBbW9RT1NBRUtBSU1JUXdnQkNnQ0NBMEFDd3NDUUNBRUtBS1VBaUlNUlEwQUlBUW9BcGdDSWhGRkRRQWdEQ0FSSUFRb0Fwd0NFSGtMQWtBZ0JDZ0NoQUVnQkNnQ2lBRWlERWNOQUNBRVFZQUJhaUFNUVFFUU1pQUVLQUtJQVNFTUN5QUVLQUtBQVNBTVFRUjBhaUlNUVFBNkFBd2dEQ0FQTmdJSUlBd2dHemtEQUNBRUlBUW9Bb2dCUVFGcU5nS0lBUXNDUUFKQUlBUW9BcVFCSWc4b0FnQkJnSUdDaEhoeElneEJnSUdDaEhoR0RRQWdERUdBZ1lLRWVITWhEQXdCQ3lBRUtBS2dBU0FQYWtFQmFpRVFJQTlCQkdvaERBTkFJQXdnRUU4TkJpQVBRWEJxSVE4Z0RDZ0NBQ0VSSUF4QkJHb2hEQ0FSUVlDQmdvUjRjU0lSUVlDQmdvUjRSZzBBQ3lBUlFZQ0Jnb1I0Y3lFTUN5QUVJQThnREdoQkEzWkJmM05CQW5ScUtBSUFOZ0tBQWlBRUlBUkJrQUZxSUFSQmdBSnFFQjRnQkNnQ0JDRVBJQVFvQWdBTkFBd0VDd3NnQTBFQkVJc0JBQXRCRUVFSUVJc0JBQXNDUUNBRUtBSlVJQVFvQWxnaURFY05BQ0FFUWRBQWFpQU1RUUVRTWlBRUtBSllJUXdMSUFRb0FsQWdERUVFZEdvaURFRUNPZ0FNSUF3Z0N6WUNDQ0FNUW9DQWdJQ0FnSUQ0UHpjREFDQUVJQVFvQWxoQkFXbzJBbGdnQkNnQ2NDSU1SUTBCSUF3Z0RFRUNkRUVFYWlJUGFrRUZhaUlNUlEwQklBUW9BblFnRDJzZ0RFRUVFSGtNQVFzZ0JDZ0NzQUVoRWdKQUlBUW9BcmdCSWd4QkJIUWlEMFVOQUNBU0lBOXFJUk1EUUFKQUlBUW9Bb2dCUVFSMEloQkZEUUFDUUFKQUFrQUNRQ0FTS0FJSUlnd2dBMDhOQUNBRUtBS0FBU0VSSUFJZ0RFRURkR29pRkVFRWFpRVZBMEFnRVVFSWFpZ0NBQ0lQSUFOUERRUWdGU2dDQUNJTUlBSWdEMEVEZEdvaUZpZ0NCQ0lQSUF3Z0R5QU1TUnNpRFVFRUlBMUJCRWtiSWcxR0RRSWdEeUFOUmcwRFJBQUFBQUFBQVBBL0lSb0NRQUpBSUJRb0FnQWlEQ29DQUNBV0tBSUFJZzhxQWdDVEloa2dHWlM3UkFBQUFBQUFBQUFBb0NBTUtnSUVJQThxQWdTVEloa2dHWlM3b0NBTUtnSUlJQThxQWdpVEloa2dHWlM3b0NBTUtnSU1JQThxQWd5VEloa2dHWlM3b0NBTUtnSVFJQThxQWhDVEloa2dHWlM3b0o4aUd5QUJLd01BSWh4bERRQWdHeUFLS3dNQUlocGtEUUVnR2lBYm9TQWFJQnlob3lJYVJBQUFBQUFBQUFBQVpFVU5BUXNnRWlzREFDRWJJQklnRVNzREFDQWFFR1FnR3hCa09RTUFDeUFSUVJCcUlSRWdFRUZ3YWlJUVJRMEZEQUFMQ3lBTUlBTkJwSURBQUJCSEFBc2dEQ0FNUVpDQndBQVFSd0FMSUE4Z0QwR2dnY0FBRUVjQUN5QVBJQU5CdElEQUFCQkhBQXNnRWtFUWFpSVNJQk5IRFFBTElBUW9BcmdCSVF3Z0JDZ0NzQUVoRWdzQ1FDQUVLQUtFQVNBRUtBS0lBU0lQYXlBTVR3MEFJQVJCZ0FGcUlBOGdEQkF5SUFRb0FvZ0JJUThMSUFRb0FvQUJJQTlCQkhScUlCSWdERUVFZEJBNkdpQUVRUUEyQXJnQklBUWdCQ2dDaUFFZ0RHbzJBb2dCSUE0Z0EwRUJFSGtDUUNBRUtBSzBBU0lNUlEwQUlBeEJCSFFpREVVTkFDQUVLQUt3QVNBTVFRZ1FlUXNDUUNBRUtBS2dBU0lNUlEwQUlBd2dERUVDZEVFRWFpSVBha0VGYWlJTVJRMEFJQVFvQXFRQklBOXJJQXhCQkJCNUN3SkFJQVFvQWtRZ0JDZ0NTQ0lNUncwQUlBUkJ3QUJxSUF4QkFSQXhJQVFvQWtnaERBc2dCQ2dDUUNBTVFReHNhaUlNSUFRcEE0QUJOd0lBSUF4QkNHb2dCRUdBQVdwQkNHb29BZ0EyQWdBZ0JDQUVLQUpJUVFGcU5nSklDeUFMUVFGcUlnc2dBMGNOQUFzQ1FDQUVLQUpZUlEwQUlBUkJnQUpxUVFocUlnOGdCRUhRQUdwQkNHb29BZ0EyQWdBZ0JDQUVLUU5RTndPQUFnSkFJQVFvQWtRZ0JDZ0NTQ0lNUncwQUlBUkJ3QUJxSUF4QkFSQXhJQVFvQWtnaERBc2dCQ2dDUUNBTVFReHNhaUlNSUFRcEE0QUNOd0lBSUF4QkNHb2dEeWdDQURZQ0FDQUVRY0FBYWtFSWFpSU1JQXdvQWdCQkFXb2lERFlDQUNBQVFRaHFJQXcyQWdBZ0FDQUVLUU5BTndJQUlBTkZEUUlnQmlBRFFRRVFlUXdDQ3lBQUlBUXBBMEEzQWdBZ0FFRUlhaUFFUWNBQWFrRUlhaWdDQURZQ0FDQURSUTBBSUFZZ0EwRUJFSGtMSUFRb0FsUWlERVVOQUNBTVFRUjBJZ3hGRFFBZ0JDZ0NVQ0FNUVFnUWVRc2dCRUd3QW1va0FBOExJQU5CQVJDTEFRQUw1UmdFRTM4Q2ZnRjlBM3dqQUVHd0Ftc2lCQ1FBSUFSQ0FEY0NSQ0FFUVFBb0FvaUFRRFlDUUNBRVFnQTNBbFFnQkVFQUtBS0FnRUFpQlRZQ1VBSkFBa0FDUUFKQUlBTkJBRWdOQUNBRERRRkJBU0VHREFJTEVIOEFDeUFEUVFFUWNpSUdSUTBCQ3dKQUFrQUNRQ0FERFFBZ0FDQUVLUU5BTndJQUlBQkJDR29nQkVIQUFHcEJDR29vQWdBMkFnQU1BUXNnQWlBRFFRTjBhaUVISUFSQmdBSnFRUkJxSVFnZ0FVRVlhaUVKSUFGQkNHb2hDa0VBSVFzRFFBSkFJQVlnQzJvaURDMEFBQTBBSUF4QkFUb0FBQ0FFSUFzMkF1QUJBa0FDUUVFQUtRUDRpMEJDQVZJTkFFRUFLUU9JakVBaEYwRUFLUU9BakVBaEdFR0FqTUFBSVF3TUFRc2dCRUV3YWhCMFFRQkNBVGNEK0l0QVFRQWdCQ2tET0NJWE53T0lqRUJCZ0l6QUFDRU1JQVFwQXpBaEdBc2dEQ0FZUWdGOE53TUFFS1VCSVF3Z0JFSUFOd040SUFRZ0REWUNkQ0FFUVFBMkFuQWdCQ0FYTndOb0lBUWdHRGNEWUNBRUlBTTJBcFFDSUFRZ0FqWUNrQUlnQkVFQU5nS0lBaUFFSUFjMkFvUUNJQVFnQWpZQ2dBSWdCQ0FCTmdLWUFpQUVJQVJCNEFGcU5nS01BaUFFUVlBQ2FpQUVRZUFBYWhBcUlBRXJBd0FnQ2lzREFDQUxJQVJCNEFCcUlBSWdBeEFZSVJvZ0FVRVFhaUVOUkFBQUFBQUFBUEEvSVJzQ1FBSkFBa0FnQ1NzREFDSWNJQnBsRFFBZ0RTc0RBQ0liSUJwa0RRRWdHaUFib1NBY0lCdWhveUliUkFBQUFBQUFBQUFBWVEwQkN5QUVRWkFCYWtFWWFpQUVRZUFBYWtFWWFpa0RBRGNEQUNBRVFaQUJha0VRYWlBRVFlQUFha0VRYWlrREFEY0RBQ0FFUVpBQmFrRUlhaUFFUWVBQWFrRUlhaWtEQURjREFDQUVJQVFwQTJBM0E1QUJBa0JCRUVFSUVIRWlERVVOQUNBTVFRQTZBQXdnRENBTE5nSUlJQXdnR3prREFDQUVRb0dBZ0lBUU53S0VBU0FFSUF3MkFvQUJJQVJDQURjQ3RBRWdCQ0FGTmdLd0FRSkFJQU5CQVJCeUlnNUZEUUFDUUFKQUlBUW9BcVFCSWc4b0FnQkJnSUdDaEhoeElneEJnSUdDaEhoR0RRQWdERUdBZ1lLRWVITWhEQXdCQ3lBRUtBS2dBU0FQYWtFQmFpRVFJQTlCQkdvaERBTkFJQXdnRUU4TkJTQVBRWEJxSVE4Z0RDZ0NBQ0VSSUF4QkJHb2hEQ0FSUVlDQmdvUjRjU0lSUVlDQmdvUjRSZzBBQ3lBUlFZQ0Jnb1I0Y3lFTUN5QUVJQThnREdoQkEzWkJmM05CQW5ScUtBSUFOZ0tBQWlBRVFTaHFJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NLRVVOQXlBRUtBSXNJUThEUUFKQUlBOGdBMGtOQUNBUElBTkJ4SURBQUJCSEFBc2dCaUFQYWtFQk9nQUFJQTRnRDJwQkFUb0FBQ0FFSUE4MkF1QUJBa0FDUUVFQUtRUDRpMEJDQVZJTkFFRUFLUU9JakVBaEYwRUFLUU9BakVBaEdFR0FqTUFBSVF3TUFRc2dCRUVZYWhCMFFRQkNBVGNEK0l0QVFRQWdCQ2tESUNJWE53T0lqRUJCZ0l6QUFDRU1JQVFwQXhnaEdBc2dEQ0FZUWdGOE53TUFFS1VCSVF3Z0JFSUFOd1BZQVNBRUlBdzJBdFFCSUFSQkFEWUMwQUVnQkNBWE53UElBU0FFSUJnM0E4QUJJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQndBRnFFQ29nQVNzREFDQUtLd01BSUE4Z0JFSEFBV29nQWlBREVCZ2hHa1FBQUFBQUFBRHdQeUViQWtBQ1FDQUpLd01BSWh3Z0dtVU5BQUpBSUEwckF3QWlHeUFhWkEwQUlCb2dHNkVnSENBYm9hTWlHMFFBQUFBQUFBQUFBR1FOQVFzQ1FDQUVLQUswQVNBRUtBSzRBU0lNUncwQUlBUkJzQUZxSUF4QkFSQXlJQVFvQXJnQklRd0xJQVFvQXJBQklBeEJCSFJxSWd4QkFUb0FEQ0FNSUE4MkFnZ2dERUwvLy8vLy8vLy85LzhBTndNQUlBUWdCQ2dDdUFGQkFXbzJBcmdCSUFRb0F0QUJJZ3hGRFFFZ0RDQU1RUUowUVFScUlnOXFRUVZxSWd4RkRRRWdCQ2dDMUFFZ0Qyc2dERUVFRUhrTUFRc2dCRUdBQW1wQkdHb2lEQ0FFUWNBQmFrRVlhaWtEQURjREFDQUlJQVJCd0FGcVFSQnFLUU1BTndNQUlBUkJnQUpxUVFocUloRWdCRUhBQVdwQkNHb3BBd0EzQXdBZ0JDQUVLUVBBQVRjRGdBSWdCRUdnQW1wQkNHb2dDRUVJYWlrQ0FEY0RBQ0FFSUFncEFnQTNBNkFDSUFSQjRBRnFJQVJCb0FKcUVFUWdEQ0FFUWVBQmFrRVlhaWtEQURjREFDQUlJQVJCNEFGcVFSQnFLUU1BTndNQUlCRWdCRUhnQVdwQkNHb3BBd0EzQXdBZ0JDQUVLUVBnQVRjRGdBSWdCRUVRYWlBRVFZQUNhaEE1QWtBZ0JDZ0NFRVVOQUNBRUtBSVVJUXdEUUFKQUFrQWdEQ0FEVHcwQUlBNGdER290QUFBTkFTQUVRWkFCYWlBTUVCTWFEQUVMSUF3Z0EwSFVnTUFBRUVjQUN5QUVRUWhxSUFSQmdBSnFFRGtnQkNnQ0RDRU1JQVFvQWdnTkFBc0xBa0FnQkNnQ2xBSWlERVVOQUNBRUtBS1lBaUlSUlEwQUlBd2dFU0FFS0FLY0FoQjVDd0pBSUFRb0FvUUJJQVFvQW9nQklneEhEUUFnQkVHQUFXb2dERUVCRURJZ0JDZ0NpQUVoREFzZ0JDZ0NnQUVnREVFRWRHb2lERUVBT2dBTUlBd2dEellDQ0NBTUlCczVBd0FnQkNBRUtBS0lBVUVCYWpZQ2lBRUxBa0FDUUNBRUtBS2tBU0lQS0FJQVFZQ0Jnb1I0Y1NJTVFZQ0Jnb1I0UmcwQUlBeEJnSUdDaEhoeklRd01BUXNnQkNnQ29BRWdEMnBCQVdvaEVDQVBRUVJxSVF3RFFDQU1JQkJQRFFZZ0QwRndhaUVQSUF3b0FnQWhFU0FNUVFScUlRd2dFVUdBZ1lLRWVIRWlFVUdBZ1lLRWVFWU5BQXNnRVVHQWdZS0VlSE1oREFzZ0JDQVBJQXhvUVFOMlFYOXpRUUowYWlnQ0FEWUNnQUlnQkNBRVFaQUJhaUFFUVlBQ2FoQWVJQVFvQWdRaER5QUVLQUlBRFFBTUJBc0xJQU5CQVJDTEFRQUxRUkJCQ0JDTEFRQUxBa0FnQkNnQ1ZDQUVLQUpZSWd4SERRQWdCRUhRQUdvZ0RFRUJFRElnQkNnQ1dDRU1DeUFFS0FKUUlBeEJCSFJxSWd4QkFqb0FEQ0FNSUFzMkFnZ2dERUtBZ0lDQWdJQ0ErRDgzQXdBZ0JDQUVLQUpZUVFGcU5nSllJQVFvQW5BaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBSjBJQTlySUF4QkJCQjVEQUVMSUFRb0FyQUJJUklDUUNBRUtBSzRBU0lNUVFSMElnOUZEUUFnRWlBUGFpRVRBMEFDUUNBRUtBS0lBVUVFZENJUVJRMEFBa0FDUUFKQUFrQWdFaWdDQ0NJTUlBTlBEUUFnQkNnQ2dBRWhFU0FDSUF4QkEzUnFJaFJCQkdvaEZRTkFJQkZCQ0dvb0FnQWlEeUFEVHcwRUlCVW9BZ0FpRENBQ0lBOUJBM1JxSWhZb0FnUWlEeUFNSUE4Z0RFa2JJZzFCQXlBTlFRTkpHeUlOUmcwQ0lBOGdEVVlOQTBRQUFBQUFBQUR3UHlFYUFrQUNRQ0FVS0FJQUlnd3FBZ0FnRmlnQ0FDSVBLZ0lBa3lJWklCbVV1MFFBQUFBQUFBQUFBS0FnRENvQ0JDQVBLZ0lFa3lJWklCbVV1NkFnRENvQ0NDQVBLZ0lJa3lJWklCbVV1NkFnRENvQ0RDQVBLZ0lNa3lJWklCbVV1NkNmSWhzZ0FTc0RBQ0ljWlEwQUlCc2dDaXNEQUNJYVpBMEJJQm9nRzZFZ0dpQWNvYU1pR2tRQUFBQUFBQUFBQUdSRkRRRUxJQklyQXdBaEd5QVNJQkVyQXdBZ0doQmtJQnNRWkRrREFBc2dFVUVRYWlFUklCQkJjR29pRUVVTkJRd0FDd3NnRENBRFFhU0F3QUFRUndBTElBd2dERUdRZ2NBQUVFY0FDeUFQSUE5Qm9JSEFBQkJIQUFzZ0R5QURRYlNBd0FBUVJ3QUxJQkpCRUdvaUVpQVRSdzBBQ3lBRUtBSzRBU0VNSUFRb0FyQUJJUklMQWtBZ0JDZ0NoQUVnQkNnQ2lBRWlEMnNnREU4TkFDQUVRWUFCYWlBUElBd1FNaUFFS0FLSUFTRVBDeUFFS0FLQUFTQVBRUVIwYWlBU0lBeEJCSFFRT2hvZ0JFRUFOZ0s0QVNBRUlBUW9Bb2dCSUF4cU5nS0lBU0FPSUFOQkFSQjVBa0FnQkNnQ3RBRWlERVVOQUNBTVFRUjBJZ3hGRFFBZ0JDZ0NzQUVnREVFSUVIa0xBa0FnQkNnQ29BRWlERVVOQUNBTUlBeEJBblJCQkdvaUQycEJCV29pREVVTkFDQUVLQUtrQVNBUGF5QU1RUVFRZVFzQ1FDQUVLQUpFSUFRb0FrZ2lERWNOQUNBRVFjQUFhaUFNUVFFUU1TQUVLQUpJSVF3TElBUW9Ba0FnREVFTWJHb2lEQ0FFS1FPQUFUY0NBQ0FNUVFocUlBUkJnQUZxUVFocUtBSUFOZ0lBSUFRZ0JDZ0NTRUVCYWpZQ1NBc2dDMEVCYWlJTElBTkhEUUFMQWtBZ0JDZ0NXRVVOQUNBRVFZQUNha0VJYWlJUElBUkIwQUJxUVFocUtBSUFOZ0lBSUFRZ0JDa0RVRGNEZ0FJQ1FDQUVLQUpFSUFRb0FrZ2lERWNOQUNBRVFjQUFhaUFNUVFFUU1TQUVLQUpJSVF3TElBUW9Ba0FnREVFTWJHb2lEQ0FFS1FPQUFqY0NBQ0FNUVFocUlBOG9BZ0EyQWdBZ0JFSEFBR3BCQ0dvaURDQU1LQUlBUVFGcUlndzJBZ0FnQUVFSWFpQU1OZ0lBSUFBZ0JDa0RRRGNDQUNBRFJRMENJQVlnQTBFQkVIa01BZ3NnQUNBRUtRTkFOd0lBSUFCQkNHb2dCRUhBQUdwQkNHb29BZ0EyQWdBZ0EwVU5BQ0FHSUFOQkFSQjVDeUFFS0FKVUlneEZEUUFnREVFRWRDSU1SUTBBSUFRb0FsQWdERUVJRUhrTElBUkJzQUpxSkFBUEN5QURRUUVRaXdFQUM5TVlCQk4vQW40QmZRTjhJd0JCc0FKcklnUWtBQ0FFUWdBM0FrUWdCRUVBS0FLSWdFQTJBa0FnQkVJQU53SlVJQVJCQUNnQ2dJQkFJZ1UyQWxBQ1FBSkFBa0FDUUNBRFFRQklEUUFnQXcwQlFRRWhCZ3dDQ3hCL0FBc2dBMEVCRUhJaUJrVU5BUXNDUUFKQUFrQWdBdzBBSUFBZ0JDa0RRRGNDQUNBQVFRaHFJQVJCd0FCcVFRaHFLQUlBTmdJQURBRUxJQUlnQTBFRGRHb2hCeUFFUVlBQ2FrRVFhaUVJSUFGQkdHb2hDU0FCUVFocUlRcEJBQ0VMQTBBQ1FDQUdJQXRxSWd3dEFBQU5BQ0FNUVFFNkFBQWdCQ0FMTmdMZ0FRSkFBa0JCQUNrRCtJdEFRZ0ZTRFFCQkFDa0RpSXhBSVJkQkFDa0RnSXhBSVJoQmdJekFBQ0VNREFFTElBUkJNR29RZEVFQVFnRTNBL2lMUUVFQUlBUXBBemdpRnpjRGlJeEFRWUNNd0FBaERDQUVLUU13SVJnTElBd2dHRUlCZkRjREFCQ2xBU0VNSUFSQ0FEY0RlQ0FFSUF3MkFuUWdCRUVBTmdKd0lBUWdGemNEYUNBRUlCZzNBMkFnQkNBRE5nS1VBaUFFSUFJMkFwQUNJQVJCQURZQ2lBSWdCQ0FITmdLRUFpQUVJQUkyQW9BQ0lBUWdBVFlDbUFJZ0JDQUVRZUFCYWpZQ2pBSWdCRUdBQW1vZ0JFSGdBR29RTFNBQkt3TUFJQW9yQXdBZ0N5QUVRZUFBYWlBQ0lBTVFHU0VhSUFGQkVHb2hEVVFBQUFBQUFBRHdQeUViQWtBQ1FBSkFJQWtyQXdBaUhDQWFaUTBBSUEwckF3QWlHeUFhWkEwQklCb2dHNkVnSENBYm9hTWlHMFFBQUFBQUFBQUFBR0VOQVFzZ0JFR1FBV3BCR0dvZ0JFSGdBR3BCR0dvcEF3QTNBd0FnQkVHUUFXcEJFR29nQkVIZ0FHcEJFR29wQXdBM0F3QWdCRUdRQVdwQkNHb2dCRUhnQUdwQkNHb3BBd0EzQXdBZ0JDQUVLUU5nTndPUUFRSkFRUkJCQ0JCeElneEZEUUFnREVFQU9nQU1JQXdnQ3pZQ0NDQU1JQnM1QXdBZ0JFS0JnSUNBRURjQ2hBRWdCQ0FNTmdLQUFTQUVRZ0EzQXJRQklBUWdCVFlDc0FFQ1FDQURRUUVRY2lJT1JRMEFBa0FDUUNBRUtBS2tBU0lQS0FJQVFZQ0Jnb1I0Y1NJTVFZQ0Jnb1I0UmcwQUlBeEJnSUdDaEhoeklRd01BUXNnQkNnQ29BRWdEMnBCQVdvaEVDQVBRUVJxSVF3RFFDQU1JQkJQRFFVZ0QwRndhaUVQSUF3b0FnQWhFU0FNUVFScUlRd2dFVUdBZ1lLRWVIRWlFVUdBZ1lLRWVFWU5BQXNnRVVHQWdZS0VlSE1oREFzZ0JDQVBJQXhvUVFOMlFYOXpRUUowYWlnQ0FEWUNnQUlnQkVFb2FpQUVRWkFCYWlBRVFZQUNhaEFlSUFRb0FpaEZEUU1nQkNnQ0xDRVBBMEFDUUNBUElBTkpEUUFnRHlBRFFjU0F3QUFRUndBTElBWWdEMnBCQVRvQUFDQU9JQTlxUVFFNkFBQWdCQ0FQTmdMZ0FRSkFBa0JCQUNrRCtJdEFRZ0ZTRFFCQkFDa0RpSXhBSVJkQkFDa0RnSXhBSVJoQmdJekFBQ0VNREFFTElBUkJHR29RZEVFQVFnRTNBL2lMUUVFQUlBUXBBeUFpRnpjRGlJeEFRWUNNd0FBaERDQUVLUU1ZSVJnTElBd2dHRUlCZkRjREFCQ2xBU0VNSUFSQ0FEY0QyQUVnQkNBTU5nTFVBU0FFUVFBMkF0QUJJQVFnRnpjRHlBRWdCQ0FZTndQQUFTQUVJQU0yQXBRQ0lBUWdBallDa0FJZ0JFRUFOZ0tJQWlBRUlBYzJBb1FDSUFRZ0FqWUNnQUlnQkNBQk5nS1lBaUFFSUFSQjRBRnFOZ0tNQWlBRVFZQUNhaUFFUWNBQmFoQXRJQUVyQXdBZ0Npc0RBQ0FQSUFSQndBRnFJQUlnQXhBWklScEVBQUFBQUFBQThEOGhHd0pBQWtBZ0NTc0RBQ0ljSUJwbERRQUNRQ0FOS3dNQUloc2dHbVFOQUNBYUlCdWhJQndnRzZHaklodEVBQUFBQUFBQUFBQmtEUUVMQWtBZ0JDZ0N0QUVnQkNnQ3VBRWlERWNOQUNBRVFiQUJhaUFNUVFFUU1pQUVLQUs0QVNFTUN5QUVLQUt3QVNBTVFRUjBhaUlNUVFFNkFBd2dEQ0FQTmdJSUlBeEMvLy8vLy8vLy8vZi9BRGNEQUNBRUlBUW9BcmdCUVFGcU5nSzRBU0FFS0FMUUFTSU1SUTBCSUF3Z0RFRUNkRUVFYWlJUGFrRUZhaUlNUlEwQklBUW9BdFFCSUE5cklBeEJCQkI1REFFTElBUkJnQUpxUVJocUlnd2dCRUhBQVdwQkdHb3BBd0EzQXdBZ0NDQUVRY0FCYWtFUWFpa0RBRGNEQUNBRVFZQUNha0VJYWlJUklBUkJ3QUZxUVFocUtRTUFOd01BSUFRZ0JDa0R3QUUzQTRBQ0lBUkJvQUpxUVFocUlBaEJDR29wQWdBM0F3QWdCQ0FJS1FJQU53T2dBaUFFUWVBQmFpQUVRYUFDYWhCRUlBd2dCRUhnQVdwQkdHb3BBd0EzQXdBZ0NDQUVRZUFCYWtFUWFpa0RBRGNEQUNBUklBUkI0QUZxUVFocUtRTUFOd01BSUFRZ0JDa0Q0QUUzQTRBQ0lBUkJFR29nQkVHQUFtb1FPUUpBSUFRb0FoQkZEUUFnQkNnQ0ZDRU1BMEFDUUFKQUlBd2dBMDhOQUNBT0lBeHFMUUFBRFFFZ0JFR1FBV29nREJBVEdnd0JDeUFNSUFOQjFJREFBQkJIQUFzZ0JFRUlhaUFFUVlBQ2FoQTVJQVFvQWd3aERDQUVLQUlJRFFBTEN3SkFJQVFvQXBRQ0lneEZEUUFnQkNnQ21BSWlFVVVOQUNBTUlCRWdCQ2dDbkFJUWVRc0NRQ0FFS0FLRUFTQUVLQUtJQVNJTVJ3MEFJQVJCZ0FGcUlBeEJBUkF5SUFRb0FvZ0JJUXdMSUFRb0FvQUJJQXhCQkhScUlneEJBRG9BRENBTUlBODJBZ2dnRENBYk9RTUFJQVFnQkNnQ2lBRkJBV28yQW9nQkN3SkFBa0FnQkNnQ3BBRWlEeWdDQUVHQWdZS0VlSEVpREVHQWdZS0VlRVlOQUNBTVFZQ0Jnb1I0Y3lFTURBRUxJQVFvQXFBQklBOXFRUUZxSVJBZ0QwRUVhaUVNQTBBZ0RDQVFUdzBHSUE5QmNHb2hEeUFNS0FJQUlSRWdERUVFYWlFTUlCRkJnSUdDaEhoeEloRkJnSUdDaEhoR0RRQUxJQkZCZ0lHQ2hIaHpJUXdMSUFRZ0R5QU1hRUVEZGtGL2MwRUNkR29vQWdBMkFvQUNJQVFnQkVHUUFXb2dCRUdBQW1vUUhpQUVLQUlFSVE4Z0JDZ0NBQTBBREFRTEN5QURRUUVRaXdFQUMwRVFRUWdRaXdFQUN3SkFJQVFvQWxRZ0JDZ0NXQ0lNUncwQUlBUkIwQUJxSUF4QkFSQXlJQVFvQWxnaERBc2dCQ2dDVUNBTVFRUjBhaUlNUVFJNkFBd2dEQ0FMTmdJSUlBeENnSUNBZ0lDQWdQZy9Od01BSUFRZ0JDZ0NXRUVCYWpZQ1dDQUVLQUp3SWd4RkRRRWdEQ0FNUVFKMFFRUnFJZzlxUVFWcUlneEZEUUVnQkNnQ2RDQVBheUFNUVFRUWVRd0JDeUFFS0FLd0FTRVNBa0FnQkNnQ3VBRWlERUVFZENJUFJRMEFJQklnRDJvaEV3TkFBa0FnQkNnQ2lBRkJCSFFpRUVVTkFBSkFBa0FDUUFKQUlCSW9BZ2dpRHlBRFR3MEFJQVFvQW9BQklRd2dBaUFQUVFOMGFpSVVRUVJxSVJVRFFDQU1RUWhxS0FJQUloRWdBMDhOQkNBVktBSUFJZzhnQWlBUlFRTjBhaUlXS0FJRUloRWdEeUFSSUE5Skd5SU5RUUlnRFVFQ1NSc2lEVVlOQWlBUklBMUdEUU5FQUFBQUFBQUE4RDhoR2dKQUFrQWdGQ2dDQUNJUEtnSUFJQllvQWdBaUVTb0NBSk1pR1NBWmxMdEVBQUFBQUFBQUFBQ2dJQThxQWdRZ0VTb0NCSk1pR1NBWmxMdWdJQThxQWdnZ0VTb0NDSk1pR1NBWmxMdWdueUliSUFFckF3QWlIR1VOQUNBYklBb3JBd0FpR21RTkFTQWFJQnVoSUJvZ0hLR2pJaHBFQUFBQUFBQUFBQUJrUlEwQkN5QVNLd01BSVJzZ0VpQU1Ld01BSUJvUVpDQWJFR1E1QXdBTElBeEJFR29oRENBUVFYQnFJaEJGRFFVTUFBc0xJQThnQTBHa2dNQUFFRWNBQ3lBUElBOUJrSUhBQUJCSEFBc2dFU0FSUWFDQndBQVFSd0FMSUJFZ0EwRzBnTUFBRUVjQUN5QVNRUkJxSWhJZ0UwY05BQXNnQkNnQ3VBRWhEQ0FFS0FLd0FTRVNDd0pBSUFRb0FvUUJJQVFvQW9nQklnOXJJQXhQRFFBZ0JFR0FBV29nRHlBTUVESWdCQ2dDaUFFaER3c2dCQ2dDZ0FFZ0QwRUVkR29nRWlBTVFRUjBFRG9hSUFSQkFEWUN1QUVnQkNBRUtBS0lBU0FNYWpZQ2lBRWdEaUFEUVFFUWVRSkFJQVFvQXJRQklneEZEUUFnREVFRWRDSU1SUTBBSUFRb0FyQUJJQXhCQ0JCNUN3SkFJQVFvQXFBQklneEZEUUFnRENBTVFRSjBRUVJxSWc5cVFRVnFJZ3hGRFFBZ0JDZ0NwQUVnRDJzZ0RFRUVFSGtMQWtBZ0JDZ0NSQ0FFS0FKSUlneEhEUUFnQkVIQUFHb2dERUVCRURFZ0JDZ0NTQ0VNQ3lBRUtBSkFJQXhCREd4cUlnd2dCQ2tEZ0FFM0FnQWdERUVJYWlBRVFZQUJha0VJYWlnQ0FEWUNBQ0FFSUFRb0FraEJBV28yQWtnTElBdEJBV29pQ3lBRFJ3MEFDd0pBSUFRb0FsaEZEUUFnQkVHQUFtcEJDR29pRHlBRVFkQUFha0VJYWlnQ0FEWUNBQ0FFSUFRcEExQTNBNEFDQWtBZ0JDZ0NSQ0FFS0FKSUlneEhEUUFnQkVIQUFHb2dERUVCRURFZ0JDZ0NTQ0VNQ3lBRUtBSkFJQXhCREd4cUlnd2dCQ2tEZ0FJM0FnQWdERUVJYWlBUEtBSUFOZ0lBSUFSQndBQnFRUWhxSWd3Z0RDZ0NBRUVCYWlJTU5nSUFJQUJCQ0dvZ0REWUNBQ0FBSUFRcEEwQTNBZ0FnQTBVTkFpQUdJQU5CQVJCNURBSUxJQUFnQkNrRFFEY0NBQ0FBUVFocUlBUkJ3QUJxUVFocUtBSUFOZ0lBSUFORkRRQWdCaUFEUVFFUWVRc2dCQ2dDVkNJTVJRMEFJQXhCQkhRaURFVU5BQ0FFS0FKUUlBeEJDQkI1Q3lBRVFiQUNhaVFBRHdzZ0EwRUJFSXNCQUF1NkdBUVRmd0orQVgwRGZDTUFRYkFDYXlJRUpBQWdCRUlBTndKRUlBUkJBQ2dDaUlCQU5nSkFJQVJDQURjQ1ZDQUVRUUFvQW9DQVFDSUZOZ0pRQWtBQ1FBSkFBa0FnQTBFQVNBMEFJQU1OQVVFQklRWU1BZ3NRZndBTElBTkJBUkJ5SWdaRkRRRUxBa0FDUUFKQUlBTU5BQ0FBSUFRcEEwQTNBZ0FnQUVFSWFpQUVRY0FBYWtFSWFpZ0NBRFlDQUF3QkN5QUNJQU5CQTNScUlRY2dCRUdBQW1wQkVHb2hDQ0FCUVJocUlRa2dBVUVJYWlFS1FRQWhDd05BQWtBZ0JpQUxhaUlNTFFBQURRQWdERUVCT2dBQUlBUWdDellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VYUVFBcEE0Q01RQ0VZUVlDTXdBQWhEQXdCQ3lBRVFUQnFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTTRJaGMzQTRpTVFFR0FqTUFBSVF3Z0JDa0RNQ0VZQ3lBTUlCaENBWHczQXdBUXBRRWhEQ0FFUWdBM0EzZ2dCQ0FNTmdKMElBUkJBRFlDY0NBRUlCYzNBMmdnQkNBWU53TmdJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQjRBQnFFREFnQVNzREFDQUtLd01BSUFzZ0JFSGdBR29nQWlBREVCd2hHaUFCUVJCcUlRMUVBQUFBQUFBQThEOGhHd0pBQWtBQ1FDQUpLd01BSWh3Z0dtVU5BQ0FOS3dNQUloc2dHbVFOQVNBYUlCdWhJQndnRzZHaklodEVBQUFBQUFBQUFBQmhEUUVMSUFSQmtBRnFRUmhxSUFSQjRBQnFRUmhxS1FNQU53TUFJQVJCa0FGcVFSQnFJQVJCNEFCcVFSQnFLUU1BTndNQUlBUkJrQUZxUVFocUlBUkI0QUJxUVFocUtRTUFOd01BSUFRZ0JDa0RZRGNEa0FFQ1FFRVFRUWdRY1NJTVJRMEFJQXhCQURvQURDQU1JQXMyQWdnZ0RDQWJPUU1BSUFSQ2dZQ0FnQkEzQW9RQklBUWdERFlDZ0FFZ0JFSUFOd0swQVNBRUlBVTJBckFCQWtBZ0EwRUJFSElpRGtVTkFBSkFBa0FnQkNnQ3BBRWlEeWdDQUVHQWdZS0VlSEVpREVHQWdZS0VlRVlOQUNBTVFZQ0Jnb1I0Y3lFTURBRUxJQVFvQXFBQklBOXFRUUZxSVJBZ0QwRUVhaUVNQTBBZ0RDQVFUdzBGSUE5QmNHb2hEeUFNS0FJQUlSRWdERUVFYWlFTUlCRkJnSUdDaEhoeEloRkJnSUdDaEhoR0RRQUxJQkZCZ0lHQ2hIaHpJUXdMSUFRZ0R5QU1hRUVEZGtGL2MwRUNkR29vQWdBMkFvQUNJQVJCS0dvZ0JFR1FBV29nQkVHQUFtb1FIaUFFS0FJb1JRMERJQVFvQWl3aER3TkFBa0FnRHlBRFNRMEFJQThnQTBIRWdNQUFFRWNBQ3lBR0lBOXFRUUU2QUFBZ0RpQVBha0VCT2dBQUlBUWdEellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VYUVFBcEE0Q01RQ0VZUVlDTXdBQWhEQXdCQ3lBRVFSaHFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTWdJaGMzQTRpTVFFR0FqTUFBSVF3Z0JDa0RHQ0VZQ3lBTUlCaENBWHczQXdBUXBRRWhEQ0FFUWdBM0E5Z0JJQVFnRERZQzFBRWdCRUVBTmdMUUFTQUVJQmMzQThnQklBUWdHRGNEd0FFZ0JDQUROZ0tVQWlBRUlBSTJBcEFDSUFSQkFEWUNpQUlnQkNBSE5nS0VBaUFFSUFJMkFvQUNJQVFnQVRZQ21BSWdCQ0FFUWVBQmFqWUNqQUlnQkVHQUFtb2dCRUhBQVdvUU1DQUJLd01BSUFvckF3QWdEeUFFUWNBQmFpQUNJQU1RSENFYVJBQUFBQUFBQVBBL0lSc0NRQUpBSUFrckF3QWlIQ0FhWlEwQUFrQWdEU3NEQUNJYklCcGtEUUFnR2lBYm9TQWNJQnVob3lJYlJBQUFBQUFBQUFBQVpBMEJDd0pBSUFRb0FyUUJJQVFvQXJnQklneEhEUUFnQkVHd0FXb2dERUVCRURJZ0JDZ0N1QUVoREFzZ0JDZ0NzQUVnREVFRWRHb2lERUVCT2dBTUlBd2dEellDQ0NBTVF2Ly8vLy8vLy8vMy93QTNBd0FnQkNBRUtBSzRBVUVCYWpZQ3VBRWdCQ2dDMEFFaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBTFVBU0FQYXlBTVFRUVFlUXdCQ3lBRVFZQUNha0VZYWlJTUlBUkJ3QUZxUVJocUtRTUFOd01BSUFnZ0JFSEFBV3BCRUdvcEF3QTNBd0FnQkVHQUFtcEJDR29pRVNBRVFjQUJha0VJYWlrREFEY0RBQ0FFSUFRcEE4QUJOd09BQWlBRVFhQUNha0VJYWlBSVFRaHFLUUlBTndNQUlBUWdDQ2tDQURjRG9BSWdCRUhnQVdvZ0JFR2dBbW9RUkNBTUlBUkI0QUZxUVJocUtRTUFOd01BSUFnZ0JFSGdBV3BCRUdvcEF3QTNBd0FnRVNBRVFlQUJha0VJYWlrREFEY0RBQ0FFSUFRcEErQUJOd09BQWlBRVFSQnFJQVJCZ0FKcUVEa0NRQ0FFS0FJUVJRMEFJQVFvQWhRaERBTkFBa0FDUUNBTUlBTlBEUUFnRGlBTWFpMEFBQTBCSUFSQmtBRnFJQXdRRXhvTUFRc2dEQ0FEUWRTQXdBQVFSd0FMSUFSQkNHb2dCRUdBQW1vUU9TQUVLQUlNSVF3Z0JDZ0NDQTBBQ3dzQ1FDQUVLQUtVQWlJTVJRMEFJQVFvQXBnQ0loRkZEUUFnRENBUklBUW9BcHdDRUhrTEFrQWdCQ2dDaEFFZ0JDZ0NpQUVpREVjTkFDQUVRWUFCYWlBTVFRRVFNaUFFS0FLSUFTRU1DeUFFS0FLQUFTQU1RUVIwYWlJTVFRQTZBQXdnRENBUE5nSUlJQXdnR3prREFDQUVJQVFvQW9nQlFRRnFOZ0tJQVFzQ1FBSkFJQVFvQXFRQklnOG9BZ0JCZ0lHQ2hIaHhJZ3hCZ0lHQ2hIaEdEUUFnREVHQWdZS0VlSE1oREF3QkN5QUVLQUtnQVNBUGFrRUJhaUVRSUE5QkJHb2hEQU5BSUF3Z0VFOE5CaUFQUVhCcUlROGdEQ2dDQUNFUklBeEJCR29oRENBUlFZQ0Jnb1I0Y1NJUlFZQ0Jnb1I0UmcwQUN5QVJRWUNCZ29SNGN5RU1DeUFFSUE4Z0RHaEJBM1pCZjNOQkFuUnFLQUlBTmdLQUFpQUVJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NCQ0VQSUFRb0FnQU5BQXdFQ3dzZ0EwRUJFSXNCQUF0QkVFRUlFSXNCQUFzQ1FDQUVLQUpVSUFRb0FsZ2lERWNOQUNBRVFkQUFhaUFNUVFFUU1pQUVLQUpZSVF3TElBUW9BbEFnREVFRWRHb2lERUVDT2dBTUlBd2dDellDQ0NBTVFvQ0FnSUNBZ0lENFB6Y0RBQ0FFSUFRb0FsaEJBV28yQWxnZ0JDZ0NjQ0lNUlEwQklBd2dERUVDZEVFRWFpSVBha0VGYWlJTVJRMEJJQVFvQW5RZ0Qyc2dERUVFRUhrTUFRc2dCQ2dDc0FFaEVnSkFJQVFvQXJnQklneEJCSFFpRDBVTkFDQVNJQTlxSVJNRFFBSkFJQVFvQW9nQlFRUjBJaEJGRFFBQ1FBSkFBa0FDUUNBU0tBSUlJZzhnQTA4TkFDQUVLQUtBQVNFTUlBSWdEMEVEZEdvaUZFRUVhaUVWQTBBZ0RFRUlhaWdDQUNJUklBTlBEUVFnRlNnQ0FDSVBJQUlnRVVFRGRHb2lGaWdDQkNJUklBOGdFU0FQU1J0QkFFY2lEVVlOQWlBUklBMUdEUU5FQUFBQUFBQUE4RDhoR2dKQUFrQWdGQ2dDQUNJUEtnSUFJQllvQWdBaUVTb0NBSk1pR1NBWmxMdEVBQUFBQUFBQUFBQ2dJQThxQWdRZ0VTb0NCSk1pR1NBWmxMdWdueUliSUFFckF3QWlIR1VOQUNBYklBb3JBd0FpR21RTkFTQWFJQnVoSUJvZ0hLR2pJaHBFQUFBQUFBQUFBQUJrUlEwQkN5QVNLd01BSVJzZ0VpQU1Ld01BSUJvUVpDQWJFR1E1QXdBTElBeEJFR29oRENBUVFYQnFJaEJGRFFVTUFBc0xJQThnQTBHa2dNQUFFRWNBQ3lBUElBOUJrSUhBQUJCSEFBc2dFU0FSUWFDQndBQVFSd0FMSUJFZ0EwRzBnTUFBRUVjQUN5QVNRUkJxSWhJZ0UwY05BQXNnQkNnQ3VBRWhEQ0FFS0FLd0FTRVNDd0pBSUFRb0FvUUJJQVFvQW9nQklnOXJJQXhQRFFBZ0JFR0FBV29nRHlBTUVESWdCQ2dDaUFFaER3c2dCQ2dDZ0FFZ0QwRUVkR29nRWlBTVFRUjBFRG9hSUFSQkFEWUN1QUVnQkNBRUtBS0lBU0FNYWpZQ2lBRWdEaUFEUVFFUWVRSkFJQVFvQXJRQklneEZEUUFnREVFRWRDSU1SUTBBSUFRb0FyQUJJQXhCQ0JCNUN3SkFJQVFvQXFBQklneEZEUUFnRENBTVFRSjBRUVJxSWc5cVFRVnFJZ3hGRFFBZ0JDZ0NwQUVnRDJzZ0RFRUVFSGtMQWtBZ0JDZ0NSQ0FFS0FKSUlneEhEUUFnQkVIQUFHb2dERUVCRURFZ0JDZ0NTQ0VNQ3lBRUtBSkFJQXhCREd4cUlnd2dCQ2tEZ0FFM0FnQWdERUVJYWlBRVFZQUJha0VJYWlnQ0FEWUNBQ0FFSUFRb0FraEJBV28yQWtnTElBdEJBV29pQ3lBRFJ3MEFDd0pBSUFRb0FsaEZEUUFnQkVHQUFtcEJDR29pRHlBRVFkQUFha0VJYWlnQ0FEWUNBQ0FFSUFRcEExQTNBNEFDQWtBZ0JDZ0NSQ0FFS0FKSUlneEhEUUFnQkVIQUFHb2dERUVCRURFZ0JDZ0NTQ0VNQ3lBRUtBSkFJQXhCREd4cUlnd2dCQ2tEZ0FJM0FnQWdERUVJYWlBUEtBSUFOZ0lBSUFSQndBQnFRUWhxSWd3Z0RDZ0NBRUVCYWlJTU5nSUFJQUJCQ0dvZ0REWUNBQ0FBSUFRcEEwQTNBZ0FnQTBVTkFpQUdJQU5CQVJCNURBSUxJQUFnQkNrRFFEY0NBQ0FBUVFocUlBUkJ3QUJxUVFocUtBSUFOZ0lBSUFORkRRQWdCaUFEUVFFUWVRc2dCQ2dDVkNJTVJRMEFJQXhCQkhRaURFVU5BQ0FFS0FKUUlBeEJDQkI1Q3lBRVFiQUNhaVFBRHdzZ0EwRUJFSXNCQUF1UEdBUVFmd0orQVgwRGZDTUFRYkFDYXlJRUpBQWdCRUlBTndKRUlBUkJBQ2dDaUlCQU5nSkFJQVJDQURjQ1ZDQUVRUUFvQW9DQVFDSUZOZ0pRQWtBQ1FBSkFBa0FnQTBFQVNBMEFJQU1OQVVFQklRWU1BZ3NRZndBTElBTkJBUkJ5SWdaRkRRRUxBa0FDUUFKQUlBTU5BQ0FBSUFRcEEwQTNBZ0FnQUVFSWFpQUVRY0FBYWtFSWFpZ0NBRFlDQUF3QkN5QUNJQU5CQTNScUlRY2dCRUdBQW1wQkVHb2hDQ0FCUVJocUlRa2dBVUVJYWlFS1FRQWhDd05BQWtBZ0JpQUxhaUlNTFFBQURRQWdERUVCT2dBQUlBUWdDellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VVUVFBcEE0Q01RQ0VWUVlDTXdBQWhEQXdCQ3lBRVFUQnFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTTRJaFEzQTRpTVFFR0FqTUFBSVF3Z0JDa0RNQ0VWQ3lBTUlCVkNBWHczQXdBUXBRRWhEQ0FFUWdBM0EzZ2dCQ0FNTmdKMElBUkJBRFlDY0NBRUlCUTNBMmdnQkNBVk53TmdJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQjRBQnFFRFlnQVNzREFDQUtLd01BSUFzZ0JFSGdBR29nQWlBREVCMGhGeUFCUVJCcUlRMUVBQUFBQUFBQThEOGhHQUpBQWtBQ1FDQUpLd01BSWhrZ0YyVU5BQ0FOS3dNQUloZ2dGMlFOQVNBWElCaWhJQmtnR0tHakloaEVBQUFBQUFBQUFBQmhEUUVMSUFSQmtBRnFRUmhxSUFSQjRBQnFRUmhxS1FNQU53TUFJQVJCa0FGcVFSQnFJQVJCNEFCcVFSQnFLUU1BTndNQUlBUkJrQUZxUVFocUlBUkI0QUJxUVFocUtRTUFOd01BSUFRZ0JDa0RZRGNEa0FFQ1FFRVFRUWdRY1NJTVJRMEFJQXhCQURvQURDQU1JQXMyQWdnZ0RDQVlPUU1BSUFSQ2dZQ0FnQkEzQW9RQklBUWdERFlDZ0FFZ0JFSUFOd0swQVNBRUlBVTJBckFCQWtBZ0EwRUJFSElpRGtVTkFBSkFBa0FnQkNnQ3BBRWlEeWdDQUVHQWdZS0VlSEVpREVHQWdZS0VlRVlOQUNBTVFZQ0Jnb1I0Y3lFTURBRUxJQVFvQXFBQklBOXFRUUZxSVJBZ0QwRUVhaUVNQTBBZ0RDQVFUdzBGSUE5QmNHb2hEeUFNS0FJQUlSRWdERUVFYWlFTUlCRkJnSUdDaEhoeEloRkJnSUdDaEhoR0RRQUxJQkZCZ0lHQ2hIaHpJUXdMSUFRZ0R5QU1hRUVEZGtGL2MwRUNkR29vQWdBMkFvQUNJQVJCS0dvZ0JFR1FBV29nQkVHQUFtb1FIaUFFS0FJb1JRMERJQVFvQWl3aER3TkFBa0FnRHlBRFNRMEFJQThnQTBIRWdNQUFFRWNBQ3lBR0lBOXFRUUU2QUFBZ0RpQVBha0VCT2dBQUlBUWdEellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VVUVFBcEE0Q01RQ0VWUVlDTXdBQWhEQXdCQ3lBRVFSaHFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTWdJaFEzQTRpTVFFR0FqTUFBSVF3Z0JDa0RHQ0VWQ3lBTUlCVkNBWHczQXdBUXBRRWhEQ0FFUWdBM0E5Z0JJQVFnRERZQzFBRWdCRUVBTmdMUUFTQUVJQlEzQThnQklBUWdGVGNEd0FFZ0JDQUROZ0tVQWlBRUlBSTJBcEFDSUFSQkFEWUNpQUlnQkNBSE5nS0VBaUFFSUFJMkFvQUNJQVFnQVRZQ21BSWdCQ0FFUWVBQmFqWUNqQUlnQkVHQUFtb2dCRUhBQVdvUU5pQUJLd01BSUFvckF3QWdEeUFFUWNBQmFpQUNJQU1RSFNFWFJBQUFBQUFBQVBBL0lSZ0NRQUpBSUFrckF3QWlHU0FYWlEwQUFrQWdEU3NEQUNJWUlCZGtEUUFnRnlBWW9TQVpJQmlob3lJWVJBQUFBQUFBQUFBQVpBMEJDd0pBSUFRb0FyUUJJQVFvQXJnQklneEhEUUFnQkVHd0FXb2dERUVCRURJZ0JDZ0N1QUVoREFzZ0JDZ0NzQUVnREVFRWRHb2lERUVCT2dBTUlBd2dEellDQ0NBTVF2Ly8vLy8vLy8vMy93QTNBd0FnQkNBRUtBSzRBVUVCYWpZQ3VBRWdCQ2dDMEFFaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBTFVBU0FQYXlBTVFRUVFlUXdCQ3lBRVFZQUNha0VZYWlJTUlBUkJ3QUZxUVJocUtRTUFOd01BSUFnZ0JFSEFBV3BCRUdvcEF3QTNBd0FnQkVHQUFtcEJDR29pRVNBRVFjQUJha0VJYWlrREFEY0RBQ0FFSUFRcEE4QUJOd09BQWlBRVFhQUNha0VJYWlBSVFRaHFLUUlBTndNQUlBUWdDQ2tDQURjRG9BSWdCRUhnQVdvZ0JFR2dBbW9RUkNBTUlBUkI0QUZxUVJocUtRTUFOd01BSUFnZ0JFSGdBV3BCRUdvcEF3QTNBd0FnRVNBRVFlQUJha0VJYWlrREFEY0RBQ0FFSUFRcEErQUJOd09BQWlBRVFSQnFJQVJCZ0FKcUVEa0NRQ0FFS0FJUVJRMEFJQVFvQWhRaERBTkFBa0FDUUNBTUlBTlBEUUFnRGlBTWFpMEFBQTBCSUFSQmtBRnFJQXdRRXhvTUFRc2dEQ0FEUWRTQXdBQVFSd0FMSUFSQkNHb2dCRUdBQW1vUU9TQUVLQUlNSVF3Z0JDZ0NDQTBBQ3dzQ1FDQUVLQUtVQWlJTVJRMEFJQVFvQXBnQ0loRkZEUUFnRENBUklBUW9BcHdDRUhrTEFrQWdCQ2dDaEFFZ0JDZ0NpQUVpREVjTkFDQUVRWUFCYWlBTVFRRVFNaUFFS0FLSUFTRU1DeUFFS0FLQUFTQU1RUVIwYWlJTVFRQTZBQXdnRENBUE5nSUlJQXdnR0RrREFDQUVJQVFvQW9nQlFRRnFOZ0tJQVFzQ1FBSkFJQVFvQXFRQklnOG9BZ0JCZ0lHQ2hIaHhJZ3hCZ0lHQ2hIaEdEUUFnREVHQWdZS0VlSE1oREF3QkN5QUVLQUtnQVNBUGFrRUJhaUVRSUE5QkJHb2hEQU5BSUF3Z0VFOE5CaUFQUVhCcUlROGdEQ2dDQUNFUklBeEJCR29oRENBUlFZQ0Jnb1I0Y1NJUlFZQ0Jnb1I0UmcwQUN5QVJRWUNCZ29SNGN5RU1DeUFFSUE4Z0RHaEJBM1pCZjNOQkFuUnFLQUlBTmdLQUFpQUVJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NCQ0VQSUFRb0FnQU5BQXdFQ3dzZ0EwRUJFSXNCQUF0QkVFRUlFSXNCQUFzQ1FDQUVLQUpVSUFRb0FsZ2lERWNOQUNBRVFkQUFhaUFNUVFFUU1pQUVLQUpZSVF3TElBUW9BbEFnREVFRWRHb2lERUVDT2dBTUlBd2dDellDQ0NBTVFvQ0FnSUNBZ0lENFB6Y0RBQ0FFSUFRb0FsaEJBV28yQWxnZ0JDZ0NjQ0lNUlEwQklBd2dERUVDZEVFRWFpSVBha0VGYWlJTVJRMEJJQVFvQW5RZ0Qyc2dERUVFRUhrTUFRc2dCQ2dDc0FFaEVBSkFJQVFvQXJnQklneEJCSFFpRDBVTkFDQVFJQTlxSVJJRFFBSkFJQVFvQW9nQlFRUjBJZzlGRFFBQ1FBSkFBa0FDUUNBUUtBSUlJaEVnQTA4TkFDQUVLQUtBQVNFTUlBSWdFVUVEZEdvaUUwRUVhaUVOQTBBZ0RFRUlhaWdDQUNJUklBTlBEUVFnRFNnQ0FFVU5BaUFDSUJGQkEzUnFJaEVvQWdSRkRRTkVBQUFBQUFBQThEOGhGd0pBQWtBZ0V5Z0NBQ29DQUNBUktBSUFLZ0lBa3lJV0lCYVV1MFFBQUFBQUFBQUFBS0NmSWhnZ0FTc0RBQ0laWlEwQUlCZ2dDaXNEQUNJWFpBMEJJQmNnR0tFZ0Z5QVpvYU1pRjBRQUFBQUFBQUFBQUdSRkRRRUxJQkFyQXdBaEdDQVFJQXdyQXdBZ0Z4QmtJQmdRWkRrREFBc2dERUVRYWlFTUlBOUJjR29pRDBVTkJRd0FDd3NnRVNBRFFhU0F3QUFRUndBTFFRQkJBRUdRZ2NBQUVFY0FDMEVBUVFCQm9JSEFBQkJIQUFzZ0VTQURRYlNBd0FBUVJ3QUxJQkJCRUdvaUVDQVNSdzBBQ3lBRUtBSzRBU0VNSUFRb0FyQUJJUkFMQWtBZ0JDZ0NoQUVnQkNnQ2lBRWlEMnNnREU4TkFDQUVRWUFCYWlBUElBd1FNaUFFS0FLSUFTRVBDeUFFS0FLQUFTQVBRUVIwYWlBUUlBeEJCSFFRT2hvZ0JFRUFOZ0s0QVNBRUlBUW9Bb2dCSUF4cU5nS0lBU0FPSUFOQkFSQjVBa0FnQkNnQ3RBRWlERVVOQUNBTVFRUjBJZ3hGRFFBZ0JDZ0NzQUVnREVFSUVIa0xBa0FnQkNnQ29BRWlERVVOQUNBTUlBeEJBblJCQkdvaUQycEJCV29pREVVTkFDQUVLQUtrQVNBUGF5QU1RUVFRZVFzQ1FDQUVLQUpFSUFRb0FrZ2lERWNOQUNBRVFjQUFhaUFNUVFFUU1TQUVLQUpJSVF3TElBUW9Ba0FnREVFTWJHb2lEQ0FFS1FPQUFUY0NBQ0FNUVFocUlBUkJnQUZxUVFocUtBSUFOZ0lBSUFRZ0JDZ0NTRUVCYWpZQ1NBc2dDMEVCYWlJTElBTkhEUUFMQWtBZ0JDZ0NXRVVOQUNBRVFZQUNha0VJYWlJUElBUkIwQUJxUVFocUtBSUFOZ0lBSUFRZ0JDa0RVRGNEZ0FJQ1FDQUVLQUpFSUFRb0FrZ2lERWNOQUNBRVFjQUFhaUFNUVFFUU1TQUVLQUpJSVF3TElBUW9Ba0FnREVFTWJHb2lEQ0FFS1FPQUFqY0NBQ0FNUVFocUlBOG9BZ0EyQWdBZ0JFSEFBR3BCQ0dvaURDQU1LQUlBUVFGcUlndzJBZ0FnQUVFSWFpQU1OZ0lBSUFBZ0JDa0RRRGNDQUNBRFJRMENJQVlnQTBFQkVIa01BZ3NnQUNBRUtRTkFOd0lBSUFCQkNHb2dCRUhBQUdwQkNHb29BZ0EyQWdBZ0EwVU5BQ0FHSUFOQkFSQjVDeUFFS0FKVUlneEZEUUFnREVFRWRDSU1SUTBBSUFRb0FsQWdERUVJRUhrTElBUkJzQUpxSkFBUEN5QURRUUVRaXdFQUM3Y1hBdzkvQW40RGZDTUFRYkFDYXlJRUpBQWdCRUlBTndKRUlBUkJBQ2dDaUlCQU5nSkFJQVJDQURjQ1ZDQUVRUUFvQW9DQVFDSUZOZ0pRQWtBQ1FBSkFBa0FnQTBFQVNBMEFJQU1OQVVFQklRWU1BZ3NRZndBTElBTkJBUkJ5SWdaRkRRRUxBa0FDUUFKQUlBTU5BQ0FBSUFRcEEwQTNBZ0FnQUVFSWFpQUVRY0FBYWtFSWFpZ0NBRFlDQUF3QkN5QUNJQU5CQTNScUlRY2dCRUdBQW1wQkVHb2hDQ0FCUVJocUlRa2dBVUVJYWlFS1FRQWhDd05BQWtBZ0JpQUxhaUlNTFFBQURRQWdERUVCT2dBQUlBUWdDellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VUUVFBcEE0Q01RQ0VVUVlDTXdBQWhEQXdCQ3lBRVFUQnFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTTRJaE0zQTRpTVFFR0FqTUFBSVF3Z0JDa0RNQ0VVQ3lBTUlCUkNBWHczQXdBUXBRRWhEQ0FFUWdBM0EzZ2dCQ0FNTmdKMElBUkJBRFlDY0NBRUlCTTNBMmdnQkNBVU53TmdJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQjRBQnFFRU1nQVNzREFDQUtLd01BSUFzZ0JFSGdBR29nQWlBREVDQWhGU0FCUVJCcUlRMUVBQUFBQUFBQThEOGhGZ0pBQWtBQ1FDQUpLd01BSWhjZ0ZXVU5BQ0FOS3dNQUloWWdGV1FOQVNBVklCYWhJQmNnRnFHakloWkVBQUFBQUFBQUFBQmhEUUVMSUFSQmtBRnFRUmhxSUFSQjRBQnFRUmhxS1FNQU53TUFJQVJCa0FGcVFSQnFJQVJCNEFCcVFSQnFLUU1BTndNQUlBUkJrQUZxUVFocUlBUkI0QUJxUVFocUtRTUFOd01BSUFRZ0JDa0RZRGNEa0FFQ1FFRVFRUWdRY1NJTVJRMEFJQXhCQURvQURDQU1JQXMyQWdnZ0RDQVdPUU1BSUFSQ2dZQ0FnQkEzQW9RQklBUWdERFlDZ0FFZ0JFSUFOd0swQVNBRUlBVTJBckFCQWtBZ0EwRUJFSElpRGtVTkFBSkFBa0FnQkNnQ3BBRWlEeWdDQUVHQWdZS0VlSEVpREVHQWdZS0VlRVlOQUNBTVFZQ0Jnb1I0Y3lFTURBRUxJQVFvQXFBQklBOXFRUUZxSVJBZ0QwRUVhaUVNQTBBZ0RDQVFUdzBGSUE5QmNHb2hEeUFNS0FJQUlSRWdERUVFYWlFTUlCRkJnSUdDaEhoeEloRkJnSUdDaEhoR0RRQUxJQkZCZ0lHQ2hIaHpJUXdMSUFRZ0R5QU1hRUVEZGtGL2MwRUNkR29vQWdBMkFvQUNJQVJCS0dvZ0JFR1FBV29nQkVHQUFtb1FIaUFFS0FJb1JRMERJQVFvQWl3aER3TkFBa0FnRHlBRFNRMEFJQThnQTBIRWdNQUFFRWNBQ3lBR0lBOXFRUUU2QUFBZ0RpQVBha0VCT2dBQUlBUWdEellDNEFFQ1FBSkFRUUFwQS9pTFFFSUJVZzBBUVFBcEE0aU1RQ0VUUVFBcEE0Q01RQ0VVUVlDTXdBQWhEQXdCQ3lBRVFSaHFFSFJCQUVJQk53UDRpMEJCQUNBRUtRTWdJaE0zQTRpTVFFR0FqTUFBSVF3Z0JDa0RHQ0VVQ3lBTUlCUkNBWHczQXdBUXBRRWhEQ0FFUWdBM0E5Z0JJQVFnRERZQzFBRWdCRUVBTmdMUUFTQUVJQk0zQThnQklBUWdGRGNEd0FFZ0JDQUROZ0tVQWlBRUlBSTJBcEFDSUFSQkFEWUNpQUlnQkNBSE5nS0VBaUFFSUFJMkFvQUNJQVFnQVRZQ21BSWdCQ0FFUWVBQmFqWUNqQUlnQkVHQUFtb2dCRUhBQVdvUVF5QUJLd01BSUFvckF3QWdEeUFFUWNBQmFpQUNJQU1RSUNFVlJBQUFBQUFBQVBBL0lSWUNRQUpBSUFrckF3QWlGeUFWWlEwQUFrQWdEU3NEQUNJV0lCVmtEUUFnRlNBV29TQVhJQmFob3lJV1JBQUFBQUFBQUFBQVpBMEJDd0pBSUFRb0FyUUJJQVFvQXJnQklneEhEUUFnQkVHd0FXb2dERUVCRURJZ0JDZ0N1QUVoREFzZ0JDZ0NzQUVnREVFRWRHb2lERUVCT2dBTUlBd2dEellDQ0NBTVF2Ly8vLy8vLy8vMy93QTNBd0FnQkNBRUtBSzRBVUVCYWpZQ3VBRWdCQ2dDMEFFaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBTFVBU0FQYXlBTVFRUVFlUXdCQ3lBRVFZQUNha0VZYWlJTUlBUkJ3QUZxUVJocUtRTUFOd01BSUFnZ0JFSEFBV3BCRUdvcEF3QTNBd0FnQkVHQUFtcEJDR29pRVNBRVFjQUJha0VJYWlrREFEY0RBQ0FFSUFRcEE4QUJOd09BQWlBRVFhQUNha0VJYWlBSVFRaHFLUUlBTndNQUlBUWdDQ2tDQURjRG9BSWdCRUhnQVdvZ0JFR2dBbW9RUkNBTUlBUkI0QUZxUVJocUtRTUFOd01BSUFnZ0JFSGdBV3BCRUdvcEF3QTNBd0FnRVNBRVFlQUJha0VJYWlrREFEY0RBQ0FFSUFRcEErQUJOd09BQWlBRVFSQnFJQVJCZ0FKcUVEa0NRQ0FFS0FJUVJRMEFJQVFvQWhRaERBTkFBa0FDUUNBTUlBTlBEUUFnRGlBTWFpMEFBQTBCSUFSQmtBRnFJQXdRRXhvTUFRc2dEQ0FEUWRTQXdBQVFSd0FMSUFSQkNHb2dCRUdBQW1vUU9TQUVLQUlNSVF3Z0JDZ0NDQTBBQ3dzQ1FDQUVLQUtVQWlJTVJRMEFJQVFvQXBnQ0loRkZEUUFnRENBUklBUW9BcHdDRUhrTEFrQWdCQ2dDaEFFZ0JDZ0NpQUVpREVjTkFDQUVRWUFCYWlBTVFRRVFNaUFFS0FLSUFTRU1DeUFFS0FLQUFTQU1RUVIwYWlJTVFRQTZBQXdnRENBUE5nSUlJQXdnRmprREFDQUVJQVFvQW9nQlFRRnFOZ0tJQVFzQ1FBSkFJQVFvQXFRQklnOG9BZ0JCZ0lHQ2hIaHhJZ3hCZ0lHQ2hIaEdEUUFnREVHQWdZS0VlSE1oREF3QkN5QUVLQUtnQVNBUGFrRUJhaUVRSUE5QkJHb2hEQU5BSUF3Z0VFOE5CaUFQUVhCcUlROGdEQ2dDQUNFUklBeEJCR29oRENBUlFZQ0Jnb1I0Y1NJUlFZQ0Jnb1I0UmcwQUN5QVJRWUNCZ29SNGN5RU1DeUFFSUE4Z0RHaEJBM1pCZjNOQkFuUnFLQUlBTmdLQUFpQUVJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NCQ0VQSUFRb0FnQU5BQXdFQ3dzZ0EwRUJFSXNCQUF0QkVFRUlFSXNCQUFzQ1FDQUVLQUpVSUFRb0FsZ2lERWNOQUNBRVFkQUFhaUFNUVFFUU1pQUVLQUpZSVF3TElBUW9BbEFnREVFRWRHb2lERUVDT2dBTUlBd2dDellDQ0NBTVFvQ0FnSUNBZ0lENFB6Y0RBQ0FFSUFRb0FsaEJBV28yQWxnZ0JDZ0NjQ0lNUlEwQklBd2dERUVDZEVFRWFpSVBha0VGYWlJTVJRMEJJQVFvQW5RZ0Qyc2dERUVFRUhrTUFRc2dCQ2dDc0FFaER3SkFJQVFvQXJnQklneEJCSFFpRVVVTkFDQVBJQkZxSVJJRFFBSkFJQVFvQW9nQlFRUjBJaEZGRFFBZ0JDZ0NnQUVoREFOQUFrQUNRQUpBSUE4b0FnZ2lFQ0FEVHcwQUlBeEJDR29vQWdBaURTQURUdzBCUkFBQUFBQUFBUEEvSVJVQ1FDQUNJQkJCQTNScUlBSWdEVUVEZEdvUU5DSVdJQUVyQXdBaUYyVU5BQ0FXSUFvckF3QWlGV1FOQXlBVklCYWhJQlVnRjZHakloVkVBQUFBQUFBQUFBQmtSUTBEQ3lBUEt3TUFJUllnRHlBTUt3TUFJQlVRWkNBV0VHUTVBd0FNQWdzZ0VDQURRYVNBd0FBUVJ3QUxJQTBnQTBHMGdNQUFFRWNBQ3lBTVFSQnFJUXdnRVVGd2FpSVJEUUFMQ3lBUFFSQnFJZzhnRWtjTkFBc2dCQ2dDdUFFaERDQUVLQUt3QVNFUEN3SkFJQVFvQW9RQklBUW9Bb2dCSWhGcklBeFBEUUFnQkVHQUFXb2dFU0FNRURJZ0JDZ0NpQUVoRVFzZ0JDZ0NnQUVnRVVFRWRHb2dEeUFNUVFSMEVEb2FJQVJCQURZQ3VBRWdCQ0FFS0FLSUFTQU1hallDaUFFZ0RpQURRUUVRZVFKQUlBUW9BclFCSWd4RkRRQWdERUVFZENJTVJRMEFJQVFvQXJBQklBeEJDQkI1Q3dKQUlBUW9BcUFCSWd4RkRRQWdEQ0FNUVFKMFFRUnFJZzlxUVFWcUlneEZEUUFnQkNnQ3BBRWdEMnNnREVFRUVIa0xBa0FnQkNnQ1JDQUVLQUpJSWd4SERRQWdCRUhBQUdvZ0RFRUJFREVnQkNnQ1NDRU1DeUFFS0FKQUlBeEJER3hxSWd3Z0JDa0RnQUUzQWdBZ0RFRUlhaUFFUVlBQmFrRUlhaWdDQURZQ0FDQUVJQVFvQWtoQkFXbzJBa2dMSUF0QkFXb2lDeUFEUncwQUN3SkFJQVFvQWxoRkRRQWdCRUdBQW1wQkNHb2lEeUFFUWRBQWFrRUlhaWdDQURZQ0FDQUVJQVFwQTFBM0E0QUNBa0FnQkNnQ1JDQUVLQUpJSWd4SERRQWdCRUhBQUdvZ0RFRUJFREVnQkNnQ1NDRU1DeUFFS0FKQUlBeEJER3hxSWd3Z0JDa0RnQUkzQWdBZ0RFRUlhaUFQS0FJQU5nSUFJQVJCd0FCcVFRaHFJZ3dnRENnQ0FFRUJhaUlNTmdJQUlBQkJDR29nRERZQ0FDQUFJQVFwQTBBM0FnQWdBMFVOQWlBR0lBTkJBUkI1REFJTElBQWdCQ2tEUURjQ0FDQUFRUWhxSUFSQndBQnFRUWhxS0FJQU5nSUFJQU5GRFFBZ0JpQURRUUVRZVFzZ0JDZ0NWQ0lNUlEwQUlBeEJCSFFpREVVTkFDQUVLQUpRSUF4QkNCQjVDeUFFUWJBQ2FpUUFEd3NnQTBFQkVJc0JBQXUzRndNUGZ3SitBM3dqQUVHd0Ftc2lCQ1FBSUFSQ0FEY0NSQ0FFUVFBb0FvaUFRRFlDUUNBRVFnQTNBbFFnQkVFQUtBS0FnRUFpQlRZQ1VBSkFBa0FDUUFKQUlBTkJBRWdOQUNBRERRRkJBU0VHREFJTEVIOEFDeUFEUVFFUWNpSUdSUTBCQ3dKQUFrQUNRQ0FERFFBZ0FDQUVLUU5BTndJQUlBQkJDR29nQkVIQUFHcEJDR29vQWdBMkFnQU1BUXNnQWlBRFFRTjBhaUVISUFSQmdBSnFRUkJxSVFnZ0FVRVlhaUVKSUFGQkNHb2hDa0VBSVFzRFFBSkFJQVlnQzJvaURDMEFBQTBBSUF4QkFUb0FBQ0FFSUFzMkF1QUJBa0FDUUVFQUtRUDRpMEJDQVZJTkFFRUFLUU9JakVBaEUwRUFLUU9BakVBaEZFR0FqTUFBSVF3TUFRc2dCRUV3YWhCMFFRQkNBVGNEK0l0QVFRQWdCQ2tET0NJVE53T0lqRUJCZ0l6QUFDRU1JQVFwQXpBaEZBc2dEQ0FVUWdGOE53TUFFS1VCSVF3Z0JFSUFOd040SUFRZ0REWUNkQ0FFUVFBMkFuQWdCQ0FUTndOb0lBUWdGRGNEWUNBRUlBTTJBcFFDSUFRZ0FqWUNrQUlnQkVFQU5nS0lBaUFFSUFjMkFvUUNJQVFnQWpZQ2dBSWdCQ0FCTmdLWUFpQUVJQVJCNEFGcU5nS01BaUFFUVlBQ2FpQUVRZUFBYWhCQ0lBRXJBd0FnQ2lzREFDQUxJQVJCNEFCcUlBSWdBeEFoSVJVZ0FVRVFhaUVOUkFBQUFBQUFBUEEvSVJZQ1FBSkFBa0FnQ1NzREFDSVhJQlZsRFFBZ0RTc0RBQ0lXSUJWa0RRRWdGU0FXb1NBWElCYWhveUlXUkFBQUFBQUFBQUFBWVEwQkN5QUVRWkFCYWtFWWFpQUVRZUFBYWtFWWFpa0RBRGNEQUNBRVFaQUJha0VRYWlBRVFlQUFha0VRYWlrREFEY0RBQ0FFUVpBQmFrRUlhaUFFUWVBQWFrRUlhaWtEQURjREFDQUVJQVFwQTJBM0E1QUJBa0JCRUVFSUVIRWlERVVOQUNBTVFRQTZBQXdnRENBTE5nSUlJQXdnRmprREFDQUVRb0dBZ0lBUU53S0VBU0FFSUF3MkFvQUJJQVJDQURjQ3RBRWdCQ0FGTmdLd0FRSkFJQU5CQVJCeUlnNUZEUUFDUUFKQUlBUW9BcVFCSWc4b0FnQkJnSUdDaEhoeElneEJnSUdDaEhoR0RRQWdERUdBZ1lLRWVITWhEQXdCQ3lBRUtBS2dBU0FQYWtFQmFpRVFJQTlCQkdvaERBTkFJQXdnRUU4TkJTQVBRWEJxSVE4Z0RDZ0NBQ0VSSUF4QkJHb2hEQ0FSUVlDQmdvUjRjU0lSUVlDQmdvUjRSZzBBQ3lBUlFZQ0Jnb1I0Y3lFTUN5QUVJQThnREdoQkEzWkJmM05CQW5ScUtBSUFOZ0tBQWlBRVFTaHFJQVJCa0FGcUlBUkJnQUpxRUI0Z0JDZ0NLRVVOQXlBRUtBSXNJUThEUUFKQUlBOGdBMGtOQUNBUElBTkJ4SURBQUJCSEFBc2dCaUFQYWtFQk9nQUFJQTRnRDJwQkFUb0FBQ0FFSUE4MkF1QUJBa0FDUUVFQUtRUDRpMEJDQVZJTkFFRUFLUU9JakVBaEUwRUFLUU9BakVBaEZFR0FqTUFBSVF3TUFRc2dCRUVZYWhCMFFRQkNBVGNEK0l0QVFRQWdCQ2tESUNJVE53T0lqRUJCZ0l6QUFDRU1JQVFwQXhnaEZBc2dEQ0FVUWdGOE53TUFFS1VCSVF3Z0JFSUFOd1BZQVNBRUlBdzJBdFFCSUFSQkFEWUMwQUVnQkNBVE53UElBU0FFSUJRM0E4QUJJQVFnQXpZQ2xBSWdCQ0FDTmdLUUFpQUVRUUEyQW9nQ0lBUWdCellDaEFJZ0JDQUNOZ0tBQWlBRUlBRTJBcGdDSUFRZ0JFSGdBV28yQW93Q0lBUkJnQUpxSUFSQndBRnFFRUlnQVNzREFDQUtLd01BSUE4Z0JFSEFBV29nQWlBREVDRWhGVVFBQUFBQUFBRHdQeUVXQWtBQ1FDQUpLd01BSWhjZ0ZXVU5BQUpBSUEwckF3QWlGaUFWWkEwQUlCVWdGcUVnRnlBV29hTWlGa1FBQUFBQUFBQUFBR1FOQVFzQ1FDQUVLQUswQVNBRUtBSzRBU0lNUncwQUlBUkJzQUZxSUF4QkFSQXlJQVFvQXJnQklRd0xJQVFvQXJBQklBeEJCSFJxSWd4QkFUb0FEQ0FNSUE4MkFnZ2dERUwvLy8vLy8vLy85LzhBTndNQUlBUWdCQ2dDdUFGQkFXbzJBcmdCSUFRb0F0QUJJZ3hGRFFFZ0RDQU1RUUowUVFScUlnOXFRUVZxSWd4RkRRRWdCQ2dDMUFFZ0Qyc2dERUVFRUhrTUFRc2dCRUdBQW1wQkdHb2lEQ0FFUWNBQmFrRVlhaWtEQURjREFDQUlJQVJCd0FGcVFSQnFLUU1BTndNQUlBUkJnQUpxUVFocUloRWdCRUhBQVdwQkNHb3BBd0EzQXdBZ0JDQUVLUVBBQVRjRGdBSWdCRUdnQW1wQkNHb2dDRUVJYWlrQ0FEY0RBQ0FFSUFncEFnQTNBNkFDSUFSQjRBRnFJQVJCb0FKcUVFUWdEQ0FFUWVBQmFrRVlhaWtEQURjREFDQUlJQVJCNEFGcVFSQnFLUU1BTndNQUlCRWdCRUhnQVdwQkNHb3BBd0EzQXdBZ0JDQUVLUVBnQVRjRGdBSWdCRUVRYWlBRVFZQUNhaEE1QWtBZ0JDZ0NFRVVOQUNBRUtBSVVJUXdEUUFKQUFrQWdEQ0FEVHcwQUlBNGdER290QUFBTkFTQUVRWkFCYWlBTUVCTWFEQUVMSUF3Z0EwSFVnTUFBRUVjQUN5QUVRUWhxSUFSQmdBSnFFRGtnQkNnQ0RDRU1JQVFvQWdnTkFBc0xBa0FnQkNnQ2xBSWlERVVOQUNBRUtBS1lBaUlSUlEwQUlBd2dFU0FFS0FLY0FoQjVDd0pBSUFRb0FvUUJJQVFvQW9nQklneEhEUUFnQkVHQUFXb2dERUVCRURJZ0JDZ0NpQUVoREFzZ0JDZ0NnQUVnREVFRWRHb2lERUVBT2dBTUlBd2dEellDQ0NBTUlCWTVBd0FnQkNBRUtBS0lBVUVCYWpZQ2lBRUxBa0FDUUNBRUtBS2tBU0lQS0FJQVFZQ0Jnb1I0Y1NJTVFZQ0Jnb1I0UmcwQUlBeEJnSUdDaEhoeklRd01BUXNnQkNnQ29BRWdEMnBCQVdvaEVDQVBRUVJxSVF3RFFDQU1JQkJQRFFZZ0QwRndhaUVQSUF3b0FnQWhFU0FNUVFScUlRd2dFVUdBZ1lLRWVIRWlFVUdBZ1lLRWVFWU5BQXNnRVVHQWdZS0VlSE1oREFzZ0JDQVBJQXhvUVFOMlFYOXpRUUowYWlnQ0FEWUNnQUlnQkNBRVFaQUJhaUFFUVlBQ2FoQWVJQVFvQWdRaER5QUVLQUlBRFFBTUJBc0xJQU5CQVJDTEFRQUxRUkJCQ0JDTEFRQUxBa0FnQkNnQ1ZDQUVLQUpZSWd4SERRQWdCRUhRQUdvZ0RFRUJFRElnQkNnQ1dDRU1DeUFFS0FKUUlBeEJCSFJxSWd4QkFqb0FEQ0FNSUFzMkFnZ2dERUtBZ0lDQWdJQ0ErRDgzQXdBZ0JDQUVLQUpZUVFGcU5nSllJQVFvQW5BaURFVU5BU0FNSUF4QkFuUkJCR29pRDJwQkJXb2lERVVOQVNBRUtBSjBJQTlySUF4QkJCQjVEQUVMSUFRb0FyQUJJUThDUUNBRUtBSzRBU0lNUVFSMEloRkZEUUFnRHlBUmFpRVNBMEFDUUNBRUtBS0lBVUVFZENJUlJRMEFJQVFvQW9BQklRd0RRQUpBQWtBQ1FDQVBLQUlJSWhBZ0EwOE5BQ0FNUVFocUtBSUFJZzBnQTA4TkFVUUFBQUFBQUFEd1B5RVZBa0FnQWlBUVFRTjBhaUFDSUExQkEzUnFFRGdpRmlBQkt3TUFJaGRsRFFBZ0ZpQUtLd01BSWhWa0RRTWdGU0FXb1NBVklCZWhveUlWUkFBQUFBQUFBQUFBWkVVTkF3c2dEeXNEQUNFV0lBOGdEQ3NEQUNBVkVHUWdGaEJrT1FNQURBSUxJQkFnQTBHa2dNQUFFRWNBQ3lBTklBTkJ0SURBQUJCSEFBc2dERUVRYWlFTUlCRkJjR29pRVEwQUN3c2dEMEVRYWlJUElCSkhEUUFMSUFRb0FyZ0JJUXdnQkNnQ3NBRWhEd3NDUUNBRUtBS0VBU0FFS0FLSUFTSVJheUFNVHcwQUlBUkJnQUZxSUJFZ0RCQXlJQVFvQW9nQklSRUxJQVFvQW9BQklCRkJCSFJxSUE4Z0RFRUVkQkE2R2lBRVFRQTJBcmdCSUFRZ0JDZ0NpQUVnREdvMkFvZ0JJQTRnQTBFQkVIa0NRQ0FFS0FLMEFTSU1SUTBBSUF4QkJIUWlERVVOQUNBRUtBS3dBU0FNUVFnUWVRc0NRQ0FFS0FLZ0FTSU1SUTBBSUF3Z0RFRUNkRUVFYWlJUGFrRUZhaUlNUlEwQUlBUW9BcVFCSUE5cklBeEJCQkI1Q3dKQUlBUW9Ba1FnQkNnQ1NDSU1SdzBBSUFSQndBQnFJQXhCQVJBeElBUW9Ba2doREFzZ0JDZ0NRQ0FNUVF4c2FpSU1JQVFwQTRBQk53SUFJQXhCQ0dvZ0JFR0FBV3BCQ0dvb0FnQTJBZ0FnQkNBRUtBSklRUUZxTmdKSUN5QUxRUUZxSWdzZ0EwY05BQXNDUUNBRUtBSllSUTBBSUFSQmdBSnFRUWhxSWc4Z0JFSFFBR3BCQ0dvb0FnQTJBZ0FnQkNBRUtRTlFOd09BQWdKQUlBUW9Ba1FnQkNnQ1NDSU1SdzBBSUFSQndBQnFJQXhCQVJBeElBUW9Ba2doREFzZ0JDZ0NRQ0FNUVF4c2FpSU1JQVFwQTRBQ053SUFJQXhCQ0dvZ0R5Z0NBRFlDQUNBRVFjQUFha0VJYWlJTUlBd29BZ0JCQVdvaUREWUNBQ0FBUVFocUlBdzJBZ0FnQUNBRUtRTkFOd0lBSUFORkRRSWdCaUFEUVFFUWVRd0NDeUFBSUFRcEEwQTNBZ0FnQUVFSWFpQUVRY0FBYWtFSWFpZ0NBRFlDQUNBRFJRMEFJQVlnQTBFQkVIa0xJQVFvQWxRaURFVU5BQ0FNUVFSMElneEZEUUFnQkNnQ1VDQU1RUWdRZVFzZ0JFR3dBbW9rQUE4TElBTkJBUkNMQVFBTHF4RUNFWDhNZmlNQVFlQUFheUlFSkFBQ1FBSkFJQUZCREdvb0FnQWlCU0FDYWlJQ0lBVlBEUUFnQkVFQkVHSWdCQ2tEQUNFVklBQkJBVFlDQUNBQUlCVTNBZ1FNQVFzQ1FBSkFBa0FDUUFKQUlBSWdBU2dDQUNJR0lBWkJBV29pQjBFRGRrRUhiQ0FHUVFoSkd5SUlRUUYyVFEwQUlBSWdDRUVCYWlJSklBSWdDVXNiSWdKQkNFa05BUUpBSUFKQi8vLy8vd0Z4SUFKSERRQkJmeUFDUVFOMFFRZHVRWDlxWjNaQkFXb2hBZ3dEQ3lBRVFSaHFRUUVRWWlBRUtBSWNJUUlnQkNnQ0dDRUpEQU1MSUFGQkJHb29BZ0FoQ2tFQUlRbEJBQ0VDQTBBQ1FBSkFBa0FnQ1VFQmNRMEFJQUlnQjA4TkFRd0NDeUFDUVFOcUlna2dBa2tOQUNBSklRSWdDU0FIU1EwQkN3SkFBa0FDUUNBSFFRUkpEUUFnQ2lBSGFpQUtLQUFBTmdBQURBRUxJQXBCQkdvZ0NpQUhFQ1VhSUFkRkRRRUxJQU1wQXdBaUZrTGg1Slh6MXV6WnZPd0FoU0VYSUJaQzljck5nOWVzMjdmekFJVWhHQ0FEUVFocUtRTUFJaGxDODhyUnk2ZU0yYkwwQUlVaEdpQVpRdTNla2ZPV3pOeTM1QUNGSVJzZ0JFSFFBR29oQzBFQUlRSURRQUpBSUFvZ0FpSU1haUlOTFFBQVFZQUJSdzBBSUFvZ0RFRi9jMEVDZEdvaURpZ0NBQ0VDQWtBRFFDQUxRZ0EzQXdBZ0MwRUlha0VBTmdJQUlBUkJBRFlDWENBRUlCbzNBMGdnQkNBYk53TkFJQVFnRnpjRE9DQUVJQmczQXpBZ0JDQVpOd01vSUFRZ0ZqY0RJQ0FDSUFSQklHb1FGU0FHSUFRMUFsaENPSVlnQkNrRFVJUWlGU0FFS1FOSWhTSWNRaENKSUJ3Z0JDa0RPSHdpSElVaUhTQUVLUU5BSWg0Z0JDa0RNSHdpSDBJZ2lYd2lJQ0FWaFNBY0lCNUNEWWtnSDRVaUZYd2lIQ0FWUWhHSmhTSVZmQ0llSUJWQ0RZbUZJaFVnSFVJVmlTQWdoU0lkSUJ4Q0lJbEMvd0dGZkNJY2ZDSWZJQlZDRVltRkloVkNEWWtnRlNBZFFoQ0pJQnlGSWh3Z0hrSWdpWHdpSFh3aUZZVWlIa0lSaVNBZUlCeENGWWtnSFlVaUhDQWZRaUNKZkNJZGZDSWVoU0lmUWcySklCOGdIRUlRaVNBZGhTSWNJQlZDSUlsOEloVjhoU0lkSUJ4Q0ZZa2dGWVVpRlNBZVFpQ0pmQ0ljZkNJZUlCVkNFSWtnSElWQ0ZZbUZJQjFDRVltRklCNUNJSWlGcHlJRGNTSVBJUWtDUUNBS0lBOXFLQUFBUVlDQmdvUjRjU0lIRFFCQkJDRUNJQThoQ1FOQUlBa2dBbW9oQ1NBQ1FRUnFJUUlnQ2lBSklBWnhJZ2xxS0FBQVFZQ0Jnb1I0Y1NJSFJRMEFDd3NDUUNBS0lBZG9RUU4ySUFscUlBWnhJZ0pxTEFBQVFYOU1EUUFnQ2lnQ0FFR0FnWUtFZUhGb1FRTjJJUUlMSUFJZ0Qyc2dEQ0FQYTNNZ0JuRkJCRWtOQVNBS0lBSnFJZ2t0QUFBaEJ5QUpJQU5CR1hZaUR6b0FBQ0FDUVh4cUlBWnhJQXBxUVFScUlBODZBQUFDUUNBSFFmOEJSZzBBSUFvZ0FrRi9jMEVDZEdvaUNTZ0NBQ0VDSUFrZ0RpZ0NBRFlDQUNBT0lBSTJBZ0FNQVFzTElBMUIvd0U2QUFBZ0RFRjhhaUFHY1NBS2FrRUVha0gvQVRvQUFDQUtJQUpCZjNOQkFuUnFJQTRvQWdBMkFnQU1BUXNnRFNBRFFSbDJJZ0k2QUFBZ0RFRjhhaUFHY1NBS2FrRUVhaUFDT2dBQUN5QU1RUUZxSVFJZ0RDQUdSdzBBQ3dzZ0FFRUFOZ0lBSUFFZ0NDQUZhellDQ0F3R0N5QUtJQUpxSWdrZ0NTZ0NBQ0lKUVFkMlFYOXpRWUdDaEFoeElBbEIvLzc5K3dkeWFqWUNBRUVCSVFrZ0FrRUJhaUVDREFBTEMwRUVRUWdnQWtFRVNSc2hBZ3NDUUFKQUlBSkIvLy8vL3dOeElBSkhEUUJCQkNFUElBSkJBblFpQ1NBQ1FRUnFJZ3RxSWdvZ0NVOE5BUXNnQkVFSWFrRUJFR0lnQkNnQ0RDRUNJQVFvQWdnaENRd0JDeUFLUlEwQklBcEJCQkJ4SWc4TkFTQUVRUkJxUVFFZ0NrRUVFR0VnQkNnQ0ZDRUNJQVFvQWhBaENRc2dBQ0FKTmdJRUlBQkJBVFlDQUNBQVFRaHFJQUkyQWdBTUFRc2dEeUFKYWtIL0FTQUxFRHNoRHlBQ1FRTjJJUkFnQWtGL2FpRUxJQU5CQ0dvcEF3QWlGa0x6eXRITHA0elpzdlFBaFNFWElBTXBBd0FpR1VMaDVKWHoxdXpadk93QWhTRVlJQlpDN2Q2Ujg1Yk0zTGZrQUlVaEdpQVpRdlhLellQWHJOdTM4d0NGSVJzZ0FVRUVhaWdDQUNJUlFRUnFJUWtnRVNBSGFpRU1JQkVvQWdCQmYzTkJnSUdDaEhoeElRMGdCRUhRQUdvaENDQVJJUU1DUUFOQUFrQWdEUTBBQTBBZ0NTQU1UdzBESUFOQmNHb2hBeUFKS0FJQUlRSWdDVUVFYWlJS0lRa2dBa0dBZ1lLRWVIRWlBa0dBZ1lLRWVFWU5BQXNnQWtHQWdZS0VlSE1oRFNBS0lRa0xJQWhDQURjREFDQUlRUWhxUVFBMkFnQWdCRUVBTmdKY0lBUWdGemNEU0NBRUlCbzNBMEFnQkNBWU53TTRJQVFnR3pjRE1DQUVJQlkzQXlnZ0JDQVpOd01nSUFNZ0RXaEJBM1pCZjNOQkFuUnFJaElvQWdBZ0JFRWdhaEFWQWtBZ0R5QUxJQVExQWxoQ09JWWdCQ2tEVUlRaUZTQUVLUU5JaFNJY1FoQ0pJQndnQkNrRE9Id2lISVVpSFNBRUtRTkFJaDRnQkNrRE1Id2lIMElnaVh3aUlDQVZoU0FjSUI1Q0RZa2dINFVpRlh3aUhDQVZRaEdKaFNJVmZDSWVJQlZDRFltRkloVWdIVUlWaVNBZ2hTSWRJQnhDSUlsQy93R0ZmQ0ljZkNJZklCVkNFWW1GSWhWQ0RZa2dGU0FkUWhDSklCeUZJaHdnSGtJZ2lYd2lIWHdpRllVaUhrSVJpU0FlSUJ4Q0ZZa2dIWVVpSENBZlFpQ0pmQ0lkZkNJZWhTSWZRZzJKSUI4Z0hFSVFpU0FkaFNJY0lCVkNJSWw4SWhWOGhTSWRJQnhDRllrZ0ZZVWlGU0FlUWlDSmZDSWNmQ0llSUJWQ0VJa2dISVZDRlltRklCMUNFWW1GSUI1Q0lJaUZweUlUY1NJS2FpZ0FBRUdBZ1lLRWVIRWlEZzBBUVFRaEFnTkFJQW9nQW1vaENpQUNRUVJxSVFJZ0R5QUtJQXR4SWdwcUtBQUFRWUNCZ29SNGNTSU9SUTBBQ3dzZ0RVRi9haUVVQWtBZ0R5QU9hRUVEZGlBS2FpQUxjU0lDYWl3QUFFRi9UQTBBSUE4b0FnQkJnSUdDaEhoeGFFRURkaUVDQ3lBVUlBMXhJUTBnRHlBQ2FpQVRRUmwySWdvNkFBQWdBa0Y4YWlBTGNTQVBha0VFYWlBS09nQUFJQThnQWtGL2MwRUNkR29nRWlnQ0FEWUNBQXdBQ3dzZ0FTQUxOZ0lBSUFCQkFEWUNBQ0FCUVFScUlBODJBZ0FnQVNBTElCQkJCMndnQzBFSVNSc2dCV3MyQWdnZ0JrVU5BQ0FHSUFkQkFuUWlBbXBCQldvaUNVVU5BQ0FSSUFKcklBbEJCQkI1Q3lBRVFlQUFhaVFBQzRNSkFRcC9JQUFvQWhBaEF3SkFBa0FDUUFKQUlBQW9BZ2dpQkVFQlJnMEFJQU5CQVVZTkFTQUFLQUlZSUFFZ0FpQUFRUnhxS0FJQUtBSU1FUWtBSVFNTUF3c2dBMEVCUncwQkN5QUJJQUpxSVFVQ1FBSkFBa0FnQUVFVWFpZ0NBQ0lHRFFCQkFDRUhJQUVoQXd3QkMwRUFJUWNnQVNFREEwQWdBeUlJSUFWR0RRSWdDRUVCYWlFREFrQWdDQ3dBQUNJSlFYOUtEUUFnQ1VIL0FYRWhDUUpBQWtBZ0F5QUZSdzBBUVFBaENpQUZJUU1NQVFzZ0NFRUNhaUVESUFndEFBRkJQM0VoQ2dzZ0NVSGdBVWtOQUFKQUFrQWdBeUFGUncwQVFRQWhDeUFGSVF3TUFRc2dBMEVCYWlFTUlBTXRBQUJCUDNFaEN3c0NRQ0FKUWZBQlR3MEFJQXdoQXd3QkN3SkFBa0FnRENBRlJ3MEFRUUFoRENBRklRTU1BUXNnREVFQmFpRURJQXd0QUFCQlAzRWhEQXNnQ2tFTWRDQUpRUkowUVlDQThBQnhjaUFMUVFaMGNpQU1ja0dBZ01RQVJnMERDeUFISUFocklBTnFJUWNnQmtGL2FpSUdEUUFMQ3lBRElBVkdEUUFDUUNBRExBQUFJZ2hCZjBvTkFBSkFBa0FnQTBFQmFpQUZSdzBBUVFBaEF5QUZJUVlNQVFzZ0EwRUNhaUVHSUFNdEFBRkJQM0ZCQm5RaEF3c2dDRUgvQVhGQjRBRkpEUUFDUUFKQUlBWWdCVWNOQUVFQUlRWWdCU0VKREFFTElBWkJBV29oQ1NBR0xRQUFRVDl4SVFZTElBaEIvd0Z4UWZBQlNRMEFJQWhCL3dGeElRZ2dCaUFEY2lFREFrQUNRQ0FKSUFWSERRQkJBQ0VGREFFTElBa3RBQUJCUDNFaEJRc2dBMEVHZENBSVFSSjBRWUNBOEFCeGNpQUZja0dBZ01RQVJnMEJDd0pBQWtBQ1FDQUhEUUJCQUNFSURBRUxBa0FnQnlBQ1NRMEFRUUFoQXlBQ0lRZ2dCeUFDUmcwQkRBSUxRUUFoQXlBSElRZ2dBU0FIYWl3QUFFRkFTQTBCQ3lBSUlRY2dBU0VEQ3lBSElBSWdBeHNoQWlBRElBRWdBeHNoQVFzZ0JFRUJSZzBBSUFBb0FoZ2dBU0FDSUFCQkhHb29BZ0FvQWd3UkNRQVBDeUFBUVF4cUtBSUFJUVlDUUFKQUlBSU5BRUVBSVFnTUFRc2dBa0VEY1NFSEFrQUNRQ0FDUVg5cVFRTlBEUUJCQUNFSUlBRWhBd3dCQzBFQUlRaEJBQ0FDUVh4eGF5RUZJQUVoQXdOQUlBZ2dBeTBBQUVIQUFYRkJnQUZIYWlBRFFRRnFMUUFBUWNBQmNVR0FBVWRxSUFOQkFtb3RBQUJCd0FGeFFZQUJSMm9nQTBFRGFpMEFBRUhBQVhGQmdBRkhhaUVJSUFOQkJHb2hBeUFGUVFScUlnVU5BQXNMSUFkRkRRQURRQ0FJSUFNdEFBQkJ3QUZ4UVlBQlIyb2hDQ0FEUVFGcUlRTWdCMEYvYWlJSERRQUxDd0pBSUFZZ0NFME5BRUVBSVFNZ0JpQUlheUlISVFZQ1FBSkFBa0JCQUNBQUxRQWdJZ2dnQ0VFRFJodEJBM0VPQXdJQUFRSUxRUUFoQmlBSElRTU1BUXNnQjBFQmRpRURJQWRCQVdwQkFYWWhCZ3NnQTBFQmFpRURJQUJCSEdvb0FnQWhCeUFBS0FJRUlRZ2dBQ2dDR0NFRkFrQURRQ0FEUVg5cUlnTkZEUUVnQlNBSUlBY29BaEFSQmdCRkRRQUxRUUVQQzBFQklRTWdDRUdBZ01RQVJnMEJJQVVnQVNBQ0lBY29BZ3dSQ1FBTkFVRUFJUU1EUUFKQUlBWWdBMGNOQUNBR0lBWkpEd3NnQTBFQmFpRURJQVVnQ0NBSEtBSVFFUVlBUlEwQUN5QURRWDlxSUFaSkR3c2dBQ2dDR0NBQklBSWdBRUVjYWlnQ0FDZ0NEQkVKQUE4TElBTUx0QWtCQm44Z0FCQ1NBU0VBSUFBZ0FCQ0hBU0lCRUk4QklRSUNRQUpBQWtBZ0FCQ0lBUTBBSUFBb0FnQWhBd0pBQWtBZ0FCQjdEUUFnQXlBQmFpRUJJQUFnQXhDUUFTSUFRUUFvQXFpUFFFY05BU0FDS0FJRVFRTnhRUU5IRFFKQkFDQUJOZ0tnajBBZ0FDQUJJQUlRWUE4TFFaQ013QUFnQUNBRGF5QURJQUZxUVJCcUlnQVFvUUZGRFFKQkFFRUFLQUt3ajBBZ0FHczJBckNQUUE4TEFrQWdBMEdBQWtrTkFDQUFFQ3dNQVFzQ1FDQUFRUXhxS0FJQUlnUWdBRUVJYWlnQ0FDSUZSZzBBSUFVZ0JEWUNEQ0FFSUFVMkFnZ01BUXRCQUVFQUtBS1FqRUJCZmlBRFFRTjJkM0UyQXBDTVFBc0NRQUpBSUFJUWRVVU5BQ0FBSUFFZ0FoQmdEQUVMQWtBQ1FBSkFBa0FnQWtFQUtBS3NqMEJHRFFBZ0FrRUFLQUtvajBCSERRRkJBQ0FBTmdLb2owQkJBRUVBS0FLZ2owQWdBV29pQVRZQ29JOUFJQUFnQVJCbkR3dEJBQ0FBTmdLc2owQkJBRUVBS0FLa2owQWdBV29pQVRZQ3BJOUFJQUFnQVVFQmNqWUNCQ0FBUVFBb0FxaVBRRVlOQVF3Q0N5QUNFSWNCSWdNZ0FXb2hBUUpBQWtBZ0EwR0FBa2tOQUNBQ0VDd01BUXNDUUNBQ1FReHFLQUlBSWdRZ0FrRUlhaWdDQUNJQ1JnMEFJQUlnQkRZQ0RDQUVJQUkyQWdnTUFRdEJBRUVBS0FLUWpFQkJmaUFEUVFOMmQzRTJBcENNUUFzZ0FDQUJFR2NnQUVFQUtBS29qMEJIRFFKQkFDQUJOZ0tnajBBTUF3dEJBRUVBTmdLZ2owQkJBRUVBTmdLb2owQUxRUUFvQXNpUFFDQUJUdzBCUVFBUWtRRWhBQ0FBSUFCQkNCQnJRUlJCQ0JCcmFrRVFRUWdRYTJwclFmai9lMnBCZDNGQmZXb2lBRUVBUVJCQkNCQnJRUUowYXlJQklBRWdBRXNiUlEwQlFRQW9BcXlQUUVVTkFVRUFFSkVCSWdCQkNCQnJJUUZCRkVFSUVHc2hBMEVRUVFnUWF5RUVRUUFoQWdKQVFRQW9BcVNQUUNJRklBUWdBeUFCSUFCcmFtb2lBRTBOQUNBRklBQkJmM05xUVlDQWZIRWhBMEVBS0FLc2owQWhBVUc0ajhBQUlRQUNRQU5BQWtBZ0FDZ0NBQ0FCU3cwQUlBQVFmU0FCU3cwQ0N5QUFLQUlJSWdBTkFBdEJBQ0VBQzBFQUlRSWdBQkNKQVEwQVFaQ013QUFnQUVFTWFpZ0NBRUVCZGhDaUFVVU5BQ0FBS0FJRUlBTkpEUUJCdUkvQUFDRUJBMEFnQUNBQkVGNE5BU0FCS0FJSUlnRU5BQXRCa0l6QUFDQUFLQUlBSUFBb0FnUWlBU0FCSUFOckVLQUJSUTBBSUFORkRRQWdBQ0FBS0FJRUlBTnJOZ0lFUVFCQkFDZ0NzSTlBSUFOck5nS3dqMEJCQUNnQ3BJOUFJUUZCQUNnQ3JJOUFJUUJCQUNBQUlBQVFrUUVpQWtFSUVHc2dBbXNpQWhDUEFTSUFOZ0tzajBCQkFDQUJJQU1nQW1wcklnRTJBcVNQUUNBQUlBRkJBWEkyQWdSQkFCQ1JBU0lDUVFnUWF5RUVRUlJCQ0JCcklRVkJFRUVJRUdzaEJpQUFJQUVRandFZ0JpQUZJQVFnQW10cWFqWUNCRUVBUVlDQWdBRTJBc2lQUUNBRElRSUxJQUpCQUJBdWEwY05BVUVBS0FLa2owQkJBQ2dDeUk5QVRRMEJRUUJCZnpZQ3lJOUFEd3NnQVVHQUFra05BU0FBSUFFUUswRUFRUUFvQXRDUFFFRi9haUlBTmdMUWowQWdBQTBBRUM0YUR3c1BDeUFCUVFOMklnSkJBM1JCbUl6QUFHb2hBUUpBQWtCQkFDZ0NrSXhBSWdOQkFTQUNkQ0lDY1VVTkFDQUJLQUlJSVFJTUFRdEJBQ0FESUFKeU5nS1FqRUFnQVNFQ0N5QUJJQUEyQWdnZ0FpQUFOZ0lNSUFBZ0FUWUNEQ0FBSUFJMkFnZ0x6d2NCQjM4Q1FBSkFJQUZGRFFCQkswR0FnTVFBSUFBb0FnQWlCa0VCY1NJQkd5RUhJQUVnQldvaENBd0JDeUFGUVFGcUlRZ2dBQ2dDQUNFR1FTMGhCd3NDUUFKQUlBWkJCSEVOQUVFQUlRSU1BUXNDUUFKQUlBTU5BRUVBSVFrTUFRc2dBMEVEY1NFS0FrQUNRQ0FEUVg5cVFRTlBEUUJCQUNFSklBSWhBUXdCQzBFQUlRbEJBQ0FEUVh4eGF5RUxJQUloQVFOQUlBa2dBUzBBQUVIQUFYRkJnQUZIYWlBQlFRRnFMUUFBUWNBQmNVR0FBVWRxSUFGQkFtb3RBQUJCd0FGeFFZQUJSMm9nQVVFRGFpMEFBRUhBQVhGQmdBRkhhaUVKSUFGQkJHb2hBU0FMUVFScUlnc05BQXNMSUFwRkRRQURRQ0FKSUFFdEFBQkJ3QUZ4UVlBQlIyb2hDU0FCUVFGcUlRRWdDa0YvYWlJS0RRQUxDeUFKSUFocUlRZ0xRUUVoQVFKQUFrQWdBQ2dDQ0VFQlJnMEFJQUFnQnlBQ0lBTVFUdzBCSUFBb0FoZ2dCQ0FGSUFCQkhHb29BZ0FvQWd3UkNRQVBDd0pBQWtBQ1FBSkFBa0FnQUVFTWFpZ0NBQ0lKSUFoTkRRQWdCa0VJY1EwRVFRQWhBU0FKSUFocklnb2hDRUVCSUFBdEFDQWlDU0FKUVFOR0cwRURjUTREQXdFQ0F3c2dBQ0FISUFJZ0F4QlBEUVFnQUNnQ0dDQUVJQVVnQUVFY2FpZ0NBQ2dDREJFSkFBOExRUUFoQ0NBS0lRRU1BUXNnQ2tFQmRpRUJJQXBCQVdwQkFYWWhDQXNnQVVFQmFpRUJJQUJCSEdvb0FnQWhDaUFBS0FJRUlRa2dBQ2dDR0NFTEFrQURRQ0FCUVg5cUlnRkZEUUVnQ3lBSklBb29BaEFSQmdCRkRRQUxRUUVQQzBFQklRRWdDVUdBZ01RQVJnMEJJQUFnQnlBQ0lBTVFUdzBCSUFBb0FoZ2dCQ0FGSUFBb0Fod29BZ3dSQ1FBTkFTQUFLQUljSVFvZ0FDZ0NHQ0VMUVFBaEFRSkFBMEFDUUNBSUlBRkhEUUFnQ0NFQkRBSUxJQUZCQVdvaEFTQUxJQWtnQ2lnQ0VCRUdBRVVOQUFzZ0FVRi9haUVCQ3lBQklBaEpJUUVNQVFzZ0FDZ0NCQ0VHSUFCQk1EWUNCQ0FBTFFBZ0lReEJBU0VCSUFCQkFUb0FJQ0FBSUFjZ0FpQURFRThOQUVFQUlRRWdDU0FJYXlJS0lRTUNRQUpBQWtCQkFTQUFMUUFnSWdrZ0NVRURSaHRCQTNFT0F3SUFBUUlMUVFBaEF5QUtJUUVNQVFzZ0NrRUJkaUVCSUFwQkFXcEJBWFloQXdzZ0FVRUJhaUVCSUFCQkhHb29BZ0FoQ2lBQUtBSUVJUWtnQUNnQ0dDRUxBa0FEUUNBQlFYOXFJZ0ZGRFFFZ0N5QUpJQW9vQWhBUkJnQkZEUUFMUVFFUEMwRUJJUUVnQ1VHQWdNUUFSZzBBSUFBb0FoZ2dCQ0FGSUFBb0Fod29BZ3dSQ1FBTkFDQUFLQUljSVFFZ0FDZ0NHQ0VMUVFBaENnSkFBMEFnQXlBS1JnMEJJQXBCQVdvaENpQUxJQWtnQVNnQ0VCRUdBRVVOQUF0QkFTRUJJQXBCZjJvZ0Ewa05BUXNnQUNBTU9nQWdJQUFnQmpZQ0JFRUFEd3NnQVF1N0J3TUxmd0Y5Qkh3Z0EwRVFhaWdDQUNBRFFSUnFLQUlBSWdacVFRRnFJUWNnQmtFRWFpRURBa0FDUUNBR0tBSUFRWUNCZ29SNGNTSUlRWUNCZ29SNFJnMEFJQWhCZ0lHQ2hIaHpJUWdNQVFzRFFBSkFJQU1nQjBrTkFFUUFBQUFBQUFEd1B3OExJQVpCY0dvaEJpQURLQUlBSVFnZ0EwRUVhaUlKSVFNZ0NFR0FnWUtFZUhFaUNFR0FnWUtFZUVZTkFBc2dDRUdBZ1lLRWVITWhDQ0FKSVFNTEFrQUNRQUpBQWtBZ0FpQUZUdzBBSUFZZ0NHaEJBM1pCZjNOQkFuUnFLQUlBSWdrZ0JVOE5BaUFCSUFDaElSSWdDRUYvYWlBSWNTRUtJQVFnQWtFTWJHb2lBaWdDQ0NJSVJRMEJJQWhCZjJvaEN5QUNLQUlBSVF3Z0FpZ0NCQ0VOSUFoQmZuRWhEaUFJUVFGeElROUVBQUFBQUFBQUFBQWhFd0pBQTBBZ0RTQUVJQWxCREd4cUlnSW9BZ1FpQ0NBTklBZ2dEVWtiSWdrZ0N5QUpJQXRKR3lJSlJnMEJBa0FDUUFKQUlBZ2dDVVlOQUNBQ0tBSUFJUkJCQUNFQ1JBQUFBQUFBQUFBQUlSUUNRQ0FMUlEwQUlCQWhDQ0FNSVFrRFFDQVVJQWtxQWdBZ0NDb0NBSk1pRVNBUmxMdWdJQWxCQkdvcUFnQWdDRUVFYWlvQ0FKTWlFU0FSbEx1Z0lSUWdDRUVJYWlFSUlBbEJDR29oQ1NBT0lBSkJBbW9pQWtjTkFBc0xBa0FnRDBVTkFDQVVJQXdnQWtFQ2RDSUlhaW9DQUNBUUlBaHFLZ0lBa3lJUklCR1V1NkFoRkF0RUFBQUFBQUFBOEQ4aEZRSkFJQlNmSWhRZ0FHVU5BRVFBQUFBQUFBQUFBQ0VWSUJRZ0FXUU5BQ0FCSUJTaElCS2pJUlVMSUJNZ0ZhQWhFeUFLRFFFRFFDQURJQWRQRFFrZ0JrRndhaUVHSUFNb0FnQWhDQ0FEUVFScUlna2hBeUFJUVlDQmdvUjRjU0lJUVlDQmdvUjRSZzBBQ3lBSVFZQ0Jnb1I0Y3lJS1FYOXFJQXB4SVFnZ0NTRUREQUlMSUFnZ0NFSEFnY0FBRUVjQUN5QUdSUTBHSUFwQmYyb2dDbkVoQ0FzZ0NtZ2hDU0FJSVFvZ0JpQUpRUU4yUVg5elFRSjBhaWdDQUNJSklBVkpEUUFNQkFzTElBMGdEVUd3Z2NBQUVFY0FDeUFDSUFWQjVJREFBQkJIQUF0RUFBQUFBQUFBQUFBaEUwUUFBQUFBQUFEd1AwUUFBQUFBQUFBQUFDQUFSQUFBQUFBQUFBQUFaaUlJR3lJQUlBQWdBU0FTb3lBQlJBQUFBQUFBQUFBQVl4c2dDQnNoQUFOQUlCTWdBS0FoRXdKQUFrQWdDa1VOQUNBS0lRZ01BUXNEUUNBRElBZFBEUVFnQmtGd2FpRUdJQU1vQWdBaENDQURRUVJxSWdraEF5QUlRWUNCZ29SNGNTSUlRWUNCZ29SNFJnMEFDeUFJUVlDQmdvUjRjeUVJSUFraEF3c2dDRUYvYWlBSWNTRUtJQVlnQ0doQkEzWkJmM05CQW5ScUtBSUFJZ2tnQlVrTkFBc0xJQWtnQlVIMGdNQUFFRWNBQ3lBVFJBQUFBQUFBQVBBL29BdUNCd0VHZndKQUFrQUNRQUpBSUFKQkNVa05BQ0FESUFJUUl5SUNEUUZCQUE4TFFRQWhBa0VBRUpFQklRRWdBU0FCUVFnUWEwRVVRUWdRYTJwQkVFRUlFR3RxYTBINC8zdHFRWGR4UVgxcUlnRkJBRUVRUVFnUWEwRUNkR3NpQkNBRUlBRkxHeUFEVFEwQlFSQWdBMEVFYWtFUVFRZ1FhMEY3YWlBRFN4dEJDQkJySVFRZ0FCQ1NBU0VCSUFFZ0FSQ0hBU0lGRUk4QklRWUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRVFldzBBSUFVZ0JFOE5BU0FHUVFBb0FxeVBRRVlOQWlBR1FRQW9BcWlQUUVZTkF5QUdFSFVOQnlBR0VJY0JJZ2NnQldvaUJTQUVTUTBISUFVZ0JHc2hDQ0FIUVlBQ1NRMEVJQVlRTEF3RkN5QUJFSWNCSVFVZ0JFR0FBa2tOQmdKQUlBVWdCRUVFYWtrTkFDQUZJQVJyUVlHQUNFa05CZ3RCa0l6QUFDQUJJQUVvQWdBaUJtc2dCU0FHYWtFUWFpSUhJQVJCSDJwQmtJekFBQkNrQVJCcklnVkJBUkNmQVNJRVJRMEdJQVFnQm1vaUFTQUZJQVpySWdOQmNHb2lBallDQkJDZEFTRUFJQUVnQWhDUEFTQUFOZ0lFSUFFZ0EwRjBhaENQQVVFQU5nSUVRUUJCQUNnQ3NJOUFJQVVnQjJ0cUlnTTJBckNQUUVFQVFRQW9Bc3lQUUNJQ0lBUWdCQ0FDU3hzMkFzeVBRRUVBUVFBb0FyU1BRQ0lDSUFNZ0FpQURTeHMyQXJTUFFBd0pDeUFGSUFScklnVkJFRUVJRUd0SkRRUWdBU0FFRUk4QklRWWdBU0FFRUZnZ0JpQUZFRmdnQmlBRkVCb01CQXRCQUNnQ3BJOUFJQVZxSWdVZ0JFME5CQ0FCSUFRUWp3RWhCaUFCSUFRUVdDQUdJQVVnQkdzaUJFRUJjallDQkVFQUlBUTJBcVNQUUVFQUlBWTJBcXlQUUF3REMwRUFLQUtnajBBZ0JXb2lCU0FFU1EwREFrQUNRQ0FGSUFScklnWkJFRUVJRUd0UERRQWdBU0FGRUZoQkFDRUdRUUFoQlF3QkN5QUJJQVFRandFaUJTQUdFSThCSVFjZ0FTQUVFRmdnQlNBR0VHY2dCeEIyQzBFQUlBVTJBcWlQUUVFQUlBWTJBcUNQUUF3Q0N3SkFJQVpCREdvb0FnQWlDU0FHUVFocUtBSUFJZ1pHRFFBZ0JpQUpOZ0lNSUFrZ0JqWUNDQXdCQzBFQVFRQW9BcENNUUVGK0lBZEJBM1ozY1RZQ2tJeEFDd0pBSUFoQkVFRUlFR3RKRFFBZ0FTQUVFSThCSVFVZ0FTQUVFRmdnQlNBSUVGZ2dCU0FJRUJvTUFRc2dBU0FGRUZnTElBRU5Bd3NnQXhBRUlnUkZEUUVnQkNBQUlBTWdBUkNIQVVGNFFYd2dBUkI3RzJvaUFpQUNJQU5MR3hBNklRTWdBQkFQSUFNUEN5QUNJQUFnQXlBQklBRWdBMHNiRURvYUlBQVFEd3NnQWc4TElBRVFleG9nQVJDUkFRdXJCZ0lLZndaK0l3QkJ3QUJySWdJa0FDQUFRUWhxS1FNQUlRd2dBQ2tEQUNFTklBSkJPR29pQTBJQU53TUFJQUpCS0dvaUJDQU1RdlBLMGN1bmpObXk5QUNGTndNQUlBSkJJR29pQlNBTVF1M2VrZk9Xek55MzVBQ0ZOd01BSUFKQkdHb2lCaUFOUXVIa2xmUFc3Tm04N0FDRk53TUFJQUpDQURjRE1DQUNJQTFDOWNyTmc5ZXMyN2Z6QUlVM0F4QWdBaUFNTndNSUlBSWdEVGNEQUNBQklBSVFGVUVBSVFjQ1FBSkFBa0FnQXpVQ0FFSTRoaUFDS1FNd2hDSU1JQVFwQXdDRklnMUNFSWtnRFNBR0tRTUFmQ0lOaFNJT0lBVXBBd0FpRHlBQ0tRTVFmQ0lRUWlDSmZDSVJJQXlGSUEwZ0QwSU5pU0FRaFNJTWZDSU5JQXhDRVltRklneDhJZzhnREVJTmlZVWlEQ0FPUWhXSklCR0ZJZzRnRFVJZ2lVTC9BWVY4SWcxOEloQWdERUlSaVlVaURFSU5pU0FNSUE1Q0VJa2dEWVVpRFNBUFFpQ0pmQ0lPZkNJTWhTSVBRaEdKSUE4Z0RVSVZpU0FPaFNJTklCQkNJSWw4SWc1OElnK0ZJaEJDRFlrZ0VDQU5RaENKSUE2RklnMGdERUlnaVh3aURIeUZJZzRnRFVJVmlTQU1oU0lNSUE5Q0lJbDhJZzE4SWc4Z0RFSVFpU0FOaFVJVmlZVWdEa0lSaVlVZ0QwSWdpWVVpREtjaUEwRVpka0dCZ29RSWJDSUlJQUJCRkdvb0FnQWlCaUFBUVJCcUlna29BZ0FpQ2lBRGNTSUVhaWdBQUNJRGN5SUZRWDl6SUFWQi8vMzdkMnB4UVlDQmdvUjRjU0lGRFFCQkFDRUhBMEFnQXlBRFFRRjBjVUdBZ1lLRWVIRU5BaUFFSUFkcUlRTWdCMEVFYWlFSElBWWdDaUFEUVFScWNTSUVhaWdBQUNJRElBaHpJZ1ZCZjNNZ0JVSC8vZnQzYW5GQmdJR0NoSGh4SWdWRkRRQUxDMEVCSVFzZ0JpQUZhRUVEZGlBRWFpQUtjVUYvYzBFQ2RHb29BZ0FnQVVZTkFTQUZRWDlxSUFWeElRc0RRQUpBQWtBZ0MwVU5BQ0FMSVFVTUFRc0RRQ0FESUFOQkFYUnhRWUNCZ29SNGNRMERJQVFnQjJvaEF5QUhRUVJxSVFjZ0JpQUtJQU5CQkdweElnUnFLQUFBSWdNZ0NITWlCVUYvY3lBRlFmLzkrM2RxY1VHQWdZS0VlSEVpQlVVTkFBc0xJQVZCZjJvZ0JYRWhDeUFHSUFWb1FRTjJJQVJxSUFweFFYOXpRUUowYWlnQ0FDQUJSdzBBQzBFQklRc01BUXNnQ1NBTUlBRWdBQkFpR2tFQUlRc0xJQUpCd0FCcUpBQWdDd3VVQmdJR2Z3RjhJd0JCRUdzaUF5UUFBa0FDUUNBQ1FReHNJZ1FOQUVFQUlRVU1BUXNnQkVGMGFpSUNRUXh1UVFGcUlnWkJBM0VoQndKQUFrQWdBa0VrVHcwQVFRQWhCU0FCSVFJTUFRdEJBQ0VGUVFBZ0JrSDgvLy8vQTNGcklRWWdBU0VDQTBBZ0JTQUNRUWhxS0FJQVFRRjBhaUFDUVJScUtBSUFRUUYwYWlBQ1FTQnFLQUlBUVFGMGFpQUNRU3hxS0FJQVFRRjBha0VFYWlFRklBSkJNR29oQWlBR1FRUnFJZ1lOQUFzTElBZEZEUUJCQUNBSGF5RUdJQUpCQ0dvaEFnTkFJQVVnQWlnQ0FFRUJkR3BCQVdvaEJTQUdRUUZxSWdjZ0JrOGhDQ0FISVFZZ0FrRU1haUVDSUFnTkFBc0xBa0FDUUFKQUFrQWdCU0FGYWlJQ0lBVkpEUUFnQWtFQVNBMEFJQUlOQVVFQ0lRWU1BZ3NRZndBTElBSkJBaEJ4SWdaRkRRRUxRUUFoQnlBRFFRQTJBZ2dnQXlBR05nSUFJQU1nQWtFQmRpSUZOZ0lFQWtBZ0FTQUVhaUlFSUFGR0RRQkJBQ0VDQTBBZ0FVRUlhaUlHS0FJQUlRY0NRQ0FDSUFWSERRQWdBeUFGUVFFUU5TQURLQUlJSVFJTElBRkJER29oQ0NBREtBSUFJQUpCQVhScUlBYzdBUUFnQXlBREtBSUlRUUZxSWdJMkFnZ0NRQ0FHS0FJQVFRUjBJZ1ZGRFFBZ0FTZ0NBQ0VCQTBBZ0FVRU1haTBBQUVFT2RDQUJRUWhxTHdFQWNpRUdBa0FnQXlnQ0JDQUNSdzBBSUFNZ0FrRUJFRFVnQXlnQ0NDRUNDeUFES0FJQUlBSkJBWFJxSUFZN0FRQWdBeUFES0FJSVFRRnFJZ0kyQWdnZ0FTc0RBRVFBQUFBQTRQL3ZRS0lpQ1VRQUFBQUFBQUFBQUdZaEJnSkFBa0FnQ1VRQUFBQUFBQUR3UVdNZ0NVUUFBQUFBQUFBQUFHWnhSUTBBSUFtcklRY01BUXRCQUNFSEMwSC8vd01nQjBFQUlBWWJJQWxFQUFBQUFPRC83MEJrR3lFR0FrQWdBeWdDQkNBQ1J3MEFJQU1nQWtFQkVEVWdBeWdDQ0NFQ0N5QUJRUkJxSVFFZ0F5Z0NBQ0FDUVFGMGFpQUdPd0VBSUFNZ0F5Z0NDRUVCYWlJQ05nSUlJQVZCY0dvaUJRMEFDd3NDUUNBSUlBUkdEUUFnQXlnQ0JDRUZJQWdoQVF3QkN3c2dBa0VCZENFSElBTW9BZ1FoQlNBREtBSUFJUVlMSUFBZ0J6WUNDQ0FBSUFZMkFnQWdBQ0FGUVFGME5nSUVJQU5CRUdva0FBOExJQUpCQWhDTEFRQUw2d1FDQlg4R2ZpTUFJUUlnQVNBQktBSTRRUVJxTmdJNElBSkJFR3NpQXlBQU5nSU1Ba0FDUUFKQUFrQUNRQ0FCS0FJOElnUU5BRUVBSVFJTUFRc2dBRUVBUVFnZ0JHc2lBa0VFSUFKQkJFa2JJZ1ZCQTBzaUJodXRJUWNDUUFKQUlBWkJBblFpQmtFQmNpQUZTUTBBSUFZaEFBd0JDeUFHUVFKeUlRQWdBMEVNYWlBR2FqTUJBQ0FHUVFOMHJZWWdCNFFoQndzQ1FDQUFJQVZQRFFBZ0EwRU1haUFBYWpFQUFDQUFRUU4wcllZZ0I0UWhCd3NnQVNBQktRTXdJQWNnQkVFRGRFRTRjYTJHaENJSE53TXdJQUpCQkVzTkFTQUJRU0JxSWdBZ0FVRVlhaUlFS1FNQUlBRkJLR29pQlNrREFDQUhoU0lJZkNJSklBQXBBd0FpQ2tJTmlTQUtJQUVwQXhCOElncUZJZ3Q4SWd3Z0MwSVJpWVUzQXdBZ0JDQU1RaUNKTndNQUlBVWdDU0FJUWhDSmhTSUlRaFdKSUFnZ0NrSWdpWHdpQ0lVM0F3QWdBU0FJSUFlRk53TVFDeUFDSVFRQ1FDQUNRUVFnQW1zaUFFRjRjVThOQUNBQklBTkJER29nQW1vcEFBQWlCeUFCS1FNb2hTSUlJQUVwQXhoOElna2dBU2tERUNBQktRTWdJZ3A4SWdzZ0NrSU5pWVVpQ253aURDQUtRaEdKaFRjRElDQUJJQXhDSUlrM0F4Z2dBU0FJUWhDSklBbUZJZ2hDRllrZ0NDQUxRaUNKZkNJSWhUY0RLQ0FCSUFnZ0I0VTNBeEFnQWtFSWFpRUVDeUFDUlEwQlFnQWhCMEVBSVFJTUFnc2dBU0FFUVFScU5nSThEd3NnQTBFTWFpQUVhalVBQUNFSFFRUWhBZ3NDUUNBQ1FRRnlJQUJQRFFBZ0EwRU1haUFDSUFScWFqTUFBQ0FDUVFOMHJZWWdCNFFoQnlBQ1FRSnlJUUlMQWtBZ0FpQUFUdzBBSUFOQkRHb2dBaUFFYW1veEFBQWdBa0VEZEsyR0lBZUVJUWNMSUFFZ0J6Y0RNQ0FCSUFBMkFqd0xqd1VCQ244akFFRXdheUlESkFBZ0EwRWthaUFCTmdJQUlBTkJBem9BS0NBRFFvQ0FnSUNBQkRjRENDQURJQUEyQWlCQkFDRUVJQU5CQURZQ0dDQURRUUEyQWhBQ1FBSkFBa0FDUUNBQ0tBSUlJZ1VOQUNBQ1FSUnFLQUlBSWdaRkRRRWdBaWdDQUNFQklBSW9BaEFoQUNBR1FRTjBRWGhxUVFOMlFRRnFJZ1FoQmdOQUFrQWdBVUVFYWlnQ0FDSUhSUTBBSUFNb0FpQWdBU2dDQUNBSElBTW9BaVFvQWd3UkNRQU5CQXNnQUNnQ0FDQURRUWhxSUFCQkJHb29BZ0FSQmdBTkF5QUFRUWhxSVFBZ0FVRUlhaUVCSUFaQmYyb2lCZzBBREFJTEN5QUNRUXhxS0FJQUlnQkZEUUFnQUVFRmRDSUlRV0JxUVFWMlFRRnFJUVFnQWlnQ0FDRUJRUUFoQmdOQUFrQWdBVUVFYWlnQ0FDSUFSUTBBSUFNb0FpQWdBU2dDQUNBQUlBTW9BaVFvQWd3UkNRQU5Bd3NnQXlBRklBWnFJZ0JCSEdvdEFBQTZBQ2dnQXlBQVFRUnFLUUlBUWlDSk53TUlJQUJCR0dvb0FnQWhDU0FDS0FJUUlRcEJBQ0VMUVFBaEJ3SkFBa0FDUUNBQVFSUnFLQUlBRGdNQkFBSUJDeUFKUVFOMElReEJBQ0VISUFvZ0RHb2lEQ2dDQkVFVlJ3MEJJQXdvQWdBb0FnQWhDUXRCQVNFSEN5QURJQWsyQWhRZ0F5QUhOZ0lRSUFCQkVHb29BZ0FoQndKQUFrQUNRQ0FBUVF4cUtBSUFEZ01CQUFJQkN5QUhRUU4wSVFrZ0NpQUphaUlKS0FJRVFSVkhEUUVnQ1NnQ0FDZ0NBQ0VIQzBFQklRc0xJQU1nQnpZQ0hDQURJQXMyQWhnZ0NpQUFLQUlBUVFOMGFpSUFLQUlBSUFOQkNHb2dBQ2dDQkJFR0FBMENJQUZCQ0dvaEFTQUlJQVpCSUdvaUJrY05BQXNMUVFBaEFDQUVJQUlvQWdSSklnRkZEUUVnQXlnQ0lDQUNLQUlBSUFSQkEzUnFRUUFnQVJzaUFTZ0NBQ0FCS0FJRUlBTW9BaVFvQWd3UkNRQkZEUUVMUVFFaEFBc2dBMEV3YWlRQUlBQUxpd1VEQjM4QmZRUjhJQU5CRUdvb0FnQWdBMEVVYWlnQ0FDSUdha0VCYWlFSElBWkJCR29oQXdKQUFrQWdCaWdDQUVHQWdZS0VlSEVpQ0VHQWdZS0VlRVlOQUNBSVFZQ0Jnb1I0Y3lFSURBRUxBMEFDUUNBRElBZEpEUUJFQUFBQUFBQUE4RDhQQ3lBR1FYQnFJUVlnQXlnQ0FDRUlJQU5CQkdvaUNTRURJQWhCZ0lHQ2hIaHhJZ2hCZ0lHQ2hIaEdEUUFMSUFoQmdJR0NoSGh6SVFnZ0NTRURDd0pBQWtBQ1FDQUNJQVZQRFFBQ1FBSkFJQVlnQ0doQkEzWkJmM05CQW5ScUtBSUFJZ29nQlU4TkFDQUJJQUNoSVE0Z0NFRi9haUFJY1NFSklBUWdBa0VEZEdvaUNDZ0NBQ0VDSUFnb0FnUWhDMFFBQUFBQUFBQUFBQ0VQQTBBZ0N5QUVJQXBCQTNScUlnd29BZ1FpQ0NBTElBZ2dDMGtiSWdwQkJDQUtRUVJKR3lJS1JnMEVJQWdnQ2tZTkJVUUFBQUFBQUFEd1B5RVFBa0FnQWlvQ0FDQU1LQUlBSWdncUFnQ1RJZzBnRFpTN1JBQUFBQUFBQUFBQW9DQUNLZ0lFSUFncUFnU1RJZzBnRFpTN29DQUNLZ0lJSUFncUFnaVRJZzBnRFpTN29DQUNLZ0lNSUFncUFneVRJZzBnRFpTN29DQUNLZ0lRSUFncUFoQ1RJZzBnRFpTN29KOGlFU0FBWlEwQVJBQUFBQUFBQUFBQUlSQWdFU0FCWkEwQUlBRWdFYUVnRHFNaEVBc2dEeUFRb0NFUEFrQUNRQ0FKUlEwQUlBa2hDQXdCQ3dOQUlBTWdCMDhOQkNBR1FYQnFJUVlnQXlnQ0FDRUlJQU5CQkdvaUNTRURJQWhCZ0lHQ2hIaHhJZ2hCZ0lHQ2hIaEdEUUFMSUFoQmdJR0NoSGh6SVFnZ0NTRURDeUFJUVg5cUlBaHhJUWtnQmlBSWFFRURka0YvYzBFQ2RHb29BZ0FpQ2lBRlNRMEFDd3NnQ2lBRlFmU0F3QUFRUndBTElBOUVBQUFBQUFBQThEK2dEd3NnQWlBRlFlU0F3QUFRUndBTElBc2dDMEdRZ2NBQUVFY0FDeUFJSUFoQm9JSEFBQkJIQUF2NUJBTUhmd0Y5Qkh3Z0EwRVFhaWdDQUNBRFFSUnFLQUlBSWdacVFRRnFJUWNnQmtFRWFpRURBa0FDUUNBR0tBSUFRWUNCZ29SNGNTSUlRWUNCZ29SNFJnMEFJQWhCZ0lHQ2hIaHpJUWdNQVFzRFFBSkFJQU1nQjBrTkFFUUFBQUFBQUFEd1B3OExJQVpCY0dvaEJpQURLQUlBSVFnZ0EwRUVhaUlKSVFNZ0NFR0FnWUtFZUhFaUNFR0FnWUtFZUVZTkFBc2dDRUdBZ1lLRWVITWhDQ0FKSVFNTEFrQUNRQUpBSUFJZ0JVOE5BQUpBQWtBZ0JpQUlhRUVEZGtGL2MwRUNkR29vQWdBaUNpQUZUdzBBSUFFZ0FLRWhEaUFJUVg5cUlBaHhJUWtnQkNBQ1FRTjBhaUlJS0FJQUlRSWdDQ2dDQkNFTFJBQUFBQUFBQUFBQUlROERRQ0FMSUFRZ0NrRURkR29pRENnQ0JDSUlJQXNnQ0NBTFNSc2lDa0VESUFwQkEwa2JJZ3BHRFFRZ0NDQUtSZzBGUkFBQUFBQUFBUEEvSVJBQ1FDQUNLZ0lBSUF3b0FnQWlDQ29DQUpNaURTQU5sTHRFQUFBQUFBQUFBQUNnSUFJcUFnUWdDQ29DQkpNaURTQU5sTHVnSUFJcUFnZ2dDQ29DQ0pNaURTQU5sTHVnSUFJcUFnd2dDQ29DREpNaURTQU5sTHVnbnlJUklBQmxEUUJFQUFBQUFBQUFBQUFoRUNBUklBRmtEUUFnQVNBUm9TQU9veUVRQ3lBUElCQ2dJUThDUUFKQUlBbEZEUUFnQ1NFSURBRUxBMEFnQXlBSFR3MEVJQVpCY0dvaEJpQURLQUlBSVFnZ0EwRUVhaUlKSVFNZ0NFR0FnWUtFZUhFaUNFR0FnWUtFZUVZTkFBc2dDRUdBZ1lLRWVITWhDQ0FKSVFNTElBaEJmMm9nQ0hFaENTQUdJQWhvUVFOMlFYOXpRUUowYWlnQ0FDSUtJQVZKRFFBTEN5QUtJQVZCOUlEQUFCQkhBQXNnRDBRQUFBQUFBQUR3UDZBUEN5QUNJQVZCNUlEQUFCQkhBQXNnQ3lBTFFaQ0J3QUFRUndBTElBZ2dDRUdnZ2NBQUVFY0FDK2NFQXdkL0FYMEVmQ0FEUVJCcUtBSUFJQU5CRkdvb0FnQWlCbXBCQVdvaEJ5QUdRUVJxSVFNQ1FBSkFJQVlvQWdCQmdJR0NoSGh4SWdoQmdJR0NoSGhHRFFBZ0NFR0FnWUtFZUhNaENBd0JDd05BQWtBZ0F5QUhTUTBBUkFBQUFBQUFBUEEvRHdzZ0JrRndhaUVHSUFNb0FnQWhDQ0FEUVFScUlna2hBeUFJUVlDQmdvUjRjU0lJUVlDQmdvUjRSZzBBQ3lBSVFZQ0Jnb1I0Y3lFSUlBa2hBd3NDUUFKQUFrQWdBaUFGVHcwQUFrQUNRQ0FHSUFob1FRTjJRWDl6UVFKMGFpZ0NBQ0lLSUFWUERRQWdBU0FBb1NFT0lBaEJmMm9nQ0hFaENTQUVJQUpCQTNScUlnZ29BZ0FoQ3lBSUtBSUVJUUpFQUFBQUFBQUFBQUFoRHdOQUlBSWdCQ0FLUVFOMGFpSU1LQUlFSWdnZ0FpQUlJQUpKR3lJS1FRSWdDa0VDU1JzaUNrWU5CQ0FJSUFwR0RRVkVBQUFBQUFBQThEOGhFQUpBSUFzcUFnQWdEQ2dDQUNJSUtnSUFreUlOSUEyVXUwUUFBQUFBQUFBQUFLQWdDeW9DQkNBSUtnSUVreUlOSUEyVXU2QWdDeW9DQ0NBSUtnSUlreUlOSUEyVXU2Q2ZJaEVnQUdVTkFFUUFBQUFBQUFBQUFDRVFJQkVnQVdRTkFDQUJJQkdoSUE2aklSQUxJQThnRUtBaER3SkFBa0FnQ1VVTkFDQUpJUWdNQVFzRFFDQURJQWRQRFFRZ0JrRndhaUVHSUFNb0FnQWhDQ0FEUVFScUlna2hBeUFJUVlDQmdvUjRjU0lJUVlDQmdvUjRSZzBBQ3lBSVFZQ0Jnb1I0Y3lFSUlBa2hBd3NnQ0VGL2FpQUljU0VKSUFZZ0NHaEJBM1pCZjNOQkFuUnFLQUlBSWdvZ0JVa05BQXNMSUFvZ0JVSDBnTUFBRUVjQUN5QVBSQUFBQUFBQUFQQS9vQThMSUFJZ0JVSGtnTUFBRUVjQUN5QUNJQUpCa0lIQUFCQkhBQXNnQ0NBSVFhQ0J3QUFRUndBTDhRUUJCSDhnQUNBQkVJOEJJUUlDUUFKQUFrQWdBQkNJQVEwQUlBQW9BZ0FoQXdKQUFrQWdBQkI3RFFBZ0F5QUJhaUVCSUFBZ0F4Q1FBU0lBUVFBb0FxaVBRRWNOQVNBQ0tBSUVRUU54UVFOSERRSkJBQ0FCTmdLZ2owQWdBQ0FCSUFJUVlBOExRWkNNd0FBZ0FDQURheUFESUFGcVFSQnFJZ0FRb1FGRkRRSkJBRUVBS0FLd2owQWdBR3MyQXJDUFFBOExBa0FnQTBHQUFra05BQ0FBRUN3TUFRc0NRQ0FBUVF4cUtBSUFJZ1FnQUVFSWFpZ0NBQ0lGUmcwQUlBVWdCRFlDRENBRUlBVTJBZ2dNQVF0QkFFRUFLQUtRakVCQmZpQURRUU4yZDNFMkFwQ01RQXNDUUNBQ0VIVkZEUUFnQUNBQklBSVFZQXdDQ3dKQUFrQWdBa0VBS0FLc2owQkdEUUFnQWtFQUtBS29qMEJIRFFGQkFDQUFOZ0tvajBCQkFFRUFLQUtnajBBZ0FXb2lBVFlDb0k5QUlBQWdBUkJuRHd0QkFDQUFOZ0tzajBCQkFFRUFLQUtrajBBZ0FXb2lBVFlDcEk5QUlBQWdBVUVCY2pZQ0JDQUFRUUFvQXFpUFFFY05BVUVBUVFBMkFxQ1BRRUVBUVFBMkFxaVBRQThMSUFJUWh3RWlBeUFCYWlFQkFrQUNRQ0FEUVlBQ1NRMEFJQUlRTEF3QkN3SkFJQUpCREdvb0FnQWlCQ0FDUVFocUtBSUFJZ0pHRFFBZ0FpQUVOZ0lNSUFRZ0FqWUNDQXdCQzBFQVFRQW9BcENNUUVGK0lBTkJBM1ozY1RZQ2tJeEFDeUFBSUFFUVp5QUFRUUFvQXFpUFFFY05BVUVBSUFFMkFxQ1BRQXNQQ3dKQUlBRkJnQUpKRFFBZ0FDQUJFQ3NQQ3lBQlFRTjJJZ0pCQTNSQm1JekFBR29oQVFKQUFrQkJBQ2dDa0l4QUlnTkJBU0FDZENJQ2NVVU5BQ0FCS0FJSUlRSU1BUXRCQUNBRElBSnlOZ0tRakVBZ0FTRUNDeUFCSUFBMkFnZ2dBaUFBTmdJTUlBQWdBVFlDRENBQUlBSTJBZ2dMbXdRQkNYOGpBRUVnYXlJQ0pBQWdBVUVVYWlnQ0FDRURJQUVvQWdBaEJBSkFBa0FnQVVFRWFpZ0NBQ0lGUVFOMElnWU5BRUVBSVFjTUFRc2dCa0Y0YWlJR1FRTjJRUUZxSWdoQkIzRWhDUUpBQWtBZ0JrRTRUdzBBUVFBaEJ5QUVJUWdNQVFzZ0JFRThhaUVHUVFBaEIwRUFJQWhCK1AvLy93TnhheUVJQTBBZ0JpZ0NBQ0FHUVhocUtBSUFJQVpCY0dvb0FnQWdCa0ZvYWlnQ0FDQUdRV0JxS0FJQUlBWkJXR29vQWdBZ0JrRlFhaWdDQUNBR1FVaHFLQUlBSUFkcWFtcHFhbXBxYWlFSElBWkJ3QUJxSVFZZ0NFRUlhaUlJRFFBTElBWkJSR29oQ0FzZ0NVVU5BRUVBSUFscklRWWdDRUVFYWlFSUEwQWdDQ2dDQUNBSGFpRUhJQVpCQVdvaUNTQUdUeUVLSUFraEJpQUlRUWhxSVFnZ0NnMEFDd3NDUUFKQUFrQUNRQ0FERFFBZ0J5RUdEQUVMQWtBZ0JVVU5BQ0FFS0FJRURRQWdCMEVRU1EwQ0N5QUhJQWRxSWdZZ0Iwa05BUXRCQUNFSEFrQUNRQ0FHUVFCSURRQUNRQ0FHRFFCQkFTRUlEQVFMSUFaQkFSQnhJZ2hGRFFFZ0JpRUhEQU1MRUg4QUN5QUdRUUVRaXdFQUMwRUJJUWhCQUNFSEN5QUFRUUEyQWdnZ0FDQUhOZ0lFSUFBZ0NEWUNBQ0FDSUFBMkFnUWdBa0VJYWtFUWFpQUJRUkJxS1FJQU53TUFJQUpCQ0dwQkNHb2dBVUVJYWlrQ0FEY0RBQ0FDSUFFcEFnQTNBd2dDUUNBQ1FRUnFRY3lHd0FBZ0FrRUlhaEFXUlEwQVFmU0d3QUJCTXlBQ1FRaHFRZVNHd0FCQndJZkFBQkJHQUFzZ0FrRWdhaVFBQzg0RUF3ZC9BWDBFZkNBRFFSQnFLQUlBSUFOQkZHb29BZ0FpQm1wQkFXb2hCeUFHUVFScUlRTUNRQUpBSUFZb0FnQkJnSUdDaEhoeElnaEJnSUdDaEhoR0RRQWdDRUdBZ1lLRWVITWhDQXdCQ3dOQUFrQWdBeUFIU1EwQVJBQUFBQUFBQVBBL0R3c2dCa0Z3YWlFR0lBTW9BZ0FoQ0NBRFFRUnFJZ2toQXlBSVFZQ0Jnb1I0Y1NJSVFZQ0Jnb1I0UmcwQUN5QUlRWUNCZ29SNGN5RUlJQWtoQXdzQ1FBSkFBa0FnQWlBRlR3MEFBa0FDUUNBR0lBaG9RUU4yUVg5elFRSjBhaWdDQUNJS0lBVlBEUUFnQVNBQW9TRU9JQWhCZjJvZ0NIRWhDU0FFSUFKQkEzUnFJZ2dvQWdBaEN5QUlLQUlFSVFKRUFBQUFBQUFBQUFBaER3TkFJQUlnQkNBS1FRTjBhaUlNS0FJRUlnZ2dBaUFJSUFKSkcwRUFSeUlLUmcwRUlBZ2dDa1lOQlVRQUFBQUFBQUR3UHlFUUFrQWdDeW9DQUNBTUtBSUFJZ2dxQWdDVElnMGdEWlM3UkFBQUFBQUFBQUFBb0NBTEtnSUVJQWdxQWdTVElnMGdEWlM3b0o4aUVTQUFaUTBBUkFBQUFBQUFBQUFBSVJBZ0VTQUJaQTBBSUFFZ0VhRWdEcU1oRUFzZ0R5QVFvQ0VQQWtBQ1FDQUpSUTBBSUFraENBd0JDd05BSUFNZ0IwOE5CQ0FHUVhCcUlRWWdBeWdDQUNFSUlBTkJCR29pQ1NFRElBaEJnSUdDaEhoeElnaEJnSUdDaEhoR0RRQUxJQWhCZ0lHQ2hIaHpJUWdnQ1NFREN5QUlRWDlxSUFoeElRa2dCaUFJYUVFRGRrRi9jMEVDZEdvb0FnQWlDaUFGU1EwQUN3c2dDaUFGUWZTQXdBQVFSd0FMSUE5RUFBQUFBQUFBOEQrZ0R3c2dBaUFGUWVTQXdBQVFSd0FMSUFJZ0FrR1FnY0FBRUVjQUN5QUlJQWhCb0lIQUFCQkhBQXVqQkFNRmZ3RjlCSHdnQTBFUWFpZ0NBQ0FEUVJScUtBSUFJZ1pxUVFGcUlRY2dCa0VFYWlFREFrQUNRQ0FHS0FJQVFZQ0Jnb1I0Y1NJSVFZQ0Jnb1I0UmcwQUlBaEJnSUdDaEhoeklRZ01BUXNEUUFKQUlBTWdCMGtOQUVRQUFBQUFBQUR3UHc4TElBWkJjR29oQmlBREtBSUFJUWdnQTBFRWFpSUpJUU1nQ0VHQWdZS0VlSEVpQ0VHQWdZS0VlRVlOQUFzZ0NFR0FnWUtFZUhNaENDQUpJUU1MQWtBQ1FDQUNJQVZQRFFBQ1FBSkFBa0FnQmlBSWFFRURka0YvYzBFQ2RHb29BZ0FpQ2lBRlR3MEFJQVFnQWtFRGRHb2lBaWdDQkVVTkJDQUJJQUNoSVF3Z0NFRi9haUFJY1NFSklBSW9BZ0FoQWtRQUFBQUFBQUFBQUNFTkEwQWdCQ0FLUVFOMGFpSUlLQUlFUlEwRFJBQUFBQUFBQVBBL0lRNENRQ0FDS2dJQUlBZ29BZ0FxQWdDVElnc2dDNVM3UkFBQUFBQUFBQUFBb0o4aUR5QUFaUTBBUkFBQUFBQUFBQUFBSVE0Z0R5QUJaQTBBSUFFZ0Q2RWdES01oRGdzZ0RTQU9vQ0VOQWtBQ1FDQUpSUTBBSUFraENBd0JDd05BSUFNZ0IwOE5CQ0FHUVhCcUlRWWdBeWdDQUNFSUlBTkJCR29pQ1NFRElBaEJnSUdDaEhoeElnaEJnSUdDaEhoR0RRQUxJQWhCZ0lHQ2hIaHpJUWdnQ1NFREN5QUlRWDlxSUFoeElRa2dCaUFJYUVFRGRrRi9jMEVDZEdvb0FnQWlDaUFGU1EwQUN3c2dDaUFGUWZTQXdBQVFSd0FMSUExRUFBQUFBQUFBOEQrZ0R3dEJBRUVBUWFDQndBQVFSd0FMSUFJZ0JVSGtnTUFBRUVjQUMwRUFRUUJCa0lIQUFCQkhBQXZWQXdJRmZ3WitJd0JCMEFCcklnTWtBQ0FEUWNnQWFpSUVRZ0EzQXdBZ0EwRTRhaUlGSUFGQkNHb3BBd0FpQ0VMenl0SExwNHpac3ZRQWhUY0RBQ0FEUVRCcUlnWWdDRUx0M3BIemxzemN0K1FBaFRjREFDQURRU2hxSWdjZ0FTa0RBQ0lKUXVIa2xmUFc3Tm04N0FDRk53TUFJQU5DQURjRFFDQURJQWczQXhnZ0F5QUpOd01RSUFNZ0NVTDF5czJEMTZ6YnQvTUFoVGNESUNBQ0tBSUFJQU5CRUdvUUZTQURRUWhxSUFGQkVHb2dCRFVDQUVJNGhpQURLUU5BaENJSUlBVXBBd0NGSWdsQ0VJa2dDU0FIS1FNQWZDSUpoU0lLSUFZcEF3QWlDeUFES1FNZ2ZDSU1RaUNKZkNJTklBaUZJQWtnQzBJTmlTQU1oU0lJZkNJSklBaENFWW1GSWdoOElnc2dDRUlOaVlVaUNDQUtRaFdKSUEyRklnb2dDVUlnaVVML0FZVjhJZ2w4SWd3Z0NFSVJpWVVpQ0VJTmlTQUlJQXBDRUlrZ0NZVWlDU0FMUWlDSmZDSUtmQ0lJaFNJTFFoR0pJQXNnQ1VJVmlTQUtoU0lKSUF4Q0lJbDhJZ3A4SWd1RklneENEWWtnRENBSlFoQ0pJQXFGSWdrZ0NFSWdpWHdpQ0h5Rklnb2dDVUlWaVNBSWhTSUlJQXRDSUlsOElnbDhJZ3NnQ0VJUWlTQUpoVUlWaVlVZ0NrSVJpWVVnQzBJZ2lZVWdBaEFrSUFBZ0F5Z0NDRFlDQUNBQUlBTW9BZ3cyQWdRZ0EwSFFBR29rQUF2SkF3TU5md0Y5QVh3Q1FBSkFBa0FnQUNnQ0FDSUNJQUFvQWdRaUEwWU5BQ0FBUVJocUtBSUFJUVFnQUVFVWFpZ0NBQ0VGSUFCQkVHb29BZ0FoQmlBQUtBSU1JUWNnQUNnQ0NDRUlBMEFDUUNBSEtBSUFJZ0FnQ0VZTkFDQUFJQVZQRFFNQ1FBSkFJQUlvQWdnaUNRMEFSQUFBQUFBQUFBQUFJUkFNQVFzZ0FpZ0NCQ0lLSUFZZ0FFRU1iR29pQ3lnQ0JDSUFJQW9nQUNBS1NSc2lEQ0FKUVg5cUlnMGdEQ0FOU1JzaURFWU5CUUpBQWtBQ1FDQUFJQXhHRFFBZ0N5Z0NBQ0VNSUFJb0FnQWhDeUFKUVFGeElRNGdEUTBCUVFBaENrUUFBQUFBQUFBQUFDRVFEQUlMSUFBZ0FFSEFnY0FBRUVjQUN5QUpRWDV4SVExQkFDRUtSQUFBQUFBQUFBQUFJUkFnRENFQUlBc2hDUU5BSUJBZ0NTb0NBQ0FBS2dJQWt5SVBJQStVdTZBZ0NVRUVhaW9DQUNBQVFRUnFLZ0lBa3lJUElBK1V1NkFoRUNBQVFRaHFJUUFnQ1VFSWFpRUpJQTBnQ2tFQ2FpSUtSdzBBQ3dzZ0RrVU5BQ0FRSUFzZ0NrRUNkQ0lBYWlvQ0FDQU1JQUJxS2dJQWt5SVBJQStVdTZBaEVBc2dFSjhnQkNzRENHVkZEUUFnQVNBSUVCTWFDeUFJUVFGcUlRZ2dBa0VNYWlJQ0lBTkhEUUFMQ3c4TElBQWdCVUg0Z3NBQUVFY0FDeUFLSUFwQnNJSEFBQkJIQUF2VEF3SUZmd1I4SUFOQkVHb29BZ0FnQTBFVWFpZ0NBQ0lHYWtFQmFpRUhJQVpCQkdvaEF3SkFBa0FnQmlnQ0FFR0FnWUtFZUhFaUNFR0FnWUtFZUVZTkFDQUlRWUNCZ29SNGN5RUlEQUVMQTBBQ1FDQURJQWRKRFFCRUFBQUFBQUFBOEQ4UEN5QUdRWEJxSVFZZ0F5Z0NBQ0VJSUFOQkJHb2lDU0VESUFoQmdJR0NoSGh4SWdoQmdJR0NoSGhHRFFBTElBaEJnSUdDaEhoeklRZ2dDU0VEQ3dKQUlBSWdCVThOQUFKQUFrQWdCaUFJYUVFRGRrRi9jMEVDZEdvb0FnQWlDaUFGVHcwQUlBRWdBS0VoQ3lBRUlBSkJBM1JxSVFJZ0NFRi9haUFJY1NFSlJBQUFBQUFBQUFBQUlRd0RRRVFBQUFBQUFBRHdQeUVOQWtBZ0FpQUVJQXBCQTNScUVEUWlEaUFBWlEwQVJBQUFBQUFBQUFBQUlRMGdEaUFCWkEwQUlBRWdEcUVnQzZNaERRc2dEQ0FOb0NFTUFrQUNRQ0FKUlEwQUlBa2hDQXdCQ3dOQUlBTWdCMDhOQkNBR1FYQnFJUVlnQXlnQ0FDRUlJQU5CQkdvaUNTRURJQWhCZ0lHQ2hIaHhJZ2hCZ0lHQ2hIaEdEUUFMSUFoQmdJR0NoSGh6SVFnZ0NTRURDeUFJUVg5cUlBaHhJUWtnQmlBSWFFRURka0YvYzBFQ2RHb29BZ0FpQ2lBRlNRMEFDd3NnQ2lBRlFmU0F3QUFRUndBTElBeEVBQUFBQUFBQThEK2dEd3NnQWlBRlFlU0F3QUFRUndBTDB3TUNCWDhFZkNBRFFSQnFLQUlBSUFOQkZHb29BZ0FpQm1wQkFXb2hCeUFHUVFScUlRTUNRQUpBSUFZb0FnQkJnSUdDaEhoeElnaEJnSUdDaEhoR0RRQWdDRUdBZ1lLRWVITWhDQXdCQ3dOQUFrQWdBeUFIU1EwQVJBQUFBQUFBQVBBL0R3c2dCa0Z3YWlFR0lBTW9BZ0FoQ0NBRFFRUnFJZ2toQXlBSVFZQ0Jnb1I0Y1NJSVFZQ0Jnb1I0UmcwQUN5QUlRWUNCZ29SNGN5RUlJQWtoQXdzQ1FDQUNJQVZQRFFBQ1FBSkFJQVlnQ0doQkEzWkJmM05CQW5ScUtBSUFJZ29nQlU4TkFDQUJJQUNoSVFzZ0JDQUNRUU4wYWlFQ0lBaEJmMm9nQ0hFaENVUUFBQUFBQUFBQUFDRU1BMEJFQUFBQUFBQUE4RDhoRFFKQUlBSWdCQ0FLUVFOMGFoQTRJZzRnQUdVTkFFUUFBQUFBQUFBQUFDRU5JQTRnQVdRTkFDQUJJQTZoSUF1aklRMExJQXdnRGFBaERBSkFBa0FnQ1VVTkFDQUpJUWdNQVFzRFFDQURJQWRQRFFRZ0JrRndhaUVHSUFNb0FnQWhDQ0FEUVFScUlna2hBeUFJUVlDQmdvUjRjU0lJUVlDQmdvUjRSZzBBQ3lBSVFZQ0Jnb1I0Y3lFSUlBa2hBd3NnQ0VGL2FpQUljU0VKSUFZZ0NHaEJBM1pCZjNOQkFuUnFLQUlBSWdvZ0JVa05BQXNMSUFvZ0JVSDBnTUFBRUVjQUN5QU1SQUFBQUFBQUFQQS9vQThMSUFJZ0JVSGtnTUFBRUVjQUM1WURBUWQvSXdCQkVHc2lCQ1FBQWtBZ0FFRUVhaWdDQUNJRklBQW9BZ0FpQmlBQnB5SUhjU0lJYWlnQUFFR0FnWUtFZUhFaUNRMEFRUVFoQ2dOQUlBZ2dDbW9oQ0NBS1FRUnFJUW9nQlNBSUlBWnhJZ2hxS0FBQVFZQ0Jnb1I0Y1NJSlJRMEFDd3NDUUNBRklBbG9RUU4ySUFocUlBWnhJZ3BxTEFBQUlnaEJmMHdOQUNBRklBVW9BZ0JCZ0lHQ2hIaHhhRUVEZGlJS2FpMEFBQ0VJQ3lBSVFRRnhJUWdDUUNBQUtBSUlEUUFnQ0VVTkFDQUVJQUJCQVNBREVBMENRQ0FBUVFScUtBSUFJZ1VnQUNnQ0FDSUdJQWR4SWdscUtBQUFRWUNCZ29SNGNTSUREUUJCQkNFS0EwQWdDU0FLYWlFSklBcEJCR29oQ2lBRklBa2dCbkVpQ1dvb0FBQkJnSUdDaEhoeElnTkZEUUFMQ3lBRklBTm9RUU4ySUFscUlBWnhJZ3BxTEFBQVFYOU1EUUFnQlNnQ0FFR0FnWUtFZUhGb1FRTjJJUW9MSUFVZ0Ntb2dCMEVaZGlJSk9nQUFJQXBCZkdvZ0JuRWdCV3BCQkdvZ0NUb0FBQ0FBSUFBb0FnZ2dDR3MyQWdnZ0FDQUFLQUlNUVFGcU5nSU1JQVVnQ2tFQ2RHc2lDa0Y4YWlBQ05nSUFJQVJCRUdva0FDQUtDNGNEQVFOL0FrQUNRQUpBQWtBQ1FDQUJRUWxKRFFCQkVFRUlFR3NnQVVzTkFRd0NDeUFBRUFRaEFnd0NDMEVRUVFnUWF5RUJDMEVBSVFKQkFCQ1JBU0VESUFNZ0EwRUlFR3RCRkVFSUVHdHFRUkJCQ0JCcmFtdEIrUDk3YWtGM2NVRjlhaUlEUVFCQkVFRUlFR3RCQW5ScklnUWdCQ0FEU3hzZ0FXc2dBRTBOQUNBQlFSQWdBRUVFYWtFUVFRZ1FhMEY3YWlBQVN4dEJDQkJySWdScVFSQkJDQkJyYWtGOGFoQUVJZ05GRFFBZ0F4Q1NBU0VBQWtBQ1FDQUJRWDlxSWdJZ0EzRU5BQ0FBSVFFTUFRc2dBaUFEYWtFQUlBRnJjUkNTQVNFQ1FSQkJDQkJySVFNZ0FCQ0hBU0FDUVFBZ0FTQUNJQUJySUFOTEcyb2lBU0FBYXlJQ2F5RURBa0FnQUJCN0RRQWdBU0FERUZnZ0FDQUNFRmdnQUNBQ0VCb01BUXNnQUNnQ0FDRUFJQUVnQXpZQ0JDQUJJQUFnQW1vMkFnQUxJQUVRZXcwQklBRVFod0VpQUVFUVFRZ1FheUFFYWswTkFTQUJJQVFRandFaEFpQUJJQVFRV0NBQ0lBQWdCR3NpQUJCWUlBSWdBQkFhREFFTElBSVBDeUFCRUpFQklRQWdBUkI3R2lBQUM0OERBUWwvSUFGQkJHb29BZ0FpQkNBQktBSUFJZ1VnQXFjaUJuRWlCMm9vQUFBaUNDQUdRUmwyUVlHQ2hBaHNJZ2x6SWdaQmYzTWdCa0gvL2Z0M2FuRkJnSUdDaEhoeElRb2dBeWdDQUNFTFFRQWhBd0pBQTBBQ1FBSkFJQXBGRFFBZ0NpRUdEQUVMQTBBQ1FDQUlJQWhCQVhSeFFZQ0Jnb1I0Y1VVTkFFRUFJUWdNQkFzZ0J5QURhaUVJSUFOQkJHb2hBeUFFSUFoQkJHb2dCWEVpQjJvb0FBQWlDQ0FKY3lJR1FYOXpJQVpCLy8zN2QycHhRWUNCZ29SNGNTSUdSUTBBQ3dzZ0JrRi9haUFHY1NFS0lBc2dCQ0FHYUVFRGRpQUhhaUFGY1VFQ2RHc2lCa0Y4YWlJTUtBSUFSdzBBQzBFQklRaEJnQUVoQXdKQUlBUWdCQ0FHYTBFQ2RTSUhhaUlHS0FBQUlna2dDVUVCZEhGQmdJR0NoSGh4YUVFRGRpQUVJQWRCZkdvZ0JYRnFJZ2NvQUFBaUJDQUVRUUYwY1VHQWdZS0VlSEZuUVFOMmFrRURTdzBBSUFFZ0FTZ0NDRUVCYWpZQ0NFSC9BU0VEQ3lBR0lBTTZBQUFnQjBFRWFpQURPZ0FBSUFFZ0FTZ0NERUYvYWpZQ0RDQU1LQUlBSVFNTElBQWdBellDQkNBQUlBZzJBZ0FMOUFJQkJIOENRQUpBSUFBZ0FXc2dBazhOQUNBQ1FYOXFJUU1DUUNBQ1FRTnhJZ1JGRFFBZ0FVRi9haUVGSUFCQmYyb2hCZ05BSUFZZ0Ftb2dCU0FDYWkwQUFEb0FBQ0FDUVg5cUlRSWdCRUYvYWlJRURRQUxDeUFEUVFOSkRRRWdBVUY4YWlFR0lBQkJmR29oQVFOQUlBRWdBbW9pQkVFRGFpQUdJQUpxSWdWQkEyb3RBQUE2QUFBZ0JFRUNhaUFGUVFKcUxRQUFPZ0FBSUFSQkFXb2dCVUVCYWkwQUFEb0FBQ0FFSUFVdEFBQTZBQUFnQWtGOGFpSUNEUUFNQWdzTElBSkZEUUFnQWtFRGNTRUdRUUFoQkFKQUlBSkJmMnBCQTBrTkFDQUNRWHh4SVFOQkFDRUVBMEFnQUNBRWFpSUNJQUVnQkdvaUJTMEFBRG9BQUNBQ1FRRnFJQVZCQVdvdEFBQTZBQUFnQWtFQ2FpQUZRUUpxTFFBQU9nQUFJQUpCQTJvZ0JVRURhaTBBQURvQUFDQURJQVJCQkdvaUJFY05BQXNMSUFaRkRRQWdBU0FFYWlFQ0lBQWdCR29oQkFOQUlBUWdBaTBBQURvQUFDQUNRUUZxSVFJZ0JFRUJhaUVFSUFaQmYyb2lCZzBBQ3dzZ0FBdm9BZ0VEZnlNQVFSQnJJZ0lrQUNBQUtBSUFJUUFDUUFKQUlBRkIvd0JMRFFBQ1FDQUFLQUlJSWdNZ0FFRUVhaWdDQUVjTkFDQUFJQU5CQVJBOElBQW9BZ2doQXdzZ0FDQURRUUZxTmdJSUlBQW9BZ0FnQTJvZ0FUb0FBQXdCQ3lBQ1FRQTJBZ3dDUUFKQUlBRkJnQkJKRFFBQ1FDQUJRWUNBQkVrTkFDQUNJQUZCUDNGQmdBRnlPZ0FQSUFJZ0FVRVNka0h3QVhJNkFBd2dBaUFCUVFaMlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQlAzRkJnQUZ5T2dBTlFRUWhBUXdDQ3lBQ0lBRkJQM0ZCZ0FGeU9nQU9JQUlnQVVFTWRrSGdBWEk2QUF3Z0FpQUJRUVoyUVQ5eFFZQUJjam9BRFVFRElRRU1BUXNnQWlBQlFUOXhRWUFCY2pvQURTQUNJQUZCQm5aQndBRnlPZ0FNUVFJaEFRc0NRQ0FBUVFScUtBSUFJQUJCQ0dvaUJDZ0NBQ0lEYXlBQlR3MEFJQUFnQXlBQkVEd2dCQ2dDQUNFREN5QUFLQUlBSUFOcUlBSkJER29nQVJBNkdpQUVJQU1nQVdvMkFnQUxJQUpCRUdva0FFRUFDOThDQVFOL0l3QkJFR3NpQWlRQUFrQUNRQ0FCUWY4QVN3MEFBa0FnQUNnQ0NDSURJQUJCQkdvb0FnQkhEUUFnQUNBRFFRRVFQU0FBS0FJSUlRTUxJQUFnQTBFQmFqWUNDQ0FBS0FJQUlBTnFJQUU2QUFBTUFRc2dBa0VBTmdJTUFrQUNRQ0FCUVlBUVNRMEFBa0FnQVVHQWdBUlBEUUFnQWlBQlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQjRBRnlPZ0FNSUFJZ0FVRUdka0UvY1VHQUFYSTZBQTFCQXlFQkRBSUxJQUlnQVVFL2NVR0FBWEk2QUE4Z0FpQUJRUkoyUWZBQmNqb0FEQ0FDSUFGQkJuWkJQM0ZCZ0FGeU9nQU9JQUlnQVVFTWRrRS9jVUdBQVhJNkFBMUJCQ0VCREFFTElBSWdBVUUvY1VHQUFYSTZBQTBnQWlBQlFRWjJRY0FCY2pvQURFRUNJUUVMQWtBZ0FFRUVhaWdDQUNBQVFRaHFJZ1FvQWdBaUEyc2dBVThOQUNBQUlBTWdBUkE5SUFRb0FnQWhBd3NnQUNnQ0FDQURhaUFDUVF4cUlBRVFPaG9nQkNBRElBRnFOZ0lBQ3lBQ1FSQnFKQUFMMVFJQ0NuOEJmUUpBQWtBQ1FBSkFJQUFvQWdBaUFpQUFLQUlFSWdOR0RRQWdBRUVZYWlnQ0FDRUVJQUJCRkdvb0FnQWhCU0FBUVJCcUtBSUFJUVlnQUNnQ0RDRUhJQUFvQWdnaEFBTkFBa0FnQUNBSEtBSUFJZ2hHRFFBZ0NDQUZUdzBESUFKQkJHb29BZ0FpQ1NBR0lBaEJBM1JxSWdvb0FnUWlDQ0FKSUFnZ0NVa2JJZ3RCQkNBTFFRUkpHeUlMUmcwRUlBZ2dDMFlOQlNBQ0tBSUFJZ2dxQWdBZ0NpZ0NBQ0lKS2dJQWt5SU1JQXlVdTBRQUFBQUFBQUFBQUtBZ0NDb0NCQ0FKS2dJRWt5SU1JQXlVdTZBZ0NDb0NDQ0FKS2dJSWt5SU1JQXlVdTZBZ0NDb0NEQ0FKS2dJTWt5SU1JQXlVdTZBZ0NDb0NFQ0FKS2dJUWt5SU1JQXlVdTZDZklBUXJBd2hsUlEwQUlBRWdBQkFUR2dzZ0FFRUJhaUVBSUFKQkNHb2lBaUFEUncwQUN3c1BDeUFJSUFWQitJTEFBQkJIQUFzZ0NTQUpRWkNCd0FBUVJ3QUxJQWdnQ0VHZ2djQUFFRWNBQzlJQ0FnVi9BWDRqQUVFd2F5SURKQUJCSnlFRUFrQUNRQ0FBUXBET0FGb05BQ0FBSVFnTUFRdEJKeUVFQTBBZ0EwRUphaUFFYWlJRlFYeHFJQUFnQUVLUXpnQ0FJZ2hDa000QWZuMm5JZ1pCLy84RGNVSGtBRzRpQjBFQmRFSDRpTUFBYWk4QUFEc0FBQ0FGUVg1cUlBWWdCMEhrQUd4clFmLy9BM0ZCQVhSQitJakFBR292QUFBN0FBQWdCRUY4YWlFRUlBQkMvOEhYTDFZaEJTQUlJUUFnQlEwQUN3c0NRQ0FJcHlJRlFlTUFUQTBBSUFOQkNXb2dCRUYrYWlJRWFpQUlweUlGSUFWQi8vOERjVUhrQUc0aUJVSGtBR3hyUWYvL0EzRkJBWFJCK0lqQUFHb3ZBQUE3QUFBTEFrQUNRQ0FGUVFwSURRQWdBMEVKYWlBRVFYNXFJZ1JxSUFWQkFYUkIrSWpBQUdvdkFBQTdBQUFNQVFzZ0EwRUphaUFFUVg5cUlnUnFJQVZCTUdvNkFBQUxJQUlnQVVHUWlNQUFRUUFnQTBFSmFpQUVha0VuSUFSckVCQWhCQ0FEUVRCcUpBQWdCQXZEQWdJS2Z3RjlBa0FDUUFKQUFrQWdBQ2dDQUNJQ0lBQW9BZ1FpQTBZTkFDQUFRUmhxS0FJQUlRUWdBRUVVYWlnQ0FDRUZJQUJCRUdvb0FnQWhCaUFBS0FJTUlRY2dBQ2dDQ0NFQUEwQUNRQ0FBSUFjb0FnQWlDRVlOQUNBSUlBVlBEUU1nQWtFRWFpZ0NBQ0lKSUFZZ0NFRURkR29pQ2lnQ0JDSUlJQWtnQ0NBSlNSc2lDMEVESUF0QkEwa2JJZ3RHRFFRZ0NDQUxSZzBGSUFJb0FnQWlDQ29DQUNBS0tBSUFJZ2txQWdDVElnd2dESlM3UkFBQUFBQUFBQUFBb0NBSUtnSUVJQWtxQWdTVElnd2dESlM3b0NBSUtnSUlJQWtxQWdpVElnd2dESlM3b0NBSUtnSU1JQWtxQWd5VElnd2dESlM3b0o4Z0JDc0RDR1ZGRFFBZ0FTQUFFQk1hQ3lBQVFRRnFJUUFnQWtFSWFpSUNJQU5IRFFBTEN3OExJQWdnQlVINGdzQUFFRWNBQ3lBSklBbEJrSUhBQUJCSEFBc2dDQ0FJUWFDQndBQVFSd0FMd2dJQkJYOUJBQ0VDQWtBZ0FVR0FBa2tOQUVFZklRSWdBVUgvLy84SFN3MEFJQUZCQmlBQlFRaDJaeUlDYTNaQkFYRWdBa0VCZEd0QlBtb2hBZ3NnQUVJQU53SVFJQUFnQWpZQ0hDQUNRUUowUWFDT3dBQnFJUU1nQUJDZUFTRUVBa0FDUUFKQUFrQUNRRUVBS0FLVWpFQWlCVUVCSUFKMElnWnhSUTBBSUFNb0FnQWhCU0FDRUdZaEFpQUZFSjRCRUljQklBRkhEUUVnQlNFQ0RBSUxRUUFnQlNBR2NqWUNsSXhBSUFNZ0FEWUNBQ0FBSUFNMkFoZ01Bd3NnQVNBQ2RDRURBMEFnQlNBRFFSMTJRUVJ4YWtFUWFpSUdLQUlBSWdKRkRRSWdBMEVCZENFRElBSWhCU0FDRUo0QkVJY0JJQUZIRFFBTEN5QUNFSjRCSWdJb0FnZ2lBeUFFTmdJTUlBSWdCRFlDQ0NBRUlBSTJBZ3dnQkNBRE5nSUlJQUJCQURZQ0dBOExJQVlnQURZQ0FDQUFJQVUyQWhnTElBUWdCRFlDQ0NBRUlBUTJBZ3dMd3dJQkJYOGdBQ2dDR0NFQkFrQUNRQUpBSUFBUWxRRWdBRWNOQUNBQVFSUkJFQ0FBUVJScUlnSW9BZ0FpQXh0cUtBSUFJZ1FOQVVFQUlRTU1BZ3NnQUJDV0FTSUVJQUFRbFFFaUF4Q2VBVFlDRENBRElBUVFuZ0UyQWdnTUFRc2dBaUFBUVJCcUlBTWJJUUlEUUNBQ0lRVUNRQ0FFSWdOQkZHb2lBaWdDQUNJRURRQWdBMEVRYWlFQ0lBTW9BaEFoQkFzZ0JBMEFDeUFGUVFBMkFnQUxBa0FnQVVVTkFBSkFBa0FnQUNnQ0hFRUNkRUdnanNBQWFpSUVLQUlBSUFCR0RRQWdBVUVRUVJRZ0FTZ0NFQ0FBUmh0cUlBTTJBZ0FnQXcwQkRBSUxJQVFnQXpZQ0FDQUREUUJCQUVFQUtBS1VqRUJCZmlBQUtBSWNkM0UyQXBTTVFBOExJQU1nQVRZQ0dBSkFJQUFvQWhBaUJFVU5BQ0FESUFRMkFoQWdCQ0FETmdJWUN5QUFRUlJxS0FJQUlnUkZEUUFnQTBFVWFpQUVOZ0lBSUFRZ0F6WUNHQThMQzdFQ0FncC9BWDBDUUFKQUFrQUNRQ0FBS0FJQUlnSWdBQ2dDQkNJRFJnMEFJQUJCR0dvb0FnQWhCQ0FBUVJScUtBSUFJUVVnQUVFUWFpZ0NBQ0VHSUFBb0Fnd2hCeUFBS0FJSUlRQURRQUpBSUFBZ0J5Z0NBQ0lJUmcwQUlBZ2dCVThOQXlBQ1FRUnFLQUlBSWdrZ0JpQUlRUU4wYWlJS0tBSUVJZ2dnQ1NBSUlBbEpHeUlMUVFJZ0MwRUNTUnNpQzBZTkJDQUlJQXRHRFFVZ0FpZ0NBQ0lJS2dJQUlBb29BZ0FpQ1NvQ0FKTWlEQ0FNbEx0RUFBQUFBQUFBQUFDZ0lBZ3FBZ1FnQ1NvQ0JKTWlEQ0FNbEx1Z0lBZ3FBZ2dnQ1NvQ0NKTWlEQ0FNbEx1Z255QUVLd01JWlVVTkFDQUJJQUFRRXhvTElBQkJBV29oQUNBQ1FRaHFJZ0lnQTBjTkFBc0xEd3NnQ0NBRlFmaUN3QUFRUndBTElBa2dDVUdRZ2NBQUVFY0FDeUFJSUFoQm9JSEFBQkJIQUF2SEFnRU5md0pBUVFBb0FzQ1BRQ0lBRFFCQkFFSC9IellDMEk5QVFRQVBDMEc0ajhBQUlRRkJBQ0VDUVFBaEF3TkFJQUFpQkNnQ0NDRUFJQVFvQWdRaEJTQUVLQUlBSVFZQ1FBSkFRWkNNd0FBZ0JFRU1haWdDQUVFQmRoQ2lBVVVOQUNBRUVJa0JEUUFnQmlBR0VKRUJJZ2RCQ0JCcklBZHJhaUlIRUljQklRaEJBQkNSQVNJSlFRZ1FheUVLUVJSQkNCQnJJUXRCRUVFSUVHc2hEQ0FIRUhjTkFDQUhJQWhxSUFZZ0JTQUphaUFLSUF0cUlBeHFhMnBKRFFBQ1FBSkFRUUFvQXFpUFFDQUhSZzBBSUFjUUxBd0JDMEVBUVFBMkFxQ1BRRUVBUVFBMkFxaVBRQXNDUUVHUWpNQUFJQVlnQlJDaEFRMEFJQWNnQ0JBckRBRUxRUUJCQUNnQ3NJOUFJQVZyTmdLd2owQWdBU0FBTmdJSUlBVWdBbW9oQWd3QkN5QUVJUUVMSUFOQkFXb2hBeUFBRFFBTFFRQWdBMEgvSHlBRFFmOGZTeHMyQXRDUFFDQUNDN1lDQWdSL0FYNGpBRUV3YXlJQ0pBQWdBVUVFYWlFREFrQUNRQ0FCS0FJRVJRMEFRUUFvQXNDRVFDRUVEQUVMSUFFb0FnQWhCU0FDUWdBM0Fnd2dBa0VBS0FMQWhFQWlCRFlDQ0NBQ0lBSkJDR28yQWhRZ0FrRVlha0VRYWlBRlFSQnFLUUlBTndNQUlBSkJHR3BCQ0dvZ0JVRUlhaWtDQURjREFDQUNJQVVwQWdBM0F4Z2dBa0VVYWtIOGc4QUFJQUpCR0dvUUZob2dBMEVJYWlBQ1FRaHFRUWhxS0FJQU5nSUFJQU1nQWlrRENEY0NBQXNnQWtFWWFrRUlhaUlGSUFOQkNHb29BZ0EyQWdBZ0FVRU1ha0VBTmdJQUlBTXBBZ0FoQmlBQlFRaHFRUUEyQWdBZ0FTQUVOZ0lFSUFJZ0JqY0RHQUpBUVF4QkJCQnhJZ0VOQUVFTVFRUVFpd0VBQ3lBQklBSXBBeGczQWdBZ0FVRUlhaUFGS0FJQU5nSUFJQUJCcklYQUFEWUNCQ0FBSUFFMkFnQWdBa0V3YWlRQUM1Z0NBZ3AvQVgwQ1FBSkFBa0FDUUNBQUtBSUFJZ0lnQUNnQ0JDSURSZzBBSUFCQkdHb29BZ0FoQkNBQVFSUnFLQUlBSVFVZ0FFRVFhaWdDQUNFR0lBQW9BZ3doQnlBQUtBSUlJUUFEUUFKQUlBQWdCeWdDQUNJSVJnMEFJQWdnQlU4TkF5QUNRUVJxS0FJQUlna2dCaUFJUVFOMGFpSUtLQUlFSWdnZ0NTQUlJQWxKRzBFQVJ5SUxSZzBFSUFnZ0MwWU5CU0FDS0FJQUlnZ3FBZ0FnQ2lnQ0FDSUpLZ0lBa3lJTUlBeVV1MFFBQUFBQUFBQUFBS0FnQ0NvQ0JDQUpLZ0lFa3lJTUlBeVV1NkNmSUFRckF3aGxSUTBBSUFFZ0FCQVRHZ3NnQUVFQmFpRUFJQUpCQ0dvaUFpQURSdzBBQ3dzUEN5QUlJQVZCK0lMQUFCQkhBQXNnQ1NBSlFaQ0J3QUFRUndBTElBZ2dDRUdnZ2NBQUVFY0FDK1FCQWdKL0FYNGpBRUVnYXlJREpBQUNRQ0FCSUFKcUlnSWdBVWtOQUNBQVFRUnFLQUlBSWdGQkFYUWlCQ0FDSUFRZ0Frc2JJZ0pCQkNBQ1FRUkxHNjFDREg0aUJVSWdpS2RGUVFKMElRSWdCYWNoQkFKQUFrQWdBVVVOQUNBRFFSaHFRUVEyQWdBZ0F5QUJRUXhzTmdJVUlBTWdBQ2dDQURZQ0VBd0JDeUFEUVFBMkFoQUxJQU1nQkNBQ0lBTkJFR29RUHdKQUlBTW9BZ0JCQVVjTkFDQURRUWhxS0FJQUlnQkZEUUVnQXlnQ0JDQUFFSXNCQUFzZ0F5Z0NCQ0VCSUFCQkJHb2dBMEVJYWlnQ0FFRU1iallDQUNBQUlBRTJBZ0FnQTBFZ2FpUUFEd3NRZndBTDZBRUJBbjhqQUVFZ2F5SURKQUFDUUNBQklBSnFJZ0lnQVVrTkFDQUFRUVJxS0FJQUlnUkJBWFFpQVNBQ0lBRWdBa3NiSWdGQkJDQUJRUVJMR3lJQlFmLy8vLzhBY1NBQlJrRURkQ0VDSUFGQkJIUWhBUUpBQWtBZ0JFVU5BQ0FEUVJCcVFRaHFRUWcyQWdBZ0F5QUVRUVIwTmdJVUlBTWdBQ2dDQURZQ0VBd0JDeUFEUVFBMkFoQUxJQU1nQVNBQ0lBTkJFR29RUHdKQUlBTW9BZ0JCQVVjTkFDQURRUWhxS0FJQUlnQkZEUUVnQXlnQ0JDQUFFSXNCQUFzZ0F5Z0NCQ0VCSUFCQkJHb2dBMEVJYWlnQ0FFRUVkallDQUNBQUlBRTJBZ0FnQTBFZ2FpUUFEd3NRZndBTDVRRUJBbjhqQUVFZ2F5SURKQUFDUUNBQklBSnFJZ0lnQVVrTkFDQUFRUVJxS0FJQUlnUkJBWFFpQVNBQ0lBRWdBa3NiSWdGQkJDQUJRUVJMR3lJQlFmLy8vLzhCY1NBQlJrRUNkQ0VDSUFGQkEzUWhBUUpBQWtBZ0JFVU5BQ0FEUVJocVFRUTJBZ0FnQXlBRVFRTjBOZ0lVSUFNZ0FDZ0NBRFlDRUF3QkN5QURRUUEyQWhBTElBTWdBU0FDSUFOQkVHb1FQd0pBSUFNb0FnQkJBVWNOQUNBRFFRaHFLQUlBSWdCRkRRRWdBeWdDQkNBQUVJc0JBQXNnQXlnQ0JDRUJJQUJCQkdvZ0EwRUlhaWdDQUVFRGRqWUNBQ0FBSUFFMkFnQWdBMEVnYWlRQUR3c1Fmd0FMNHdFQ0EzOEJmUUpBQWtBZ0FDZ0NCQ0lDSUFFb0FnUWlBeUFDSUFNZ0Fra2JJZ1JCQmlBRVFRWkpHeUlFUmcwQUlBTWdCRVlOQVNBQUtBSUFJZ0lxQWdBZ0FTZ0NBQ0lES2dJQWt5SUZJQVdVdTBRQUFBQUFBQUFBQUtBZ0Fpb0NCQ0FES2dJRWt5SUZJQVdVdTZBZ0Fpb0NDQ0FES2dJSWt5SUZJQVdVdTZBZ0Fpb0NEQ0FES2dJTWt5SUZJQVdVdTZBZ0Fpb0NFQ0FES2dJUWt5SUZJQVdVdTZBZ0Fpb0NGQ0FES2dJVWt5SUZJQVdVdTZBZ0Fpb0NHQ0FES2dJWWt5SUZJQVdVdTZDZkR3c2dBaUFDUVpDQndBQVFSd0FMSUFNZ0EwR2dnY0FBRUVjQUM5a0JBUU4vSXdCQklHc2lBeVFBQWtBZ0FTQUNhaUlDSUFGSkRRQWdBRUVFYWlnQ0FDSUVRUUYwSWdVZ0FpQUZJQUpMR3lJQlFRUWdBVUVFU3hzaUFTQUJhaUlDSUFGUFFRRjBJUUVDUUFKQUlBUkZEUUFnQTBFWWFrRUNOZ0lBSUFNZ0JUWUNGQ0FESUFBb0FnQTJBaEFNQVFzZ0EwRUFOZ0lRQ3lBRElBSWdBU0FEUVJCcUVEOENRQ0FES0FJQVFRRkhEUUFnQTBFSWFpZ0NBQ0lBUlEwQklBTW9BZ1FnQUJDTEFRQUxJQU1vQWdRaEFTQUFRUVJxSUFOQkNHb29BZ0JCQVhZMkFnQWdBQ0FCTmdJQUlBTkJJR29rQUE4TEVIOEFDKzBCQWdkL0FYMENRQUpBQWtBQ1FDQUFLQUlBSWdJZ0FDZ0NCQ0lEUmcwQUlBQkJHR29vQWdBaEJDQUFRUlJxS0FJQUlRVWdBRUVRYWlnQ0FDRUdJQUFvQWd3aEJ5QUFLQUlJSVFBRFFBSkFJQUFnQnlnQ0FDSUlSZzBBSUFnZ0JVOE5BeUFDUVFScUtBSUFSUTBFSUFZZ0NFRURkR29pQ0NnQ0JFVU5CU0FDS0FJQUtnSUFJQWdvQWdBcUFnQ1RJZ2tnQ1pTN1JBQUFBQUFBQUFBQW9KOGdCQ3NEQ0dWRkRRQWdBU0FBRUJNYUN5QUFRUUZxSVFBZ0FrRUlhaUlDSUFOSERRQUxDdzhMSUFnZ0JVSDRnc0FBRUVjQUMwRUFRUUJCa0lIQUFCQkhBQXRCQUVFQVFhQ0J3QUFRUndBTCtBRUJBMzhqQUVFZ2F5SUVKQUJCQVNFRlFRQkJBQ2dDOEl0QUlnWkJBV28yQXZDTFFBSkFBa0JCQUNnQzJJOUFRUUZIRFFCQkFDZ0MzSTlBUVFGcUlRVU1BUXRCQUVFQk5nTFlqMEFMUVFBZ0JUWUMzSTlBQWtBQ1FDQUdRUUJJRFFBZ0JVRUNTdzBBSUFRZ0F6WUNIQ0FFSUFJMkFoaEJBQ2dDNUl0QUlnWkJmMHdOQUVFQUlBWkJBV29pQmpZQzVJdEFBa0JCQUNnQzdJdEFJZ0pGRFFCQkFDZ0M2SXRBSVFZZ0JFRUlhaUFBSUFFb0FoQVJCUUFnQkNBRUtRTUlOd01RSUFZZ0JFRVFhaUFDS0FJVUVRVUFRUUFvQXVTTFFDRUdDMEVBSUFaQmYybzJBdVNMUUNBRlFRRk5EUUVMQUFzZ0FDQUJFRjBBQzlFQkFnTi9BWDBDUUFKQUlBQW9BZ1FpQWlBQktBSUVJZ01nQWlBRElBSkpHeUlFUVFVZ0JFRUZTUnNpQkVZTkFDQURJQVJHRFFFZ0FDZ0NBQ0lDS2dJQUlBRW9BZ0FpQXlvQ0FKTWlCU0FGbEx0RUFBQUFBQUFBQUFDZ0lBSXFBZ1FnQXlvQ0JKTWlCU0FGbEx1Z0lBSXFBZ2dnQXlvQ0NKTWlCU0FGbEx1Z0lBSXFBZ3dnQXlvQ0RKTWlCU0FGbEx1Z0lBSXFBaEFnQXlvQ0VKTWlCU0FGbEx1Z0lBSXFBaFFnQXlvQ0ZKTWlCU0FGbEx1Z253OExJQUlnQWtHUWdjQUFFRWNBQ3lBRElBTkJvSUhBQUJCSEFBdldBUUVHZndKQUFrQUNRQUpBSUFFb0FnQWlBZzBBSUFFb0Fnd2hBeUFCS0FJSUlRUURRQ0FFSUFOUERRTWdBU0FFUVFScUlnVTJBZ2dnQVNBQktBSUVRWEJxSWdZMkFnUWdBU0FFS0FJQVFZQ0Jnb1I0Y1NJSFFZQ0Jnb1I0Y3lJQ05nSUFJQVVoQkNBSFFZQ0Jnb1I0UmcwQUN5QUJJQUpCZjJvZ0FuRTJBZ0FNQVFzZ0FTQUNRWDlxSUFKeE5nSUFJQUVvQWdRaUJrVU5BUXNnQVNBQktBSVFRWDlxTmdJUUlBWWdBbWhCQTNaQmYzTkJBblJxS0FJQUlRUkJBU0VCREFFTFFRQWhBUXNnQUNBRU5nSUVJQUFnQVRZQ0FBdTdBUUVFZndKQUlBSkZEUUFnQWtFRGNTRURRUUFoQkFKQUlBSkJmMnBCQTBrTkFDQUNRWHh4SVFWQkFDRUVBMEFnQUNBRWFpSUNJQUVnQkdvaUJpMEFBRG9BQUNBQ1FRRnFJQVpCQVdvdEFBQTZBQUFnQWtFQ2FpQUdRUUpxTFFBQU9nQUFJQUpCQTJvZ0JrRURhaTBBQURvQUFDQUZJQVJCQkdvaUJFY05BQXNMSUFORkRRQWdBU0FFYWlFQ0lBQWdCR29oQkFOQUlBUWdBaTBBQURvQUFDQUNRUUZxSVFJZ0JFRUJhaUVFSUFOQmYyb2lBdzBBQ3dzZ0FBdTRBUUVEZndKQUlBSkZEUUFnQWtFSGNTRURRUUFoQkFKQUlBSkJmMnBCQjBrTkFDQUNRWGh4SVFWQkFDRUVBMEFnQUNBRWFpSUNJQUU2QUFBZ0FrRUhhaUFCT2dBQUlBSkJCbW9nQVRvQUFDQUNRUVZxSUFFNkFBQWdBa0VFYWlBQk9nQUFJQUpCQTJvZ0FUb0FBQ0FDUVFKcUlBRTZBQUFnQWtFQmFpQUJPZ0FBSUFVZ0JFRUlhaUlFUncwQUN3c2dBMFVOQUNBQUlBUnFJUUlEUUNBQ0lBRTZBQUFnQWtFQmFpRUNJQU5CZjJvaUF3MEFDd3NnQUF1NEFRRUNmeU1BUVNCcklnTWtBQUpBSUFFZ0Ftb2lBaUFCU1EwQUlBQkJCR29vQWdBaUFVRUJkQ0lFSUFJZ0JDQUNTeHNpQWtFSUlBSkJDRXNiSVFJQ1FBSkFJQUZGRFFBZ0EwRVFha0VJYWtFQk5nSUFJQU1nQVRZQ0ZDQURJQUFvQWdBMkFoQU1BUXNnQTBFQU5nSVFDeUFESUFKQkFTQURRUkJxRUVBQ1FDQURLQUlBUVFGSERRQWdBMEVJYWlnQ0FDSUFSUTBCSUFNb0FnUWdBQkNMQVFBTElBQWdBeWtDQkRjQ0FDQURRU0JxSkFBUEN4Qi9BQXU0QVFFQ2Z5TUFRU0JySWdNa0FBSkFJQUVnQW1vaUFpQUJTUTBBSUFCQkJHb29BZ0FpQVVFQmRDSUVJQUlnQkNBQ1N4c2lBa0VJSUFKQkNFc2JJUUlDUUFKQUlBRkZEUUFnQTBFUWFrRUlha0VCTmdJQUlBTWdBVFlDRkNBRElBQW9BZ0EyQWhBTUFRc2dBMEVBTmdJUUN5QURJQUpCQVNBRFFSQnFFRUVDUUNBREtBSUFRUUZIRFFBZ0EwRUlhaWdDQUNJQVJRMEJJQU1vQWdRZ0FCQ0xBUUFMSUFBZ0F5a0NCRGNDQUNBRFFTQnFKQUFQQ3hCL0FBdTVBUUVDZnlNQVFUQnJJZ0lrQUNBQlFRUnFJUU1DUUNBQktBSUVEUUFnQVNnQ0FDRUJJQUpDQURjQ0RDQUNRUUFvQXNDRVFEWUNDQ0FDSUFKQkNHbzJBaFFnQWtFWWFrRVFhaUFCUVJCcUtRSUFOd01BSUFKQkdHcEJDR29nQVVFSWFpa0NBRGNEQUNBQ0lBRXBBZ0EzQXhnZ0FrRVVha0g4ZzhBQUlBSkJHR29RRmhvZ0EwRUlhaUFDUVFocVFRaHFLQUlBTmdJQUlBTWdBaWtEQ0RjQ0FBc2dBRUdzaGNBQU5nSUVJQUFnQXpZQ0FDQUNRVEJxSkFBTHFBRUJBbjhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWtVTkFFRUJJUVFnQVVFQVNBMEJJQU1vQWdBaUJVVU5BaUFES0FJRUlnTU5CQ0FCUlEwRERBVUxJQUFnQVRZQ0JFRUJJUVFMUVFBaEFRd0dDeUFCRFFJTElBSWhBd3dDQ3lBRklBTWdBaUFCRUd3aUF3MEJEQUlMSUFFZ0FoQnhJZ05GRFFFTElBQWdBellDQkVFQUlRUU1BUXNnQUNBQk5nSUVJQUloQVFzZ0FDQUVOZ0lBSUFCQkNHb2dBVFlDQUF1b0FRRUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUlBSkZEUUJCQVNFRUlBRkJBRWdOQVNBREtBSUFJZ1ZGRFFNZ0F5Z0NCQ0lERFFJZ0FRMEVJQUloQXd3RkN5QUFJQUUyQWdSQkFTRUVDMEVBSVFFTUJBc2dCU0FESUFJZ0FSQnNJUU1NQWdzZ0FRMEFJQUloQXd3QkN5QUJJQUlRY1NFREN3SkFJQU5GRFFBZ0FDQUROZ0lFUVFBaEJBd0JDeUFBSUFFMkFnUWdBaUVCQ3lBQUlBUTJBZ0FnQUVFSWFpQUJOZ0lBQzZnQkFRSi9Ba0FDUUFKQUFrQUNRQUpBQWtBZ0FrVU5BRUVCSVFRZ0FVRUFTQTBCSUFNb0FnQWlCVVVOQXlBREtBSUVJZ01OQWlBQkRRUWdBaUVEREFVTElBQWdBVFlDQkVFQklRUUxRUUFoQVF3RUN5QUZJQU1nQWlBQkVHd2hBd3dDQ3lBQkRRQWdBaUVEREFFTElBRWdBaEJ4SVFNTEFrQWdBMFVOQUNBQUlBTTJBZ1JCQUNFRURBRUxJQUFnQVRZQ0JDQUNJUUVMSUFBZ0JEWUNBQ0FBUVFocUlBRTJBZ0FMbkFFQkIzOENRQUpBSUFBb0FnQWlBaUFBS0FJRUlnTkdEUUFnQUVFWWFpZ0NBQ0VFSUFCQkZHb29BZ0FoQlNBQVFSQnFLQUlBSVFZZ0FDZ0NEQ0VISUFBb0FnZ2hBQU5BQWtBZ0FDQUhLQUlBSWdoR0RRQWdDQ0FGVHcwRElBSWdCaUFJUVFOMGFoQTRJQVFyQXdobFJRMEFJQUVnQUJBVEdnc2dBRUVCYWlFQUlBSkJDR29pQWlBRFJ3MEFDd3NQQ3lBSUlBVkIrSUxBQUJCSEFBdWNBUUVIZndKQUFrQWdBQ2dDQUNJQ0lBQW9BZ1FpQTBZTkFDQUFRUmhxS0FJQUlRUWdBRUVVYWlnQ0FDRUZJQUJCRUdvb0FnQWhCaUFBS0FJTUlRY2dBQ2dDQ0NFQUEwQUNRQ0FBSUFjb0FnQWlDRVlOQUNBSUlBVlBEUU1nQWlBR0lBaEJBM1JxRURRZ0JDc0RDR1ZGRFFBZ0FTQUFFQk1hQ3lBQVFRRnFJUUFnQWtFSWFpSUNJQU5IRFFBTEN3OExJQWdnQlVINGdzQUFFRWNBQzVvQkFRWi9JQUVvQWdBaUFrRUJhaUVESUFGQkJHb29BZ0FpQkNnQ0FDRUZJQUVvQWd3aEFRSkFBa0FnQWcwQVFRQWhCZ3dCQ3lBRUlBTkJBblFpQjJzaEJpQUNJQWRxUVFWcUlRSUxJQUFnQmpZQ0ZDQUFJQUUyQWhBZ0FDQUVOZ0lFSUFCQkhHcEJCRFlDQUNBQVFSaHFJQUkyQWdBZ0FDQUVJQU5xTmdJTUlBQWdCRUVFYWpZQ0NDQUFJQVZCZjNOQmdJR0NoSGh4TmdJQUM1WUJBUUovSXdCQkVHc2lBeVFBSUFCQkZHb29BZ0FoQkFKQUFrQUNRQUpBSUFCQkJHb29BZ0FPQWdBQkF3c2dCQTBDUVpTRXdBQWhBRUVBSVFRTUFRc2dCQTBCSUFBb0FnQWlBQ2dDQkNFRUlBQW9BZ0FoQUFzZ0F5QUVOZ0lFSUFNZ0FEWUNBQ0FEUVppRndBQWdBUkNYQVNBQ0VEY0FDeUFEUVFBMkFnUWdBeUFBTmdJQUlBTkJoSVhBQUNBQkVKY0JJQUlRTndBTGZnRUJmeU1BUWNBQWF5SUZKQUFnQlNBQk5nSU1JQVVnQURZQ0NDQUZJQU0yQWhRZ0JTQUNOZ0lRSUFWQkxHcEJBallDQUNBRlFUeHFRUlkyQWdBZ0JVSUNOd0ljSUFWQjZJakFBRFlDR0NBRlFSYzJBalFnQlNBRlFUQnFOZ0lvSUFVZ0JVRVFhallDT0NBRklBVkJDR28yQWpBZ0JVRVlhaUFFRUZvQUMyd0JBWDhqQUVFd2F5SURKQUFnQXlBQk5nSUVJQU1nQURZQ0FDQURRUnhxUVFJMkFnQWdBMEVzYWtFVU5nSUFJQU5DQWpjQ0RDQURRZFNJd0FBMkFnZ2dBMEVVTmdJa0lBTWdBMEVnYWpZQ0dDQURJQU0yQWlnZ0F5QURRUVJxTmdJZ0lBTkJDR29nQWhCYUFBdHNBUUYvSXdCQk1Hc2lBeVFBSUFNZ0FUWUNCQ0FESUFBMkFnQWdBMEVjYWtFQ05nSUFJQU5CTEdwQkZEWUNBQ0FEUWdJM0Fnd2dBMEgwaXNBQU5nSUlJQU5CRkRZQ0pDQURJQU5CSUdvMkFoZ2dBeUFEUVFScU5nSW9JQU1nQXpZQ0lDQURRUWhxSUFJUVdnQUxiQUVCZnlNQVFUQnJJZ01rQUNBRElBRTJBZ1FnQXlBQU5nSUFJQU5CSEdwQkFqWUNBQ0FEUVN4cVFSUTJBZ0FnQTBJQ053SU1JQU5CcUl2QUFEWUNDQ0FEUVJRMkFpUWdBeUFEUVNCcU5nSVlJQU1nQTBFRWFqWUNLQ0FESUFNMkFpQWdBMEVJYWlBQ0VGb0FDMlFCQW44akFFRWdheUlDSkFBZ0FFRWNhaWdDQUNFRElBQW9BaGdoQUNBQ1FRaHFRUkJxSUFGQkVHb3BBZ0EzQXdBZ0FrRUlha0VJYWlBQlFRaHFLUUlBTndNQUlBSWdBU2tDQURjRENDQUFJQU1nQWtFSWFoQVdJUUVnQWtFZ2FpUUFJQUVMWXdFQmZ5TUFRU0JySWdJa0FDQUNJQUFvQWdBMkFnUWdBa0VJYWtFUWFpQUJRUkJxS1FJQU53TUFJQUpCQ0dwQkNHb2dBVUVJYWlrQ0FEY0RBQ0FDSUFFcEFnQTNBd2dnQWtFRWFrSDhnOEFBSUFKQkNHb1FGaUVCSUFKQklHb2tBQ0FCQzJNQkFYOGpBRUVnYXlJQ0pBQWdBaUFBS0FJQU5nSUVJQUpCQ0dwQkVHb2dBVUVRYWlrQ0FEY0RBQ0FDUVFocVFRaHFJQUZCQ0dvcEFnQTNBd0FnQWlBQktRSUFOd01JSUFKQkJHcEJ6SWJBQUNBQ1FRaHFFQlloQVNBQ1FTQnFKQUFnQVF0UUFRSi9Ba0FnQUNnQ0FDSURRUVJxS0FJQUlBTkJDR29pQkNnQ0FDSUFheUFDVHcwQUlBTWdBQ0FDRUR3Z0JDZ0NBQ0VBQ3lBREtBSUFJQUJxSUFFZ0FoQTZHaUFFSUFBZ0FtbzJBZ0JCQUF0UUFRSi9Ba0FnQUNnQ0FDSURRUVJxS0FJQUlBTkJDR29pQkNnQ0FDSUFheUFDVHcwQUlBTWdBQ0FDRUQwZ0JDZ0NBQ0VBQ3lBREtBSUFJQUJxSUFFZ0FoQTZHaUFFSUFBZ0FtbzJBZ0JCQUF0VUFRRi9Ba0FDUUFKQUlBRkJnSURFQUVZTkFFRUJJUVFnQUNnQ0dDQUJJQUJCSEdvb0FnQW9BaEFSQmdBTkFRc2dBZzBCUVFBaEJBc2dCQThMSUFBb0FoZ2dBaUFESUFCQkhHb29BZ0FvQWd3UkNRQUxSd0VCZnlNQVFTQnJJZ01rQUNBRFFSUnFRUUEyQWdBZ0EwR1FpTUFBTmdJUUlBTkNBVGNDQkNBRElBRTJBaHdnQXlBQU5nSVlJQU1nQTBFWWFqWUNBQ0FESUFJUVdnQUxSZ0VCZnlNQVFTQnJJZ0lrQUNBQ1FSeHFRUUEyQWdBZ0FrR0VnY0FBTmdJWUlBSkNBVGNDRENBQ1FkU0N3QUEyQWdnZ0FTQUNRUWhxRUVvaEFTQUNRU0JxSkFBZ0FRdEdBUUovSUFFb0FnUWhBaUFCS0FJQUlRTUNRRUVJUVFRUWNTSUJEUUJCQ0VFRUVJc0JBQXNnQVNBQ05nSUVJQUVnQXpZQ0FDQUFRYnlGd0FBMkFnUWdBQ0FCTmdJQUN6a0JBWDhnQWtFUWRrQUFJUU1nQUVFQU5nSUlJQUJCQUNBQ1FZQ0FmSEVnQTBGL1JpSUNHellDQkNBQVFRQWdBMEVRZENBQ0d6WUNBQXMrQVFGL0FrQkJLRUVJRUhFaUJBMEFRU2hCQ0JDTEFRQUxJQVFnQXprQ0lDQUVJQUk1QWhnZ0JDQUJPUUlRSUFRZ0FEa0NDQ0FFUVFBMkFnQWdCQXMrQVFOL0l3QkJFR3NpQVNRQUlBQVFtQUZCNUlUQUFCQnFJUUlnQUJDWEFSQnBJUU1nQVNBQ05nSUlJQUVnQURZQ0JDQUJJQU0yQWdBZ0FSQnVBQXN1QUFKQUlBQkJmRXNOQUFKQUlBQU5BRUVFRHdzZ0FDQUFRWDFKUVFKMEVIRWlBRVVOQUNBQUR3c1Frd0VBQ3pJQUFrQWdBQ0FCRUNNaUFVVU5BQUpBUVpDTXdBQVFvd0ZGRFFBZ0FSQ1NBUkI3RFFFTElBRkJBQ0FBRURzYUN5QUJDeW9BSUFBZ0FDZ0NCRUVCY1NBQmNrRUNjallDQkNBQklBQnFRUVJxSWdBZ0FDZ0NBRUVCY2pZQ0FBc3NBQUpBQWtBZ0FFVU5BQ0FBS0FJQURRRWdBRUVBTmdJQUlBQkJLRUVJRUhrUEN4Q0ZBUUFMRUlZQkFBczBBUUYvSXdCQkVHc2lBaVFBSUFJZ0FUWUNEQ0FDSUFBMkFnZ2dBa0dRaU1BQU5nSUVJQUpCa0lqQUFEWUNBQ0FDRUZVQUN5WUJBWDhDUUNBQVFRUnFLQUlBSWdGRkRRQWdBQ2dDQUNJQVJRMEFJQUFnQVVFQkVIa0xDeVlCQVg4Q1FDQUFLQUlFSWdGRkRRQWdBRUVJYWlnQ0FDSUFSUTBBSUFFZ0FFRUJFSGtMQ3lVQkFYOGpBRUVRYXlJQ0pBQWdBaUFCTmdJTUlBSWdBRFlDQ0NBQ1FRaHFFSndCR2dBTEpnRUNmMEVBSVFJQ1FDQUFLQUlBSWdNZ0FVc05BQ0FESUFBb0FnUnFJQUZMSVFJTElBSUxJUUFnQUNBQlFRTnlOZ0lFSUFFZ0FHcEJCR29pQUNBQUtBSUFRUUZ5TmdJQUN5TUFJQUlnQWlnQ0JFRitjVFlDQkNBQUlBRkJBWEkyQWdRZ0FDQUJhaUFCTmdJQUN5QUFBa0FnQVEwQUlBQWdBellDQkNBQUlBSTJBZ0FQQ3lBQ0lBTVFpd0VBQ3lBQUFrQWdBUTBBSUFCQkFEWUNCQThMUWN5RndBQkJIRUc0aHNBQUVGQUFDeHdCQVg4Q1FDQUFLQUlRSWdFTkFDQUFRUlJxS0FJQUlRRUxJQUVMRkFBZ0FDQUFJQUVnQUNBQll4c2dBU0FCWWhzTEdnRUJmeUFBSUFGQkFDZ0M0SXRBSWdKQkFpQUNHeEVGQUFBTEVnQkJBRUVaSUFCQkFYWnJJQUJCSDBZYkN4WUFJQUFnQVVFQmNqWUNCQ0FBSUFGcUlBRTJBZ0FMSEFBZ0FTZ0NHRUc0aThBQVFRVWdBVUVjYWlnQ0FDZ0NEQkVKQUFzYUFBSkFJQUFOQUVHVWhNQUFRU3RCOUlUQUFCQlFBQXNnQUFzWEFBSkFJQUFOQUVHVWhNQUFRU3NnQVJCUUFBc2dBQXNRQUNBQUlBRnFRWDlxUVFBZ0FXdHhDeE1CQVg4Z0FDQUJJQUlnQXhBU0lRUWdCQThMRWdBQ1FDQUJSUTBBSUFBZ0FVRUVFSGtMQ3hRQUlBQW9BZ0FnQUNnQ0JDQUFLQUlJRUVVQUN3OEFJQUJCQVhRaUFFRUFJQUJyY2dzVUFDQUFLQUlBSUFFZ0FDZ0NCQ2dDREJFR0FBc1FBUUYvSUFBZ0FSQ09BU0VDSUFJUEN3OEJBWDhnQUNBQkVGY2hBaUFDRHdzVEFDQUFRYnlGd0FBMkFnUWdBQ0FCTmdJQUN4QUFJQUJDQWpjRENDQUFRZ0UzQXdBTERRQWdBQzBBQkVFQ2NVRUJkZ3NQQUNBQUlBQW9BZ1JCZm5FMkFnUUxEUUFnQUNnQ0JFRURjVUVCUndzUUFDQUJJQUFvQWdBZ0FDZ0NCQkFPQ3d3QUlBQWdBU0FDRUpRQkR3c0tBRUVBSUFCcklBQnhDd3NBSUFBdEFBUkJBM0ZGQ3d3QUlBQWdBVUVEY2pZQ0JBc05BQ0FBS0FJQUlBQW9BZ1JxQ3cwQUlBQW9BZ0FnQVJBblFRQUxFUUJCN0lmQUFFRVJRWUNJd0FBUVVBQUxEUUFnQUNnQ0FCb0Rmd3dBQ3dzTkFDQUFOUUlBUVFFZ0FSQXBDd3NBSUFBakFHb2tBQ01BQ3dvQUlBQWdBUkNNQVE4TENRQWdBQ0FCRUFFQUN3MEFRWWlEd0FCQkd4Q0VBUUFMRGdCQm80UEFBRUhQQUJDRUFRQUxDZ0FnQUNnQ0JFRjRjUXNLQUNBQUtBSUVRUUZ4Q3dvQUlBQW9BZ3hCQVhFTENnQWdBQ2dDREVFQmRnc0tBQ0FBSUFFUWd3RUFDd2tBSUFBZ0FSQmxBQXNIQUNBQUVBSUFDd2dBSUFBZ0FSQWpDd2NBSUFBZ0FXb0xCd0FnQUNBQmF3c0hBQ0FBUVFocUN3Y0FJQUJCZUdvTEJnQVFtd0VBQ3dZQUlBQVFEd3NIQUNBQUtBSU1Dd2NBSUFBb0FnZ0xCd0FnQUNnQ0NBc0hBQ0FBS0FJTUN3MEFRdlQ1bnVidW82cjUvZ0FMREFCQ3VabWxsWmpEak9ON0N3TUFBQXNEQUFBTEJBQkJCd3NFQUNBQUN3UUFRUUFMQkFCQkFBc0VBRUVBQ3dRQVFRQUxCQUJCQVFzR0FFR0FnQVFMQndCQnlJYkFBQXNOQUVLWW90SDEwdTNNN0l0L0N3SUFDd0lBQ3dJQUN3SUFDd3ZIaTRDQUFBRUFRWUNBd0FBTHZRc0lBQUFBQUFBQUFBUUFBQUFBQUFBQWMzSmpYR1oxZW5wNVgyUmljMk5oYmk1eWN3QVFBQkFBRXdBQUFMb0FBQUFuQUFBQUVBQVFBQk1BQUFDNkFBQUFSQUFBQUJBQUVBQVRBQUFBbndBQUFBMEFBQUFRQUJBQUV3QUFBS1lBQUFBWkFBQUFFQUFRQUJNQUFBRFhBQUFBSlFBQUFCQUFFQUFUQUFBQTF3QUFBRHNBQUFCemNtTmNiR2xpTG5KekFBQ0VBQkFBQ2dBQUFGWUFBQUFZQUFBQWhBQVFBQW9BQUFCV0FBQUFKd0FBQUlRQUVBQUtBQUFBWmdBQUFCZ0FBQUNFQUJBQUNnQUFBR1lBQUFBbkFBQUFZWFIwWlcxd2RDQjBieUJqWVd4amRXeGhkR1VnZEdobElISmxiV0ZwYm1SbGNpQjNhWFJvSUdFZ1pHbDJhWE52Y2lCdlppQjZaWEp2QUFBQWhBQVFBQW9BQUFDQkFBQUFGQUFBQUlRQUVBQUtBQUFBakFBQUFBZ0FBQUNFQUJBQUNnQUFBSk1BQUFBVUFBQUFkVzVsZUhCbFkzUmxaQ0JsYm1RZ2IyWWdhVzV3ZFhRQVBBRVFBQmNBQUFDRUFCQUFBQUFBQUhOeVkxeG1kWHA2ZVY5a1luTmpZVzR1Y25NQVpBRVFBQk1BQUFETEFBQUFNUUFBQUc1MWJHd2djRzlwYm5SbGNpQndZWE56WldRZ2RHOGdjblZ6ZEhKbFkzVnljMmwyWlNCMWMyVWdiMllnWVc0Z2IySnFaV04wSUdSbGRHVmpkR1ZrSUhkb2FXTm9JSGR2ZFd4a0lHeGxZV1FnZEc4Z2RXNXpZV1psSUdGc2FXRnphVzVuSUdsdUlISjFjM1FBQUFRQUFBQUFBQUFBQXdBQUFBUUFBQUFFQUFBQUJBQUFBQVVBQUFBR0FBQUFZMkZzYkdWa0lHQlBjSFJwYjI0Nk9uVnVkM0poY0NncFlDQnZiaUJoSUdCT2IyNWxZQ0IyWVd4MVpRQUJBQUFBQUFBQUFHeHBZbkpoY25rdmMzUmtMM055WXk5d1lXNXBZMnRwYm1jdWNuTklBaEFBSEFBQUFBTUNBQUFmQUFBQVNBSVFBQndBQUFBRUFnQUFIZ0FBQUFjQUFBQVFBQUFBQkFBQUFBZ0FBQUFKQUFBQUF3QUFBQWdBQUFBRUFBQUFDZ0FBQUFzQUFBQU1BQUFBREFBQUFBUUFBQUFOQUFBQUF3QUFBQWdBQUFBRUFBQUFEZ0FBQUVoaGMyZ2dkR0ZpYkdVZ1kyRndZV05wZEhrZ2IzWmxjbVpzYjNjdlkyRnlaMjh2Y21WbmFYTjBjbmt2YzNKakwyZHBkR2gxWWk1amIyMHRNV1ZqWXpZeU9UbGtZamxsWXpneU15OW9ZWE5vWW5KdmQyNHRNQzR4TVM0d0wzTnlZeTl5WVhjdmJXOWtMbkp6QU9nQ0VBQlBBQUFBWXdBQUFDZ0FBQUQvLy8vL0R3QUFBQVFBQUFBRUFBQUFFQUFBQUJFQUFBQVNBQUFBRHdBQUFBQUFBQUFCQUFBQUV3QUFBR0VnWm05eWJXRjBkR2x1WnlCMGNtRnBkQ0JwYlhCc1pXMWxiblJoZEdsdmJpQnlaWFIxY201bFpDQmhiaUJsY25KdmNteHBZbkpoY25rdllXeHNiMk12YzNKakwyWnRkQzV5Y3dDbkF4QUFHQUFBQUVjQ0FBQWNBQUFBYkdsaWNtRnllUzloYkd4dll5OXpjbU12Y21GM1gzWmxZeTV5YzJOaGNHRmphWFI1SUc5MlpYSm1iRzkzQUFBQTBBTVFBQndBQUFBdkFnQUFCUUFBQUJnQUFBQUFBQUFBQVFBQUFCa0FBQUJwYm1SbGVDQnZkWFFnYjJZZ1ltOTFibVJ6T2lCMGFHVWdiR1Z1SUdseklDQmlkWFFnZEdobElHbHVaR1Y0SUdseklBQUFJQVFRQUNBQUFBQkFCQkFBRWdBQUFEb2dBQUFRQkJBQUFBQUFBR1FFRUFBQ0FBQUFNREF3TVRBeU1ETXdOREExTURZd056QTRNRGt4TURFeE1USXhNekUwTVRVeE5qRTNNVGd4T1RJd01qRXlNakl6TWpReU5USTJNamN5T0RJNU16QXpNVE15TXpNek5ETTFNell6TnpNNE16azBNRFF4TkRJME16UTBORFUwTmpRM05EZzBPVFV3TlRFMU1qVXpOVFExTlRVMk5UYzFPRFU1TmpBMk1UWXlOak0yTkRZMU5qWTJOelk0TmprM01EY3hOekkzTXpjME56VTNOamMzTnpnM09UZ3dPREU0TWpnek9EUTROVGcyT0RjNE9EZzVPVEE1TVRreU9UTTVORGsxT1RZNU56azRPVGtnYjNWMElHOW1JSEpoYm1kbElHWnZjaUJ6YkdsalpTQnZaaUJzWlc1bmRHZ2djbUZ1WjJVZ1pXNWtJR2x1WkdWNElBQUFZZ1VRQUJBQUFBQkFCUkFBSWdBQUFITnNhV05sSUdsdVpHVjRJSE4wWVhKMGN5QmhkQ0FnWW5WMElHVnVaSE1nWVhRZ0FJUUZFQUFXQUFBQW1nVVFBQTBBQUFCRmNuSnZjZ0NMMFlDQUFBUnVZVzFsQVlEUmdJQUFxd0VBTm5kaGMyMWZZbWx1WkdkbGJqbzZYMTkzWW1sdVpHZGxibDl6ZEhKcGJtZGZibVYzT2pwb09ESTNaRGhtTUdVME5qTXdZVGRqTVFFeGQyRnpiVjlpYVc1a1oyVnVPanBmWDNkaWFXNWtaMlZ1WDNSb2NtOTNPanBvWXpRMk16Y3dNREZpWW1JNFl6UTRaQUl6ZDJGemJWOWlhVzVrWjJWdU9qcGZYM2RpYVc1a1oyVnVYM0psZEdoeWIzYzZPbWhrT0RRMU5tUXhZVFJtT1dZNVpUZ3dBeFJtZFhwNmVXTnNkWE4wWlhKZlkyeDFjM1JsY2dRNlpHeHRZV3hzYjJNNk9tUnNiV0ZzYkc5ak9qcEViRzFoYkd4dll6eEJQam82YldGc2JHOWpPanBvWldWaU5qa3pZemN5TTJRM04yWmhNQVZBWkROemRGOTNZWE50T2pwbWRYcDZlVjlrWW5OallXNDZPa1oxZW5wNVJFSlRRMEZPT2pwamJIVnpkR1Z5T2pwb00yTXpOekF4WkRCbE5HTmhNbU5tT1FaQVpETnpkRjkzWVhOdE9qcG1kWHA2ZVY5a1luTmpZVzQ2T2taMWVucDVSRUpUUTBGT09qcGpiSFZ6ZEdWeU9qcG9OREZrTTJNME1XVmhOMk5oWW1JeU1BZEFaRE56ZEY5M1lYTnRPanBtZFhwNmVWOWtZbk5qWVc0Nk9rWjFlbnA1UkVKVFEwRk9PanBqYkhWemRHVnlPanBvTVRCak1tTTBNbU01WXpVek1qVm1OZ2hBWkROemRGOTNZWE50T2pwbWRYcDZlVjlrWW5OallXNDZPa1oxZW5wNVJFSlRRMEZPT2pwamJIVnpkR1Z5T2pwb016azROMkpqTWpVNFltSXhNRFUzTVFsQVpETnpkRjkzWVhOdE9qcG1kWHA2ZVY5a1luTmpZVzQ2T2taMWVucDVSRUpUUTBGT09qcGpiSFZ6ZEdWeU9qcG9aV1U1WlRRd09XSXhZamN5TnpGall3cEFaRE56ZEY5M1lYTnRPanBtZFhwNmVWOWtZbk5qWVc0Nk9rWjFlbnA1UkVKVFEwRk9PanBqYkhWemRHVnlPanBvT0dWaU1qVm1ZakUzTW1Zd1l6bGxaZ3RBWkROemRGOTNZWE50T2pwbWRYcDZlVjlrWW5OallXNDZPa1oxZW5wNVJFSlRRMEZPT2pwamJIVnpkR1Z5T2pwb1kyVm1NekF6WlRBNU5XWTFNekptWWd4QVpETnpkRjkzWVhOdE9qcG1kWHA2ZVY5a1luTmpZVzQ2T2taMWVucDVSRUpUUTBGT09qcGpiSFZ6ZEdWeU9qcG9aV0kzWVRrNFptWmtPV1ZtTnpreVpRMUFhR0Z6YUdKeWIzZHVPanB5WVhjNk9sSmhkMVJoWW14bFBGUXNRVDQ2T25KbGMyVnlkbVZmY21Wb1lYTm9PanBvWlRVM09Ea3pNekUyWkdOaE9EWTRZdzRzWTI5eVpUbzZabTEwT2pwR2IzSnRZWFIwWlhJNk9uQmhaRG82YURjeVkyTmpOREl4T1dNeFpEQTVaakFQT0dSc2JXRnNiRzlqT2pwa2JHMWhiR3h2WXpvNlJHeHRZV3hzYjJNOFFUNDZPbVp5WldVNk9taGlNRGRsWldaa016RmxZV05rT0RSakVEVmpiM0psT2pwbWJYUTZPa1p2Y20xaGRIUmxjam82Y0dGa1gybHVkR1ZuY21Gc09qcG9PR00zTmpZd01HUXhNV0V5WXpSaU1SRkFaRE56ZEY5M1lYTnRPanBtZFhwNmVWOWtZbk5qWVc0Nk9rWjFlbnA1UkVKVFEwRk9PanBrWlc1emFYUjVPanBvWkRjeU9EQTRPV0poTXpOalptVmxOeElOWDE5eVpHeGZjbVZoYkd4dll4TTdhR0Z6YUdKeWIzZHVPanB0WVhBNk9raGhjMmhOWVhBOFN5eFdMRk1zUVQ0Nk9tbHVjMlZ5ZERvNmFHUTROREk1WlRZMk9XWTVOekprT0RNVUsyUXpjM1JmZDJGemJUbzZjR0ZqYTE5amJIVnpkR1Z5Y3pvNmFHSm1aams0TkRrNU16WmxNekF3WVRVVlRXTnZjbVU2T21oaGMyZzZPbWx0Y0d4ek9qbzhhVzF3YkNCamIzSmxPanBvWVhOb09qcElZWE5vSUdadmNpQjFjMmw2WlQ0Nk9taGhjMmc2T21obU16QTFNelEzTURZNFpUSmpPVGt3RmlOamIzSmxPanBtYlhRNk9uZHlhWFJsT2pwb1lqTTJNMkUxWTJNek4yUmlOelJoWmhkQVpETnpkRjkzWVhOdE9qcG1kWHA2ZVY5a1luTmpZVzQ2T2taMWVucDVSRUpUUTBGT09qcGtaVzV6YVhSNU9qcG9NRGMxT1RrMU9XUmxNV0l3TVRNMVl4aEFaRE56ZEY5M1lYTnRPanBtZFhwNmVWOWtZbk5qWVc0Nk9rWjFlbnA1UkVKVFEwRk9PanBrWlc1emFYUjVPanBvWXpjMU9UVTFZMlZpTVRnM01EWTJOeGxBWkROemRGOTNZWE50T2pwbWRYcDZlVjlrWW5OallXNDZPa1oxZW5wNVJFSlRRMEZPT2pwa1pXNXphWFI1T2pwb1pUZ3laVFk1TUdRd1pURTNZVE0xT0JwQlpHeHRZV3hzYjJNNk9tUnNiV0ZzYkc5ak9qcEViRzFoYkd4dll6eEJQam82WkdsemNHOXpaVjlqYUhWdWF6bzZhRE5sWlRneE1XSXpNbVV6TTJSa1lqUWJKV0ZzYkc5ak9qcG1iWFE2T21admNtMWhkRG82YURKaFlqTm1aRGRrT0RFM016WXdZMlVjUUdRemMzUmZkMkZ6YlRvNlpuVjZlbmxmWkdKelkyRnVPanBHZFhwNmVVUkNVME5CVGpvNlpHVnVjMmwwZVRvNmFEaGlaVFUxWmpJd1l6TTRPR00yWkRRZFFHUXpjM1JmZDJGemJUbzZablY2ZW5sZlpHSnpZMkZ1T2pwR2RYcDZlVVJDVTBOQlRqbzZaR1Z1YzJsMGVUbzZhRFkzWldKbU9HTm1NekZqTW1Jd01UWWVRV2hoYzJoaWNtOTNiam82YldGd09qcElZWE5vVFdGd1BFc3NWaXhUTEVFK09qcHlaVzF2ZG1WZlpXNTBjbms2T21nelpHVTJZVEE1WkRObVlqQXlPREZpSDJnOFkyOXlaVG82YVhSbGNqbzZZV1JoY0hSbGNuTTZPbTFoY0RvNlRXRndQRWtzUmo0Z1lYTWdZMjl5WlRvNmFYUmxjam82ZEhKaGFYUnpPanBwZEdWeVlYUnZjam82U1hSbGNtRjBiM0krT2pwbWIyeGtPanBvWlRWaVpHSmpOamMxTlRVNE1tTmpNeUJBWkROemRGOTNZWE50T2pwbWRYcDZlVjlrWW5OallXNDZPa1oxZW5wNVJFSlRRMEZPT2pwa1pXNXphWFI1T2pwb01XWXdZekJpTXpZMU5qRTFZVFUxTVNGQVpETnpkRjkzWVhOdE9qcG1kWHA2ZVY5a1luTmpZVzQ2T2taMWVucDVSRUpUUTBGT09qcGtaVzV6YVhSNU9qcG9ZalZsTXprME1EQXlPVGM0TWpnd1l5STRhR0Z6YUdKeWIzZHVPanB5WVhjNk9sSmhkMVJoWW14bFBGUXNRVDQ2T21sdWMyVnlkRG82YURReVpqbGtOR0ZsTlRSaU1EbG1aVGtqTUdSc2JXRnNiRzlqT2pwRWJHMWhiR3h2WXp4QlBqbzZiV0ZzYkc5ak9qcG9ZbVF5WWpKaE5UWXhaVEJsWmpZM01DUSthR0Z6YUdKeWIzZHVPanB5WVhjNk9sSmhkMVJoWW14bFBGUXNRVDQ2T25KbGJXOTJaVjlsYm5SeWVUbzZhR1ZrTXpRek9UUXlNakpsTXpJM1lXSWxCMjFsYlcxdmRtVW1PendtYlhWMElGY2dZWE1nWTI5eVpUbzZabTEwT2pwWGNtbDBaVDQ2T25keWFYUmxYMk5vWVhJNk9tZzVaakJsTnpZeU9XUmlZVEZpWXpGbEp5NWhiR3h2WXpvNmMzUnlhVzVuT2pwVGRISnBibWM2T25CMWMyZzZPbWd6TlRJd016QTFZMkUxTmpGa1kyWTNLR2c4WTI5eVpUbzZhWFJsY2pvNllXUmhjSFJsY25NNk9tMWhjRG82VFdGd1BFa3NSajRnWVhNZ1kyOXlaVG82YVhSbGNqbzZkSEpoYVhSek9qcHBkR1Z5WVhSdmNqbzZTWFJsY21GMGIzSStPanBtYjJ4a09qcG9PR0l6WXpZMk1HUTRaVEJsWWpSaE9Da3ZZMjl5WlRvNlptMTBPanB1ZFcwNk9tbHRjRG82Wm0xMFgzVTJORG82YURSa09HTXlObU16TmpJelkySTVPR0lxYUR4amIzSmxPanBwZEdWeU9qcGhaR0Z3ZEdWeWN6bzZiV0Z3T2pwTllYQThTU3hHUGlCaGN5QmpiM0psT2pwcGRHVnlPanAwY21GcGRITTZPbWwwWlhKaGRHOXlPanBKZEdWeVlYUnZjajQ2T21admJHUTZPbWc0T0RabE5UUmhOelk0WTJSa01qVTJLMFprYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2tSc2JXRnNiRzlqUEVFK09qcHBibk5sY25SZmJHRnlaMlZmWTJoMWJtczZPbWd5WkRkaFlqUmpaREl4WWpsaU1XVTRMRVprYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2tSc2JXRnNiRzlqUEVFK09qcDFibXhwYm10ZmJHRnlaMlZmWTJoMWJtczZPbWhpTURjNU1qVm1NRE15WTJNNE5qUTRMV2c4WTI5eVpUbzZhWFJsY2pvNllXUmhjSFJsY25NNk9tMWhjRG82VFdGd1BFa3NSajRnWVhNZ1kyOXlaVG82YVhSbGNqbzZkSEpoYVhSek9qcHBkR1Z5WVhSdmNqbzZTWFJsY21GMGIzSStPanBtYjJ4a09qcG9PV05pTkdZNU16Rm1ZMkZpT0RnME55NUxaR3h0WVd4c2IyTTZPbVJzYldGc2JHOWpPanBFYkcxaGJHeHZZenhCUGpvNmNtVnNaV0Z6WlY5MWJuVnpaV1JmYzJWbmJXVnVkSE02T21neE5XRTBORFUyTW1ZeVptWXlNakk0TDJnOGMzUmtPanB3WVc1cFkydHBibWM2T21KbFoybHVYM0JoYm1salgyaGhibVJzWlhJNk9sQmhibWxqVUdGNWJHOWhaQ0JoY3lCamIzSmxPanB3WVc1cFl6bzZRbTk0VFdWVmNENDZPblJoYTJWZlltOTRPanBvTURJeE0yWTRZVFUwTjJNM1pUZGlZakJvUEdOdmNtVTZPbWwwWlhJNk9tRmtZWEIwWlhKek9qcHRZWEE2T2sxaGNEeEpMRVkrSUdGeklHTnZjbVU2T21sMFpYSTZPblJ5WVdsMGN6bzZhWFJsY21GMGIzSTZPa2wwWlhKaGRHOXlQam82Wm05c1pEbzZhRFUyWVRsalkyUTBabUZqWlRWak5Ua3hUbUZzYkc5ak9qcHlZWGRmZG1Wak9qcFNZWGRXWldNOFZDeEJQam82Y21WelpYSjJaVG82Wkc5ZmNtVnpaWEoyWlY5aGJtUmZhR0Z1Wkd4bE9qcG9OakpqWmpRNVpETXlPVGM1WlRNNU9USk9ZV3hzYjJNNk9uSmhkMTkyWldNNk9sSmhkMVpsWXp4VUxFRStPanB5WlhObGNuWmxPanBrYjE5eVpYTmxjblpsWDJGdVpGOW9ZVzVrYkdVNk9taGtNMlF5WTJNd1ltRTNNVEE1TkdabE0wNWhiR3h2WXpvNmNtRjNYM1psWXpvNlVtRjNWbVZqUEZRc1FUNDZPbkpsYzJWeWRtVTZPbVJ2WDNKbGMyVnlkbVZmWVc1a1gyaGhibVJzWlRvNmFEQXpaREF4T1RCbVpXRmtOREJqTVRVMFhqeGtNM04wWDNkaGMyMDZPa1JoZEdGUWIybHVkRHhmUGlCaGN5QmtNM04wWDNkaGMyMDZPbVoxZW5wNVgyUmljMk5oYmpvNlRXVjBjbWxqVTNCaFkyVStPanBrYVhOMFlXNWpaVG82YURVeU16VTNOalE0WkRFME1UUTRabVExVG1Gc2JHOWpPanB5WVhkZmRtVmpPanBTWVhkV1pXTThWQ3hCUGpvNmNtVnpaWEoyWlRvNlpHOWZjbVZ6WlhKMlpWOWhibVJmYUdGdVpHeGxPanBvTWpOaFlUaGlNV05qWm1Sak5Ea3lNVFpvUEdOdmNtVTZPbWwwWlhJNk9tRmtZWEIwWlhKek9qcHRZWEE2T2sxaGNEeEpMRVkrSUdGeklHTnZjbVU2T21sMFpYSTZPblJ5WVdsMGN6bzZhWFJsY21GMGIzSTZPa2wwWlhKaGRHOXlQam82Wm05c1pEbzZhREpqT1RVM01qa3hOamszT0RKaE56ZzNOM04wWkRvNmNHRnVhV05yYVc1bk9qcHlkWE4wWDNCaGJtbGpYM2RwZEdoZmFHOXZhem82YURNMk5EazNOR1UzTVRkbFpEVTVaV000WGp4a00zTjBYM2RoYzIwNk9rUmhkR0ZRYjJsdWREeGZQaUJoY3lCa00zTjBYM2RoYzIwNk9tWjFlbnA1WDJSaWMyTmhiam82VFdWMGNtbGpVM0JoWTJVK09qcGthWE4wWVc1alpUbzZhRGd5WlRReE16Vm1OVEkxTWpZNE9UVTVaVHhvWVhOb1luSnZkMjQ2T25KaGR6bzZVbUYzU1c1MGIwbDBaWEk4VkN4QlBpQmhjeUJqYjNKbE9qcHBkR1Z5T2pwMGNtRnBkSE02T21sMFpYSmhkRzl5T2pwSmRHVnlZWFJ2Y2o0Nk9tNWxlSFE2T21neVlXUmtPVEkyTm1ZeU9HRmlNVGxsT2dadFpXMWpjSGs3Qm0xbGJYTmxkRHhPWVd4c2IyTTZPbkpoZDE5MlpXTTZPbEpoZDFabFl6eFVMRUUrT2pweVpYTmxjblpsT2pwa2IxOXlaWE5sY25abFgyRnVaRjlvWVc1a2JHVTZPbWcwT1RJMFpXRmtNREpsTkdJM09UUXdQVTVoYkd4dll6bzZjbUYzWDNabFl6bzZVbUYzVm1WalBGUXNRVDQ2T25KbGMyVnlkbVU2T21SdlgzSmxjMlZ5ZG1WZllXNWtYMmhoYm1Sc1pUbzZhRGN5WWpWbVl6bGhNbUl3TnpjM09ERStZenh6ZEdRNk9uQmhibWxqYTJsdVp6bzZZbVZuYVc1ZmNHRnVhV05mYUdGdVpHeGxjam82VUdGdWFXTlFZWGxzYjJGa0lHRnpJR052Y21VNk9uQmhibWxqT2pwQ2IzaE5aVlZ3UGpvNloyVjBPanBvTURJelpUZ3dNakUyTXpVeFpHUmxOVDh1WVd4c2IyTTZPbkpoZDE5MlpXTTZPbVpwYm1semFGOW5jbTkzT2pwb01tWTFZamt3TjJabFkyWm1NR0psWWtBdVlXeHNiMk02T25KaGQxOTJaV002T21acGJtbHphRjluY205M09qcG9NMll5TnpRMVlUVTVOVEl6WWpJMFprRXVZV3hzYjJNNk9uSmhkMTkyWldNNk9tWnBibWx6YUY5bmNtOTNPanBvTVdVeE56ZzRNVEU0TVRjeFlqQmxaVUpvUEdOdmNtVTZPbWwwWlhJNk9tRmtZWEIwWlhKek9qcHRZWEE2T2sxaGNEeEpMRVkrSUdGeklHTnZjbVU2T21sMFpYSTZPblJ5WVdsMGN6bzZhWFJsY21GMGIzSTZPa2wwWlhKaGRHOXlQam82Wm05c1pEbzZhRFZsTnpVNFpUWTJPV1JrTTJVM01qaERhRHhqYjNKbE9qcHBkR1Z5T2pwaFpHRndkR1Z5Y3pvNmJXRndPanBOWVhBOFNTeEdQaUJoY3lCamIzSmxPanBwZEdWeU9qcDBjbUZwZEhNNk9tbDBaWEpoZEc5eU9qcEpkR1Z5WVhSdmNqNDZPbVp2YkdRNk9tZzVPREV5T0Raa1kyVXlaRFU0T0dFelJHbzhhR0Z6YUdKeWIzZHVPanB5WVhjNk9sSmhkMVJoWW14bFBGUXNRVDRnWVhNZ1kyOXlaVG82YVhSbGNqbzZkSEpoYVhSek9qcGpiMnhzWldOME9qcEpiblJ2U1hSbGNtRjBiM0krT2pwcGJuUnZYMmwwWlhJNk9tZzFaRFpsWmpsbE1HRXdOamcxWW1OaVJVTnpkR1E2T25CaGJtbGphMmx1WnpvNlltVm5hVzVmY0dGdWFXTmZhR0Z1Wkd4bGNqbzZlM3RqYkc5emRYSmxmWDA2T21nNVl6WTNOVEUyT0RkaVptTTFOVEl4Umk1amIzSmxPanB5WlhOMWJIUTZPblZ1ZDNKaGNGOW1ZV2xzWldRNk9tZzJPVFJrWWpFellUUTFZV0UyTnpRd1J6WmpiM0psT2pwd1lXNXBZMnRwYm1jNk9uQmhibWxqWDJKdmRXNWtjMTlqYUdWamF6bzZhREZrT0RRMU1UbGxZelEyWldRME9HTklQMk52Y21VNk9uTnNhV05sT2pwcGJtUmxlRG82YzJ4cFkyVmZaVzVrWDJsdVpHVjRYMnhsYmw5bVlXbHNPanBvWlRBd01EVXpNekl5WkRSa04yRmhORWs5WTI5eVpUbzZjMnhwWTJVNk9tbHVaR1Y0T2pwemJHbGpaVjlwYm1SbGVGOXZjbVJsY2w5bVlXbHNPanBvWlRNNE9HUXdNMkl5T0RJNFlqUmxZa295WTI5eVpUbzZabTEwT2pwR2IzSnRZWFIwWlhJNk9uZHlhWFJsWDJadGREbzZhREUzTlRFd1ltUTFabUUyT0Rka01URkxPandtYlhWMElGY2dZWE1nWTI5eVpUbzZabTEwT2pwWGNtbDBaVDQ2T25keWFYUmxYMlp0ZERvNmFEUmxOak5pWlRrM01EYzVOek5rTlRGTU9qd21iWFYwSUZjZ1lYTWdZMjl5WlRvNlptMTBPanBYY21sMFpUNDZPbmR5YVhSbFgyWnRkRG82YUdKa01UQTFOamc0TkdFeU1qbGtZakZOT2p3bWJYVjBJRmNnWVhNZ1kyOXlaVG82Wm0xME9qcFhjbWwwWlQ0Nk9uZHlhWFJsWDNOMGNqbzZhR0ppT1dRMk1EbG1ZVFpqWVRJeU5qVk9PandtYlhWMElGY2dZWE1nWTI5eVpUbzZabTEwT2pwWGNtbDBaVDQ2T25keWFYUmxYM04wY2pvNmFEWm1Oakk1TVRZME5tTm1OREV5WTJaUFEyTnZjbVU2T21adGREbzZSbTl5YldGMGRHVnlPanB3WVdSZmFXNTBaV2R5WVd3Nk9uZHlhWFJsWDNCeVpXWnBlRG82YURVNE5XTTBaamN5WlRGa09EUmpNV0ZRS1dOdmNtVTZPbkJoYm1samEybHVaem82Y0dGdWFXTTZPbWhqWldGbE1HTTNPV0l3TWpRM1pqazRVVWM4WkROemRGOTNZWE50T2pwRGJIVnpkR1Z5UlhKeWIzSWdZWE1nWTI5eVpUbzZabTEwT2pwRWFYTndiR0Y1UGpvNlptMTBPanBvWkROaVlXSTVOekpsWTJJelptRTROMUpyUEhOMFpEbzZjR0Z1YVdOcmFXNW5PanBpWldkcGJsOXdZVzVwWTE5b1lXNWtiR1Z5T2pwVGRISlFZVzVwWTFCaGVXeHZZV1FnWVhNZ1kyOXlaVG82Y0dGdWFXTTZPa0p2ZUUxbFZYQStPanAwWVd0bFgySnZlRG82YURoak5XUmpPRFkzWmpCaE5qazVOREZUU0R4a2JHMWhiR3h2WXpvNmMzbHpPanBUZVhOMFpXMGdZWE1nWkd4dFlXeHNiMk02T2tGc2JHOWpZWFJ2Y2o0Nk9tRnNiRzlqT2pwb1pXVmpaVFJoWW1Fd05tTXhORGd5TjFRUVpuVjZlbmxqYkhWemRHVnlYMjVsZDFVUmNuVnpkRjlpWldkcGJsOTFibmRwYm1SV0VWOWZkMkpwYm1SblpXNWZiV0ZzYkc5alZ4SmZYM0prYkY5aGJHeHZZMTk2WlhKdlpXUllOMlJzYldGc2JHOWpPanBrYkcxaGJHeHZZem82UTJoMWJtczZPbk5sZEY5cGJuVnpaVG82YUdFeVpqbGpaamxsWVRRMFl6WTFOV1JaRjE5ZmQySm5YMloxZW5wNVkyeDFjM1JsY2w5bWNtVmxXaTFqYjNKbE9qcHdZVzVwWTJ0cGJtYzZPbkJoYm1salgyWnRkRG82YUdZMk9XTTRZakE0WW1NNVpESmxaVFZiMEFGamIzSmxPanB3ZEhJNk9tUnliM0JmYVc1ZmNHeGhZMlU4YzNSa09qcGxjbkp2Y2pvNlBHbHRjR3dnWTI5eVpUbzZZMjl1ZG1WeWREbzZSbkp2YlR4aGJHeHZZem82YzNSeWFXNW5PanBUZEhKcGJtYytJR1p2Y2lCaGJHeHZZem82WW05NFpXUTZPa0p2ZUR4a2VXNGdjM1JrT2pwbGNuSnZjam82UlhKeWIzSXJZMjl5WlRvNmJXRnlhMlZ5T2pwVFpXNWtLMk52Y21VNk9tMWhjbXRsY2pvNlUzbHVZejQrT2pwbWNtOXRPanBUZEhKcGJtZEZjbkp2Y2o0Nk9tZzBOVEl6WkdJeU1tUTRNVGsyTnpNeVhGNWpiM0psT2pwd2RISTZPbVJ5YjNCZmFXNWZjR3hoWTJVOGMzUmtPanB3WVc1cFkydHBibWM2T21KbFoybHVYM0JoYm1salgyaGhibVJzWlhJNk9sQmhibWxqVUdGNWJHOWhaRDQ2T21oa09XRmlOalV3TlRJME9USmlOVEpoWFFweWRYTjBYM0JoYm1salhqVmtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPbE5sWjIxbGJuUTZPbWh2YkdSek9qcG9NRGMwTWpJeU5ERm1OVEJpTmpZMk1sOUNaR3h0WVd4c2IyTTZPbVJzYldGc2JHOWpPanBEYUhWdWF6bzZjMlYwWDJsdWRYTmxYMkZ1WkY5d2FXNTFjMlU2T21nM05XTXlaamd6TjJOaU56WXlaakkyWUVKa2JHMWhiR3h2WXpvNlpHeHRZV3hzYjJNNk9rTm9kVzVyT2pwelpYUmZabkpsWlY5M2FYUm9YM0JwYm5WelpUbzZhR1JsTmpRME1UQTNNakZqWkRVMU9HWmhPV2hoYzJoaWNtOTNiam82Y21GM09qcEdZV3hzYVdKcGJHbDBlVG82WVd4c2IyTmZaWEp5T2pwb05tRmhNelEwWXpka09UTm1NelF3TkdKQmFHRnphR0p5YjNkdU9qcHlZWGM2T2taaGJHeHBZbWxzYVhSNU9qcGpZWEJoWTJsMGVWOXZkbVZ5Wm14dmR6bzZhR1kxWTJZell6STJabUU1WkdRek5tSmpRR1JzYldGc2JHOWpPanBrYkcxaGJHeHZZem82VkhKbFpVTm9kVzVyT2pwc1pXWjBiVzl6ZEY5amFHbHNaRG82YURRNFpqSTFNREptWTJSalptRXdZVEprQkdadGFXNWxDSEoxYzNSZmIyOXRaajlrYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T214bFpuUnphR2xtZEY5bWIzSmZkSEpsWlY5cGJtUmxlRG82YURZeVpHRmpaakk0WTJOaVpUQXhZbVZuVDJSc2JXRnNiRzlqT2pwa2JHMWhiR3h2WXpvNlEyaDFibXM2T25ObGRGOXphWHBsWDJGdVpGOXdhVzUxYzJWZmIyWmZabkpsWlY5amFIVnVhem82YURrMFkyVmlNRGd5TXpreFpqZzVPV1JvUGp4amIzSmxPanBtYlhRNk9rVnljbTl5SUdGeklHTnZjbVU2T21adGREbzZSR1ZpZFdjK09qcG1iWFE2T21oak1tVm1ObUV5TlRFME1tVTFNVFJoYVRKamIzSmxPanB2Y0hScGIyNDZPazl3ZEdsdmJqeFVQam82ZFc1M2NtRndPanBvTWpWaVlqSTBNMlUxWm1SalpqWTFOR295WTI5eVpUbzZiM0IwYVc5dU9qcFBjSFJwYjI0OFZENDZPblZ1ZDNKaGNEbzZhR05qWXpWa05EVmpZVGM1WVRJNE0yUnJMMlJzYldGc2JHOWpPanBrYkcxaGJHeHZZem82WVd4cFoyNWZkWEE2T21nME56Y3lZell5TkRSaFpXTTJOekV6YkE1ZlgzSjFjM1JmY21WaGJHeHZZMjBQWDE5M1ltbHVaR2RsYmw5bWNtVmxia2x6ZEdRNk9uTjVjMTlqYjIxdGIyNDZPbUpoWTJ0MGNtRmpaVG82WDE5eWRYTjBYMlZ1WkY5emFHOXlkRjlpWVdOcmRISmhZMlU2T21nME16aGxZMlZoWmpRNVpEWXlPV05rYnpCa2JHMWhiR3h2WXpvNlpHeHRZV3hzYjJNNk9teGxablJmWW1sMGN6bzZhR1ppWmpNeE16aGxOelZoTlRabVpUbHdNRHdtVkNCaGN5QmpiM0psT2pwbWJYUTZPa1JsWW5WblBqbzZabTEwT2pwb1pUQm1ZakJsWXpVMU5tRTJZV0kwWVhFTVgxOXlkWE4wWDJGc2JHOWpjaE5mWDNKMWMzUmZZV3hzYjJOZmVtVnliMlZrYzJZOGMzUmtPanB3WVc1cFkydHBibWM2T21KbFoybHVYM0JoYm1salgyaGhibVJzWlhJNk9sTjBjbEJoYm1salVHRjViRzloWkNCaGN5QmpiM0psT2pwd1lXNXBZem82UW05NFRXVlZjRDQ2T21kbGREbzZhR0kxWTJKbU56QmlOVE5oTnpKbU1XVjBQbk4wWkRvNmMzbHpPanAzWVhOdE9qcGpiMjF0YjI0Nk9taGhjMmh0WVhCZmNtRnVaRzl0WDJ0bGVYTTZPbWhqWlRFeFptWTBabU14TVdOa1pqTm1kVFJrYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2tOb2RXNXJPanBqYVc1MWMyVTZPbWcxWlRnM09XUXdORE16TURJeU9EazFkanBrYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2tOb2RXNXJPanBqYkdWaGNsOXdhVzUxYzJVNk9tZ3haVGcwWWpKbU1qZ3pZV1E0WlRnNWR6TmtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPa05vZFc1ck9qcHBiblZ6WlRvNmFEaGpabU0yTmpZMVlXRmxPV0l5T0RkNE1qd21WQ0JoY3lCamIzSmxPanBtYlhRNk9rUnBjM0JzWVhrK09qcG1iWFE2T21oaE9ESXdaRE16Tnpsa1pUTmpPREl6ZVE1ZlgzSjFjM1JmWkdWaGJHeHZZM293Wkd4dFlXeHNiMk02T21Sc2JXRnNiRzlqT2pwc1pXRnpkRjlpYVhRNk9taG1NV0ZqTjJaaVlqQmpPV0ZtWTJZMmV6VmtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPa05vZFc1ck9qcHRiV0Z3Y0dWa09qcG9ORE16WkRBME9HVTVPVE5pTXprMlpYeFFaR3h0WVd4c2IyTTZPbVJzYldGc2JHOWpPanBEYUhWdWF6bzZjMlYwWDNOcGVtVmZZVzVrWDNCcGJuVnpaVjl2Wmw5cGJuVnpaVjlqYUhWdWF6bzZhR0l6WTJSaE4yVmxNV0psTlRFNVlqaDlNMlJzYldGc2JHOWpPanBrYkcxaGJHeHZZem82VTJWbmJXVnVkRG82ZEc5d09qcG9OMkpoTkdOaU16VmlNbUZpTnpoaU0zNDdQQ1p0ZFhRZ1Z5QmhjeUJqYjNKbE9qcG1iWFE2T2xkeWFYUmxQam82ZDNKcGRHVmZZMmhoY2pvNmFHUm1Oamt3WkRJeE4yVm1ZalF5TVdWL05HRnNiRzlqT2pweVlYZGZkbVZqT2pwallYQmhZMmwwZVY5dmRtVnlabXh2ZHpvNmFEVTJZemhrTWpCa09XVmxabU01TTJTQUFUbGpiM0psT2pwdmNITTZPbVoxYm1OMGFXOXVPanBHYms5dVkyVTZPbU5oYkd4ZmIyNWpaVG82YURZMlpEVTFNbU01TVRjeU1EazFOamlCQVU1amIzSmxPanBtYlhRNk9tNTFiVG82YVcxd09qbzhhVzF3YkNCamIzSmxPanBtYlhRNk9rUnBjM0JzWVhrZ1ptOXlJSFV6TWo0Nk9tWnRkRG82YUROa1pqTXdOMk5tT1dKaU1HWTFOakNDQVI5ZlgzZGlhVzVrWjJWdVgyRmtaRjkwYjE5emRHRmphMTl3YjJsdWRHVnlnd0VhWDE5eWRYTjBYMkZzYkc5algyVnljbTl5WDJoaGJtUnNaWEtFQVNwM1lYTnRYMkpwYm1SblpXNDZPblJvY205M1gzTjBjam82YURrNU9EaGxZV0kyTXpRNVpqSXlaVEtGQVRGM1lYTnRYMkpwYm1SblpXNDZPbDlmY25RNk9uUm9jbTkzWDI1MWJHdzZPbWhoTldFeU1UUTFNamsyTnpKaU5UaGxoZ0V5ZDJGemJWOWlhVzVrWjJWdU9qcGZYM0owT2pwaWIzSnliM2RmWm1GcGJEbzZhR1kyTkdSbU1USTBPRFl4WkRrd1kyYUhBVEprYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2tOb2RXNXJPanB6YVhwbE9qcG9ORGMzTVRneU1ERTVZMk5pTkRZNE40Z0JOR1JzYldGc2JHOWpPanBrYkcxaGJHeHZZem82UTJoMWJtczZPbkJwYm5WelpUbzZhRFE1WkRnelptVTBPRFpoT0dNME1qYUpBVGxrYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2xObFoyMWxiblE2T21selgyVjRkR1Z5YmpvNmFHTmlPVE16TWpJeE9UVmxabUpqWTJXS0FUbGtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPbE5sWjIxbGJuUTZPbk41YzE5bWJHRm5jem82YUdKaE1EbGtaakV3WmpSa01UbGtObVdMQVROaGJHeHZZem82WVd4c2IyTTZPbWhoYm1Sc1pWOWhiR3h2WTE5bGNuSnZjam82YURRMVlUY3hORGt3TUdReU9XSmxaaldNQVFoZlgzSm5YMjl2YlkwQktuZGhjMjFmWW1sdVpHZGxiam82ZEdoeWIzZGZkbUZzT2pwb1l6TXlPVFk0TkRkbE9EQTBNekExWm80QkMxOWZjbVJzWDJGc2JHOWpqd0U1Wkd4dFlXeHNiMk02T21Sc2JXRnNiRzlqT2pwRGFIVnVhem82Y0d4MWMxOXZabVp6WlhRNk9taGhNamd4WXpobU16ZGtaVGxqWWpZMWtBRTZaR3h0WVd4c2IyTTZPbVJzYldGc2JHOWpPanBEYUhWdWF6bzZiV2x1ZFhOZmIyWm1jMlYwT2pwb09UVTJZVFJsTW1Ga1pqTmxaV1pqWXBFQk5HUnNiV0ZzYkc5ak9qcGtiRzFoYkd4dll6bzZRMmgxYm1zNk9uUnZYMjFsYlRvNmFEazFOV0k1TmpOaE4yRTRNelF6TURHU0FUWmtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPa05vZFc1ck9qcG1jbTl0WDIxbGJUbzZhR1ZsTm1NeE9XSXlabVl3TWpoaU5XT1RBVFYzWVhOdFgySnBibVJuWlc0Nk9sOWZjblE2T20xaGJHeHZZMTltWVdsc2RYSmxPanBvWVdWbU1XTm1ORGd5TUdJellqQXpacFFCRFY5ZmNtUnNYMlJsWVd4c2IyT1ZBVFprYkcxaGJHeHZZem82Wkd4dFlXeHNiMk02T2xSeVpXVkRhSFZ1YXpvNmJtVjRkRG82YURFeE5XUmpaVGN6TXpObE5XWmpNbU9XQVRaa2JHMWhiR3h2WXpvNlpHeHRZV3hzYjJNNk9sUnlaV1ZEYUhWdWF6bzZjSEpsZGpvNmFEQTJaRFU0WVRnMU5UQmhaR1ppTXphWEFUNWpiM0psT2pwd1lXNXBZem82Y0dGdWFXTmZhVzVtYnpvNlVHRnVhV05KYm1adk9qcHRaWE56WVdkbE9qcG9NelkzTURKa00yUXdNRFJoTm1SbFpaZ0JQMk52Y21VNk9uQmhibWxqT2pwd1lXNXBZMTlwYm1adk9qcFFZVzVwWTBsdVptODZPbXh2WTJGMGFXOXVPanBvTm1ZMU5qZGtabUpsT0dOa09ESmhacGtCTVR4VUlHRnpJR052Y21VNk9tRnVlVG82UVc1NVBqbzZkSGx3WlY5cFpEbzZhR0ptWW1OaE5HWmlNelZsT1dKa05tU2FBVEU4VkNCaGN5QmpiM0psT2pwaGJuazZPa0Z1ZVQ0Nk9uUjVjR1ZmYVdRNk9taGxaakppTkRreVl6VmhNVGs1TVdZM213RW1jM1JrT2pwd2NtOWpaWE56T2pwaFltOXlkRG82YUdJd1pHUTFaRE0yT1RGa01UZ3dZMktjQVJKZlgzSjFjM1JmYzNSaGNuUmZjR0Z1YVdPZEFUeGtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPa05vZFc1ck9qcG1aVzVqWlhCdmMzUmZhR1ZoWkRvNmFEaG1PRE0xWlRCa1ltWXpObU5oWXpTZUFUZGtiRzFoYkd4dll6bzZaR3h0WVd4c2IyTTZPbFJ5WldWRGFIVnVhem82WTJoMWJtczZPbWd3TkRVM01qWTFNekpoTVdVd1l6aGtud0ZJUEdSc2JXRnNiRzlqT2pwemVYTTZPbE41YzNSbGJTQmhjeUJrYkcxaGJHeHZZem82UVd4c2IyTmhkRzl5UGpvNmNtVnRZWEE2T21neVptWXdNREEyTmpnME5tVmhPVEl4b0FGTVBHUnNiV0ZzYkc5ak9qcHplWE02T2xONWMzUmxiU0JoY3lCa2JHMWhiR3h2WXpvNlFXeHNiMk5oZEc5eVBqbzZabkpsWlY5d1lYSjBPanBvWlRCaE5tVm1NR013TVdJNU16UmpZcUVCUnp4a2JHMWhiR3h2WXpvNmMzbHpPanBUZVhOMFpXMGdZWE1nWkd4dFlXeHNiMk02T2tGc2JHOWpZWFJ2Y2o0Nk9tWnlaV1U2T21oaU5XRXdOelJrWkRNNU0yTmtPVEJob2dGVFBHUnNiV0ZzYkc5ak9qcHplWE02T2xONWMzUmxiU0JoY3lCa2JHMWhiR3h2WXpvNlFXeHNiMk5oZEc5eVBqbzZZMkZ1WDNKbGJHVmhjMlZmY0dGeWREbzZhR0poWkdOaE9XRmxaalEwTWpZeU0yU2pBVkk4Wkd4dFlXeHNiMk02T25ONWN6bzZVM2x6ZEdWdElHRnpJR1JzYldGc2JHOWpPanBCYkd4dlkyRjBiM0krT2pwaGJHeHZZMkYwWlhOZmVtVnliM002T21oalpqSXdNakV4TVdaalltRTBNRGhrcEFGTVBHUnNiV0ZzYkc5ak9qcHplWE02T2xONWMzUmxiU0JoY3lCa2JHMWhiR3h2WXpvNlFXeHNiMk5oZEc5eVBqbzZjR0ZuWlY5emFYcGxPanBvTW1NeU9XSm1PR0l6TVRVMk5tVTJNNlVCUDJoaGMyaGljbTkzYmpvNmNtRjNPanBuWlc1bGNtbGpPanBIY205MWNEbzZjM1JoZEdsalgyVnRjSFI1T2pwb05qSmtZakkyTmpNMU1tVTJaRGd6T2FZQk1UeFVJR0Z6SUdOdmNtVTZPbUZ1ZVRvNlFXNTVQam82ZEhsd1pWOXBaRG82YURVd09XRTRNbVl5T1RoaU1USXhZbU9uQVdsamIzSmxPanB3ZEhJNk9tUnliM0JmYVc1ZmNHeGhZMlU4Sm0xMWRDQnpkR1E2T21sdk9qcFhjbWwwWlRvNmQzSnBkR1ZmWm0xME9qcEJaR0Z3ZEdWeVBHRnNiRzlqT2pwMlpXTTZPbFpsWXp4MU9ENCtQam82YUdKaU1EVm1OREkzWXpObVlXRmpZV09vQVRkemRHUTZPbUZzYkc5ak9qcGtaV1poZFd4MFgyRnNiRzlqWDJWeWNtOXlYMmh2YjJzNk9taGpPRFUwTVdZM1l6RmxZek15WVdabHFRRXdZMjl5WlRvNmNIUnlPanBrY205d1gybHVYM0JzWVdObFBDWjFPRDQ2T21nNE9UUmhaVFkyTkdObE9UTTVNekprcWdGdlkyOXlaVG82Y0hSeU9qcGtjbTl3WDJsdVgzQnNZV05sUENaamIzSmxPanBwZEdWeU9qcGhaR0Z3ZEdWeWN6bzZZMjl3YVdWa09qcERiM0JwWldROFkyOXlaVG82YzJ4cFkyVTZPbWwwWlhJNk9rbDBaWEk4ZFRnK1BqNDZPbWhoWVRSbE1EQmpNVGcyWmpkaU1ERTBBUHVBZ0lBQUNYQnliMlIxWTJWeWN3SUliR0Z1WjNWaFoyVUJCRkoxYzNRQURIQnliMk5sYzNObFpDMWllUU1GY25WemRHTWRNUzQxTmk0eElDZzFPV1ZsWkRoaE1tRWdNakF5TVMweE1TMHdNU2tHZDJGc2NuVnpCakF1TVRrdU1BeDNZWE50TFdKcGJtUm5aVzRTTUM0eUxqYzRJQ2czWmpneU1HUmlOR0lwIik7CgogICAgICAgICAgICAgICAgICAgICAgdmFyIGQzc3RXYXNtID0gYXN5bmMgKCkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGluaXQod2FzbV9jb2RlKTsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cyQxOwogICAgICAgICAgICAgICAgICAgICAgfTsKCiAgLy8gQHRzLWlnbm9yZQ0KICBjb25zdCBmdXp6eUNsdXN0ZXIgPSBhc3luYyBmdW5jdGlvbiBmdXp6eUNsdXN0ZXIoZGF0YSwgZGltZW5zaW9ucywgcGFyYW1zKSB7DQogICAgICBjb25zdCBkM3N0ID0gYXdhaXQgZDNzdFdhc20oKTsNCiAgICAgIGNvbnN0IGNsdXN0ZXJpbmcgPSBuZXcgZDNzdC5GdXp6eUNsdXN0ZXIocGFyYW1zLmVwc01pbiwgcGFyYW1zLmVwc01heCwgcGFyYW1zLnB0c01pbiwgcGFyYW1zLnB0c01heCk7DQogICAgICBjb25zdCBkaW1lbnNpb25Db3VudCA9IGRpbWVuc2lvbnMubGVuZ3RoOw0KICAgICAgY29uc3QgcGFja2VkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGggKiBkaW1lbnNpb25Db3VudCk7DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsNCiAgICAgICAgICBsZXQgb2Zmc2V0ID0gaSAqIGRpbWVuc2lvbkNvdW50Ow0KICAgICAgICAgIGZvciAoY29uc3QgZGltIG9mIGRpbWVuc2lvbnMpIHsNCiAgICAgICAgICAgICAgcGFja2VkRGF0YVtvZmZzZXRdID0gZGltLm5vcm1hbGl6ZShkYXRhW2ldW2RpbS5uYW1lXSk7DQogICAgICAgICAgICAgIG9mZnNldCsrOw0KICAgICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGNvbnN0IHJlc3VsdCA9IGNsdXN0ZXJpbmcuY2x1c3RlcihuZXcgVWludDhBcnJheShwYWNrZWREYXRhLmJ1ZmZlciksIGRpbWVuc2lvbkNvdW50KTsNCiAgICAgIGNvbnN0IHBhY2tlZENsdXN0ZXJzID0gbmV3IFVpbnQxNkFycmF5KHJlc3VsdC5idWZmZXIpOw0KICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXTsNCiAgICAgIGNvbnN0IG5vaXNlID0gW107DQogICAgICBsZXQgY3Vyc29yID0gMDsNCiAgICAgIHdoaWxlIChjdXJzb3IgPCBwYWNrZWRDbHVzdGVycy5sZW5ndGgpIHsNCiAgICAgICAgICBjb25zdCBwb2ludENvdW50ID0gcGFja2VkQ2x1c3RlcnNbY3Vyc29yKytdOw0KICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBbXTsNCiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkrKykgew0KICAgICAgICAgICAgICBjb25zdCBpZCA9IHBhY2tlZENsdXN0ZXJzW2N1cnNvcisrXTsNCiAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBpZCA+PiAxNDsNCiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZCAmIDB4M0ZGRjsNCiAgICAgICAgICAgICAgcGFja2VkQ2x1c3RlcnNbY3Vyc29yKytdOw0KICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IDIpIHsNCiAgICAgICAgICAgICAgICAgIC8vIG5vaXNlIGdldHMgdG8gYmUgaW4gaXRzIG93biBjbHVzdGVyDQogICAgICAgICAgICAgICAgICBub2lzZS5wdXNoKGluZGV4KTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICAgIGNsdXN0ZXIucHVzaChpbmRleCk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID4gMCkgew0KICAgICAgICAgICAgICBjbHVzdGVycy5wdXNoKGNsdXN0ZXIpOw0KICAgICAgICAgIH0NCiAgICAgIH0NCiAgICAgIGlmIChub2lzZS5sZW5ndGggPiAwKSB7DQogICAgICAgICAgY2x1c3RlcnMucHVzaChub2lzZSk7DQogICAgICB9DQogICAgICAvL2NvbnN0IGNvdW50cyA9IGNsdXN0ZXJzLm1hcChjID0+IGMubGVuZ3RoKS5qb2luKCIsICIpOw0KICAgICAgLy9jb25zb2xlLmluZm8oYEZvdW5kICR7Y2x1c3RlcnMubGVuZ3RofSBjbHVzdGVyczogJHtjb3VudHN9YCk7DQogICAgICAvL2NvbnNvbGUuaW5mbyhgJHtub2lzZS5sZW5ndGh9IHBvaW50cyBpbiBub2lzZSBjbHVzdGVyLmApOw0KICAgICAgcmV0dXJuIGNsdXN0ZXJzOw0KICB9OwoKICAvKiogQ3JlYXRlcyBhIHBvbHlsaW5lIGZvciBlYWNoIGNsdXN0ZXIgdGhhdCBhcHByb3hpbWF0ZXMgdGhlIG1vdGlvbiBvZiBhbGwgb2YgaXRzIHBvaW50cy4gKi8NCiAgZnVuY3Rpb24gY2x1c3RlcnNUb1BvbHlsaW5lcyhkYXRhLCBjbHVzdGVycywgdmlld3MpIHsNCiAgICAgIGNvbnN0IHBvbHlsaW5lcyA9IFtdOw0KICAgICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIGNsdXN0ZXJzKSB7DQogICAgICAgICAgY29uc3QgcG9seWxpbmUgPSBbXTsNCiAgICAgICAgICBmb3IgKGNvbnN0IHZpZXcgb2Ygdmlld3MpIHsNCiAgICAgICAgICAgICAgbGV0IHhTdW0gPSAwOw0KICAgICAgICAgICAgICBsZXQgeVN1bSA9IDA7DQogICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnRJZCBvZiBjbHVzdGVyKSB7DQogICAgICAgICAgICAgICAgICB4U3VtICs9IHZpZXcuZ2V0WChkYXRhW3BvaW50SWRdKTsNCiAgICAgICAgICAgICAgICAgIHlTdW0gKz0gdmlldy5nZXRZKGRhdGFbcG9pbnRJZF0pOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIHBvbHlsaW5lLnB1c2goZnJvbVZhbHVlcyh4U3VtIC8gY2x1c3Rlci5sZW5ndGgsIHlTdW0gLyBjbHVzdGVyLmxlbmd0aCkpOw0KICAgICAgICAgIH0NCiAgICAgICAgICBwb2x5bGluZXMucHVzaChwb2x5bGluZSk7DQogICAgICB9DQogICAgICByZXR1cm4gcG9seWxpbmVzOw0KICB9DQogIC8qKiBDcmVhdGVzIGEgUGF0aEd1aWRlIGZyb20gYSBwb2x5bGluZS4gKi8NCiAgZnVuY3Rpb24gcG9seWxpbmVUb0NsdXN0ZXJHdWlkZShwb2x5bGluZSwgcGFyYW1zKSB7DQogICAgICB2YXIgX2E7DQogICAgICBjb25zdCBwb2ludFRhbmdlbnRzID0gW107DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlsaW5lLmxlbmd0aDsgaSsrKSB7DQogICAgICAgICAgY29uc3QgcHJldlBvaW50ID0gcG9seWxpbmVbaSAtIDFdOw0KICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9seWxpbmVbaV07DQogICAgICAgICAgY29uc3QgbmV4dFBvaW50ID0gcG9seWxpbmVbaSArIDFdOw0KICAgICAgICAgIGxldCB0YW5nZW50ID0gY3JlYXRlKCk7DQogICAgICAgICAgaWYgKHByZXZQb2ludCAmJiBuZXh0UG9pbnQpIHsNCiAgICAgICAgICAgICAgY29uc3QgdGFuZ2VudFByZXYgPSBzdWIoY3JlYXRlKCksIHBvaW50LCBwcmV2UG9pbnQpOw0KICAgICAgICAgICAgICBjb25zdCB0YW5nZW50TmV4dCA9IHN1YihjcmVhdGUoKSwgbmV4dFBvaW50LCBwb2ludCk7DQogICAgICAgICAgICAgIG5vcm1hbGl6ZSh0YW5nZW50UHJldiwgdGFuZ2VudFByZXYpOw0KICAgICAgICAgICAgICBub3JtYWxpemUodGFuZ2VudE5leHQsIHRhbmdlbnROZXh0KTsNCiAgICAgICAgICAgICAgYWRkKHRhbmdlbnQsIHRhbmdlbnRQcmV2LCB0YW5nZW50TmV4dCk7DQogICAgICAgICAgICAgIG5vcm1hbGl6ZSh0YW5nZW50LCB0YW5nZW50KTsNCiAgICAgICAgICB9DQogICAgICAgICAgcG9pbnRUYW5nZW50cy5wdXNoKHRhbmdlbnQpOw0KICAgICAgfQ0KICAgICAgY29uc3QgYnVuZGxpbmdTdHJlbmd0aCA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5idW5kbGluZ1N0cmVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwOw0KICAgICAgY29uc3QgZ3VpZGVzID0gW107DQogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlsaW5lLmxlbmd0aCAtIDE7IGkrKykgew0KICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9seWxpbmVbaV07DQogICAgICAgICAgY29uc3QgbmV4dFBvaW50ID0gcG9seWxpbmVbaSArIDFdOw0KICAgICAgICAgIGNvbnN0IHBvaW50VGFuID0gcG9pbnRUYW5nZW50c1tpXTsNCiAgICAgICAgICBjb25zdCBuZXh0VGFuID0gcG9pbnRUYW5nZW50c1tpICsgMV07DQogICAgICAgICAgY29uc3QgYnVuZGxpbmdQb2ludCA9IGNyZWF0ZSgpOw0KICAgICAgICAgIGxlcnAoYnVuZGxpbmdQb2ludCwgcG9pbnQsIG5leHRQb2ludCwgMC41KTsNCiAgICAgICAgICBjb25zdCBidW5kbGluZ1BvaW50cyA9IFtdOw0KICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVuZGxpbmdTdHJlbmd0aDsgaSsrKSB7DQogICAgICAgICAgICAgIGJ1bmRsaW5nUG9pbnRzLnB1c2goYnVuZGxpbmdQb2ludCk7DQogICAgICAgICAgfQ0KICAgICAgICAgIGd1aWRlcy5wdXNoKHsNCiAgICAgICAgICAgICAgaW5UYW5nZW50OiBwb2ludFRhbiwNCiAgICAgICAgICAgICAgb3V0VGFuZ2VudDogbmV4dFRhbiwNCiAgICAgICAgICAgICAgYnVuZGxpbmdQb2ludHMNCiAgICAgICAgICB9KTsNCiAgICAgIH0NCiAgICAgIHJldHVybiBndWlkZXM7DQogIH0NCiAgLyoqIENyZWF0ZXMgYSBQYXRoU2VnbWVudCBmcm9tIGEgYsOpemllciBjdXJ2ZSBieSBhZGRpbmcgYW4gYXJjIGxlbmd0aCBMVVQuICovDQogIGZ1bmN0aW9uIGNyZWF0ZVBhdGhTZWdtZW50KGN1cnZlKSB7DQogICAgICBjb25zdCBzdGFydFBvaW50ID0gYmV6aWVyRXZhbChjdXJ2ZSwgMCk7DQogICAgICBsZXQgc3RlcExlbmd0aCA9IDE7DQogICAgICBsZXQgdFN0ZXAgPSAxOw0KICAgICAgd2hpbGUgKE51bWJlci5pc0Zpbml0ZShzdGVwTGVuZ3RoKSAmJiBzdGVwTGVuZ3RoID4gMC4wMSkgew0KICAgICAgICAgIHRTdGVwIC89IDI7DQogICAgICAgICAgY29uc3QgcG9pbnQgPSBiZXppZXJFdmFsKGN1cnZlLCB0U3RlcCk7DQogICAgICAgICAgc3RlcExlbmd0aCA9IE1hdGgubWF4KDAuMDEsIGRpc3RhbmNlKHN0YXJ0UG9pbnQsIHBvaW50KSk7DQogICAgICB9DQogICAgICAvLyB0IC0+IGFyYyBsZW5ndGgNCiAgICAgIGNvbnN0IGx1dCA9IFtdOw0KICAgICAgbGV0IHRvdGFsTGVuID0gMDsNCiAgICAgIGxldCBwcmV2UG9pbnQgPSBzdGFydFBvaW50Ow0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSArPSBzdGVwTGVuZ3RoKSB7DQogICAgICAgICAgY29uc3QgcG9pbnQgPSBiZXppZXJFdmFsKGN1cnZlLCBpKTsNCiAgICAgICAgICB0b3RhbExlbiArPSBkaXN0YW5jZShwcmV2UG9pbnQsIHBvaW50KTsNCiAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDsNCiAgICAgICAgICBsdXQucHVzaCh0b3RhbExlbik7DQogICAgICB9DQogICAgICAvLyByZXRpbWUgZGF0YSB3aWxsIGJlIGFzc2lnbmVkIGxhdGVyIChzZWUgYmVsb3cpDQogICAgICBjb25zdCByZXRpbWUgPSB7IGluZGV4OiAwLCB0b3RhbDogMCwgY2x1c3RlcnM6IFtdIH07DQogICAgICByZXR1cm4geyBjdXJ2ZSwgbHV0LCByZXRpbWUgfTsNCiAgfQ0KICAvKiogQ3JlYXRlcyBhIHBhdGggZnJvbSBhIHBvaW50IGFuZCB0aGUgUGF0aEd1aWRlIG9mIGl0cyBjbHVzdGVyLiAqLw0KICBmdW5jdGlvbiBjbHVzdGVyR3VpZGVUb1BvaW50UGF0aChwb2ludCwgZ3VpZGVTZWdtZW50cywgdmlld3MsIHBhcmFtcywgcmV0aW1lRGF0YSkgew0KICAgICAgdmFyIF9hOw0KICAgICAgY29uc3QgbG9vc2VJbnRlcm1lZGlhdGVzID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmxvb3NlSW50ZXJtZWRpYXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7DQogICAgICBjb25zdCBwYXRocyA9IFtdOw0KICAgICAgbGV0IHBhdGggPSBbXTsNCiAgICAgIGxldCBjdXJ2ZSA9IFtdOw0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGggLSAxOyBpKyspIHsNCiAgICAgICAgICBjb25zdCB2aWV3ID0gdmlld3NbaV07DQogICAgICAgICAgY29uc3QgbmV4dFZpZXcgPSB2aWV3c1tpICsgMV07DQogICAgICAgICAgY29uc3QgZ3VpZGUgPSBndWlkZVNlZ21lbnRzW2ldOw0KICAgICAgICAgIGNvbnN0IHZpZXdQb3MgPSBmcm9tVmFsdWVzKHZpZXcuZ2V0WChwb2ludCksIHZpZXcuZ2V0WShwb2ludCkpOw0KICAgICAgICAgIGNvbnN0IG5leHRQb3MgPSBmcm9tVmFsdWVzKG5leHRWaWV3LmdldFgocG9pbnQpLCBuZXh0Vmlldy5nZXRZKHBvaW50KSk7DQogICAgICAgICAgY29uc3QgZGlzdGFuY2UkMSA9IGRpc3RhbmNlKHZpZXdQb3MsIG5leHRQb3MpOw0KICAgICAgICAgIGlmICghbG9vc2VJbnRlcm1lZGlhdGVzKSB7DQogICAgICAgICAgICAgIHBhdGggPSBbXTsNCiAgICAgICAgICAgICAgY3VydmUgPSBbXTsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gVE9ETzogbWFrZSB0aGlzIGEgY29uZmlnIHBhcmFtZXRlcg0KICAgICAgICAgIGNvbnN0IHRhbmdlbnRMZW5ndGggPSBkaXN0YW5jZSQxIC8gMjsNCiAgICAgICAgICBjdXJ2ZS5wdXNoKHZpZXdQb3MpOw0KICAgICAgICAgIGN1cnZlLnB1c2goYWRkKGNyZWF0ZSgpLCB2aWV3UG9zLCBzY2FsZShjcmVhdGUoKSwgZ3VpZGUuaW5UYW5nZW50LCB0YW5nZW50TGVuZ3RoKSkpOw0KICAgICAgICAgIGZvciAoY29uc3QgYnVuZGxpbmdQb2ludCBvZiBndWlkZS5idW5kbGluZ1BvaW50cykgew0KICAgICAgICAgICAgICBjdXJ2ZS5wdXNoKGJ1bmRsaW5nUG9pbnQpOw0KICAgICAgICAgIH0NCiAgICAgICAgICBjdXJ2ZS5wdXNoKGFkZChjcmVhdGUoKSwgbmV4dFBvcywgc2NhbGUoY3JlYXRlKCksIGd1aWRlLm91dFRhbmdlbnQsIC10YW5nZW50TGVuZ3RoKSkpOw0KICAgICAgICAgIGN1cnZlLnB1c2gobmV4dFBvcyk7DQogICAgICAgICAgaWYgKCFsb29zZUludGVybWVkaWF0ZXMpIHsNCiAgICAgICAgICAgICAgcGF0aC5wdXNoKGNyZWF0ZVBhdGhTZWdtZW50KGN1cnZlKSk7DQogICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7DQogICAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgaWYgKGxvb3NlSW50ZXJtZWRpYXRlcykgew0KICAgICAgICAgIHBhdGgucHVzaChjcmVhdGVQYXRoU2VnbWVudChjdXJ2ZSkpOw0KICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7DQogICAgICB9DQogICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHsNCiAgICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkgew0KICAgICAgICAgICAgICBzZWdtZW50LnJldGltZSA9IHJldGltZURhdGE7DQogICAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIHBhdGhzOw0KICB9DQogIGFzeW5jIGZ1bmN0aW9uIGluaXRTcGxpbmUoeyBkYXRhLCB2aWV3cywgcGFyYW1zIH0pIHsNCiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBbXTsNCiAgICAgIGZvciAoY29uc3QgdmlldyBvZiB2aWV3cykgew0KICAgICAgICAgIGlmICghZGltZW5zaW9ucy5pbmNsdWRlcyh2aWV3LngpKQ0KICAgICAgICAgICAgICBkaW1lbnNpb25zLnB1c2godmlldy54KTsNCiAgICAgICAgICBpZiAoIWRpbWVuc2lvbnMuaW5jbHVkZXModmlldy55KSkNCiAgICAgICAgICAgICAgZGltZW5zaW9ucy5wdXNoKHZpZXcueSk7DQogICAgICB9DQogICAgICBsZXQgY2x1c3RlcnM7DQogICAgICBpZiAocGFyYW1zLmNsdXN0ZXJpbmcpIHsNCiAgICAgICAgICBjbHVzdGVycyA9IGF3YWl0IGZ1enp5Q2x1c3RlcihkYXRhLCBkaW1lbnNpb25zLCBwYXJhbXMuY2x1c3RlcmluZyk7DQogICAgICB9DQogICAgICBlbHNlIHsNCiAgICAgICAgICBjbHVzdGVycyA9IFtdOw0KICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykNCiAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaChbaV0pOyAvLyBhIGNsdXN0ZXIgZm9yIGV2ZXJ5IHBvaW50DQogICAgICB9DQogICAgICBjb25zdCBwb2x5bGluZXMgPSBjbHVzdGVyc1RvUG9seWxpbmVzKGRhdGEsIGNsdXN0ZXJzLCB2aWV3cyk7DQogICAgICBjb25zdCBjbHVzdGVyR3VpZGVzID0gcG9seWxpbmVzLm1hcChwbGluZSA9PiBwb2x5bGluZVRvQ2x1c3Rlckd1aWRlKHBsaW5lLCBwYXJhbXMpKTsNCiAgICAgIGNvbnN0IGNsdXN0ZXJJbmZvID0gW107DQogICAgICBmb3IgKGNvbnN0IGNsdXN0ZXIgb2YgY2x1c3RlcnMpIHsNCiAgICAgICAgICBjbHVzdGVySW5mby5wdXNoKHsgcG9pbnRzOiBjbHVzdGVyLmxlbmd0aCB9KTsNCiAgICAgIH0NCiAgICAgIGNvbnN0IHBvaW50UGF0aHMgPSBuZXcgTWFwKCk7DQogICAgICBmb3IgKGxldCBjbHVzdGVySWQgPSAwOyBjbHVzdGVySWQgPCBjbHVzdGVycy5sZW5ndGg7IGNsdXN0ZXJJZCsrKSB7DQogICAgICAgICAgY29uc3QgY2x1c3Rlckd1aWRlID0gY2x1c3Rlckd1aWRlc1tjbHVzdGVySWRdOw0KICAgICAgICAgIGNvbnN0IHJldGltZSA9IHsNCiAgICAgICAgICAgICAgaW5kZXg6IGNsdXN0ZXJJZCwNCiAgICAgICAgICAgICAgdG90YWw6IGNsdXN0ZXJzLmxlbmd0aCwNCiAgICAgICAgICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJJbmZvLA0KICAgICAgICAgIH07DQogICAgICAgICAgZm9yIChjb25zdCBpdGVtSWQgb2YgY2x1c3RlcnNbY2x1c3RlcklkXSkgew0KICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IGRhdGFbaXRlbUlkXTsNCiAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGNsdXN0ZXJHdWlkZVRvUG9pbnRQYXRoKHBvaW50LCBjbHVzdGVyR3VpZGUsIHZpZXdzLCBwYXJhbXMsIHJldGltZSk7DQogICAgICAgICAgICAgIHBvaW50UGF0aHMuc2V0KGl0ZW1JZCwgcGF0aCk7DQogICAgICAgICAgfQ0KICAgICAgfQ0KICAgICAgcmV0dXJuIHsgY2x1c3Rlckd1aWRlcywgcG9pbnRQYXRocyB9Ow0KICB9DQogIGFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBlID0+IHsNCiAgICAgIGNvbnN0IGlucHV0ID0gZS5kYXRhOw0KICAgICAgLy8gaGF2aW5nIGJlZW4gc2VudCBvdmVyIGEgY2hhbm5lbCwgb2JqZWN0cyBkb24ndCBoYXZlIHRoZWlyIHByb3RvdHlwZSBhbnltb3JlIQ0KICAgICAgLy8gaGVuY2UsIHdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlbQ0KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC52aWV3cy5sZW5ndGg7IGkrKykgew0KICAgICAgICAgIGNvbnN0IHZpZXcgPSBpbnB1dC52aWV3c1tpXTsNCiAgICAgICAgICBjb25zdCB4ID0gbmV3IERpbWVuc2lvbih2aWV3LngubmFtZSwgdmlldy54LmRvbWFpbiwgdmlldy54Lm1hcHBpbmcpOw0KICAgICAgICAgIGNvbnN0IHkgPSBuZXcgRGltZW5zaW9uKHZpZXcueS5uYW1lLCB2aWV3LnkuZG9tYWluLCB2aWV3LnkubWFwcGluZyk7DQogICAgICAgICAgaW5wdXQudmlld3NbaV0gPSBuZXcgU2NhdHRlclZpZXcoeCwgeSk7DQogICAgICB9DQogICAgICBpbml0U3BsaW5lKGUuZGF0YSkudGhlbihyZXN1bHQgPT4gew0KICAgICAgICAgIHBvc3RNZXNzYWdlKFt0cnVlLCByZXN1bHRdKTsNCiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHsNCiAgICAgICAgICBwb3N0TWVzc2FnZShbZmFsc2UsIGVycm9yXSk7DQogICAgICB9KTsNCiAgfSk7Cgp9KSgpOwoK', null, false);
    /* eslint-enable */

    const retimeIdentity = (t) => t;
    /** Legacy retime function used when timeOffset is true */
    const retimeLegacyTimeOffset = (t, data) => {
        const timeOffset = data.index / data.total - 0.5;
        if (timeOffset > 0) {
            t = Math.min(1, Math.max(0, (t - timeOffset) / (1 - timeOffset)));
        }
        else if (timeOffset < 0) {
            t = Math.min(1, Math.max(0, t / (1 + timeOffset)));
        }
        return t;
    };
    /** Retime function that animates every cluster in sequence with no overlapping animation. */
    const retimeEqualNonOverlappingCascade = (t, data) => {
        t = t * data.total - data.index;
        return Math.min(1, Math.max(0, t));
    };
    /**
     * Retime function that animates every cluster in sequence with no overlapping animation.
     * The duration of the animation is proportional to the cluster size.
     */
    const retimeProportionalNonOverlappingCascade = (t, data) => {
        const clusterPoints = data.clusters.map(c => c.points);
        const totalPoints = clusterPoints.reduce((a, b) => a + b, 0);
        const pointsIndexMin = clusterPoints.slice(0, data.index).reduce((a, b) => a + b, 0);
        t = ((t * totalPoints) - pointsIndexMin) / clusterPoints[data.index];
        return Math.min(1, Math.max(0, t));
    };

    // Spline transition
    /**
     * A spline transition animates points on splines.
     * Points are clustered in an attempt to minimize confusing paths by having points that are adjacent
     * move similarly.
     */
    class SplineTransition {
        constructor(views, params) {
            this.views = views;
            this.params = params;
            this.clusterGuides = [];
            this.pointPaths = new Map();
            this.hasMeaningfulIntermediates = !this.params.looseIntermediates;
            this.isReady = false;
        }
        async prepare() {
            var _a, _b, _c;
            const worker = new WorkerFactory();
            worker.postMessage({
                data: this.params.data,
                views: this.views,
                params: {
                    clustering: (_a = this.params) === null || _a === void 0 ? void 0 : _a.clustering,
                    looseIntermediates: (_b = this.params) === null || _b === void 0 ? void 0 : _b.looseIntermediates,
                    bundlingStrength: (_c = this.params) === null || _c === void 0 ? void 0 : _c.bundlingStrength,
                }
            });
            const [ok, result] = await new Promise(resolve => {
                const callback = (e) => {
                    resolve(e.data);
                    worker.removeEventListener('message', callback);
                };
                worker.addEventListener('message', callback);
            });
            if (!ok)
                throw result;
            this.clusterGuides = result.clusterGuides;
            this.pointPaths = result.pointPaths;
            this.isReady = true;
        }
        ease(t) {
            if (this.params.ease) {
                return this.params.ease(t);
            }
            return d3Ease.easeQuad(t);
        }
        getPointPos(t, point) {
            // looseIntermediates creates a single curve
            if (!this.params.looseIntermediates)
                t *= this.views.length - 1;
            const pathSegments = this.pointPaths.get(this.params.data.indexOf(point));
            if (pathSegments === undefined)
                throw new Error('unknown point passed to spline transition');
            const segmentIndex = Math.min(Math.floor(t), pathSegments.length - 1);
            const currentPath = pathSegments[segmentIndex];
            let easing = (t) => t;
            // if we're animating over multiple views, we'll need easing because the path segments
            // are different lengths and thus different speeds
            if (!this.params.looseIntermediates && this.views.length > 2) {
                easing = (t) => this.ease(t);
            }
            let retimeFn = retimeIdentity;
            if (this.params.retime)
                retimeFn = this.params.retime;
            else if (this.params.timeOffset)
                retimeFn = retimeLegacyTimeOffset;
            return pathEval(currentPath, t - segmentIndex, easing, retimeFn);
        }
        getX(t, point) {
            return this.getPointPos(t, point)[0];
        }
        getY(t, point) {
            return this.getPointPos(t, point)[1];
        }
        drawDebug(node, mapPos) {
            for (const path of this.pointPaths.values()) {
                let d = [];
                for (const segment of path) {
                    for (const curve of segment) {
                        d.push(`M ${mapPos(curve.curve[0]).join(',')}`);
                        // svg doesn't support higher order curves
                        for (let i = 1; i <= 50; i++) {
                            const pos = bezierEval(curve.curve, i / 50);
                            d.push(`L ${mapPos(pos).join(',')}`);
                        }
                    }
                }
                const pathNode = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathNode.setAttribute('d', d.join(' '));
                pathNode.setAttribute('fill', 'none');
                pathNode.setAttribute('stroke', '#' + ('000000' + (Math.random() * 0xFFFFFF).toString(16)).substr(-6));
                node.appendChild(pathNode);
            }
        }
    }
    SplineTransition.requiresCommonDimensions = false;
    SplineTransition.canSwapDimensions = true;
    SplineTransition.params = {
        clustering: {
            type: 'group',
            nullable: true,
            contents: {
                epsMin: {
                    type: 'number',
                    domain: [0, 1],
                    default: 0.1,
                    round: false
                },
                ptsMin: {
                    type: 'number',
                    domain: [0, 100],
                    default: 1,
                    round: false
                },
                epsMax: {
                    type: 'derived',
                    derive: (params) => params.clustering.epsMin
                },
                ptsMax: {
                    type: 'derived',
                    derive: (params) => params.clustering.ptsMin
                }
            }
        },
        looseIntermediates: {
            type: 'bool',
            default: false
        },
        bundlingStrength: {
            shouldShow: (params) => !!params.clustering,
            type: 'number',
            domain: [0, 10],
            default: 0,
            round: true
        },
        ease: {
            type: 'enum',
            variants: [
                { label: 'linear', value: (t) => t },
                { label: 'quad', value: d3Ease.easeQuad },
                { label: 'cubic', value: d3Ease.easeCubic },
                { label: 'exp', value: d3Ease.easeExp }
            ],
            default: 1
        },
        timeOffset: {
            shouldShow: (params) => !!params.clustering && !params.retime,
            type: 'bool',
            default: false
        },
        retime: {
            shouldShow: (params) => !!params.clustering && !params.timeOffset,
            type: 'enum',
            variants: [
                { label: 'identity', value: null },
                { label: 'cascade', value: retimeEqualNonOverlappingCascade },
                { label: 'proportional cascade', value: retimeProportionalNonOverlappingCascade }
            ],
            default: 0,
        },
    };
    /** Finds the index where the given element would be sorted into the array. */
    function binarySearch(arr, toFind) {
        let low = 0;
        let high = arr.length - 1;
        while (high - low > 1) {
            const avg = Math.floor((high + low) / 2);
            const sample = arr[avg];
            if (sample > toFind) {
                high = avg;
            }
            else {
                low = avg;
            }
        }
        return [low, high];
    }
    /** Evaluates a point path (polybzier) for the given time t. */
    function pathEval(path, t, easing, retime) {
        t *= path.length;
        const curveIndex = Math.min(Math.floor(t), path.length - 1);
        const curve = path[curveIndex];
        let offsetTime = t - curveIndex;
        offsetTime = retime(offsetTime, curve.retime);
        offsetTime = easing(offsetTime);
        // use arc length LUT
        const targetLen = offsetTime * curve.lut[curve.lut.length - 1];
        const [lutDownIdx, lutUpIdx] = binarySearch(curve.lut, targetLen);
        const lutDownT = lutDownIdx / (curve.lut.length - 1);
        const lutUpT = lutUpIdx / (curve.lut.length - 1);
        const lutDownLen = curve.lut[lutDownIdx];
        const lutUpLen = curve.lut[lutUpIdx];
        let curveT;
        if (lutDownLen === lutUpLen) {
            curveT = lutDownT;
        }
        else {
            curveT = lutDownT === lutUpT
                ? lutDownT
                : lutDownT + (lutUpT - lutDownT) * ((targetLen - lutDownLen) / (lutUpLen - lutDownLen));
        }
        return bezierEval(curve.curve, curveT);
    }

    var sTransitions = /*#__PURE__*/Object.freeze({
        __proto__: null,
        util: index,
        RotationTransition: RotationTransition,
        SingleRotationTransition: SingleRotationTransition,
        StraightTransition: StraightTransition,
        retimeIdentity: retimeIdentity,
        retimeLegacyTimeOffset: retimeLegacyTimeOffset,
        retimeEqualNonOverlappingCascade: retimeEqualNonOverlappingCascade,
        retimeProportionalNonOverlappingCascade: retimeProportionalNonOverlappingCascade,
        SplineTransition: SplineTransition
    });

    var DimensionMappingType;
    (function (DimensionMappingType) {
        DimensionMappingType["Linear"] = "linear";
        DimensionMappingType["Log"] = "log";
    })(DimensionMappingType || (DimensionMappingType = {}));
    const mappings = {
        [DimensionMappingType.Linear]: {
            toNormalized([min, max], value) {
                return (value - min) / (max - min);
            },
            toDomain([min, max], value) {
                return min + value * (max - min);
            }
        },
        [DimensionMappingType.Log]: {
            toNormalized([min, max], value) {
                const a = value - min;
                const b = max - min;
                return Math.log(a + 1) / Math.log(b + 1);
            },
            toDomain([min, max], value) {
                value = value * Math.log(max - min + 1);
                return min + Math.exp(value) - 1;
            }
        }
    };
    /**
     * A data dimension.
     *
     * In general, dimensions are assumed to be usable as a dimension in euclidean space.
     */
    class Dimension {
        constructor(name, domain, mapping = Dimension.Linear) {
            this.name = name;
            this.domain = domain;
            this.mapping = mapping;
        }
        /** Normalizes a value from this dimension's domain to 0..1.  */
        normalize(value) {
            return mappings[this.mapping].toNormalized(this.domain, value);
        }
        /** Expands a normalized value [0..1] to a value in the regular domain range. */
        expand(value) {
            return mappings[this.mapping].toDomain(this.domain, value);
        }
        /** Returns true if this object equals the other object. */
        eq(other) {
            return this.name === other.name && this.domain[0] === other.domain[0] && this.domain[1] === other.domain[1];
        }
        /**
         * Creates a new dimension from the given data.
         *
         * @param key the key in the DataPoints that contains this dimension's data
         * @param data the data with which to calculate the domain
         * @param padding additional padding (multiplicative: the domain will be scaled by padding + 1)
         */
        static fromData(key, data, padding = 0) {
            let min = Infinity;
            let max = -Infinity;
            for (const point of data) {
                const value = point[key];
                if (value < min)
                    min = value;
                if (value > max)
                    max = value;
            }
            if (!Number.isFinite(min))
                min = 0;
            if (!Number.isFinite(max))
                max = 0;
            if (padding) {
                const range = max - min;
                min -= range * padding / 2;
                max += range * padding / 2;
            }
            return new Dimension(key, [min, max]);
        }
    }
    Dimension.Linear = DimensionMappingType.Linear;
    Dimension.Log = DimensionMappingType.Log;

    var sData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get DimensionMappingType () { return DimensionMappingType; },
        Dimension: Dimension
    });

    /**
     * Represents a view of two data dimensions as a scatter plot.
     */
    class ScatterView {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        /** Returns the normalized X position of a point (in 0..1). */
        getX(point) {
            return this.x.normalize(point[this.x.name]);
        }
        /** Returns the normalized Y position of a point (in 0..1). */
        getY(point) {
            return this.y.normalize(point[this.y.name]);
        }
        toString() {
            return `ScatterView(x: ${this.x.name.toString()}, y: ${this.y.name.toString()})`;
        }
        /**
        * Checks whether this view can be transitioned to the given view with the given transition.
        * If not, this function will throw an error.
        */
        validateTransitionTo(view, withType) {
            const transType = withType;
            if (transType.requiresCommonDimensions) {
                if (!this.x.eq(view.x) && !this.x.eq(view.y) && !this.y.eq(view.x) && !this.y.eq(view.y)) {
                    throw new Error(`cannot transitions between view ${this.toString()} and ${view.toString()} with ${transType.name}: no common dimensions`);
                }
            }
            if (!transType.canSwapDimensions) {
                if (this.x.eq(view.y) || this.y.eq(view.x)) {
                    throw new Error(`cannot transitions between view ${this.toString()} and ${view.toString()} with ${transType.name}: swapping is not supported`);
                }
            }
        }
        /**
         * Transitions this view with the given transition type and parameters to the last view across
         * all intermediate views.
         *
         * @param withType the transition type
         * @param params parameters for the transition
         * @param views intermediate views and a final view. The final view is required
         */
        transitionTo(withType, params, ...views) {
            if (!views.length)
                throw new Error('cannot transition to nothing');
            const transType = withType;
            const transitionViews = [this, ...views];
            for (let i = 0; i < transitionViews.length - 1; i++) {
                transitionViews[i].validateTransitionTo(transitionViews[i + 1], transType);
            }
            return new transType(transitionViews, params);
        }
    }

    var sView = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ScatterView: ScatterView
    });

    var domain;

    // This constructor is used to store event handlers. Instantiating this is
    // faster than explicitly calling `Object.create(null)` to get a "clean" empty
    // object (tested with v8 v4.9).
    function EventHandlers() {}
    EventHandlers.prototype = Object.create(null);

    function EventEmitter() {
      EventEmitter.init.call(this);
    }

    // nodejs oddity
    // require('events') === require('events').EventEmitter
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.usingDomains = false;

    EventEmitter.prototype.domain = undefined;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;

    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        // if there is an active domain, then attach to it.
        if (domain.active ) ;
      }

      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };

    function $getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };

    // These standalone emit* functions are used to optimize calling of event
    // handlers for fast cases because emit() itself often has a variable number of
    // arguments and can be deoptimized because of that. These functions always have
    // the same number of arguments and thus do not get deoptimized, so the code
    // inside them can execute faster.
    function emitNone(handler, isFn, self) {
      if (isFn)
        handler.call(self);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self);
      }
    }
    function emitOne(handler, isFn, self, arg1) {
      if (isFn)
        handler.call(self, arg1);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1);
      }
    }
    function emitTwo(handler, isFn, self, arg1, arg2) {
      if (isFn)
        handler.call(self, arg1, arg2);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2);
      }
    }
    function emitThree(handler, isFn, self, arg1, arg2, arg3) {
      if (isFn)
        handler.call(self, arg1, arg2, arg3);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].call(self, arg1, arg2, arg3);
      }
    }

    function emitMany(handler, isFn, self, args) {
      if (isFn)
        handler.apply(self, args);
      else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          listeners[i].apply(self, args);
      }
    }

    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain;
      var doError = (type === 'error');

      events = this._events;
      if (events)
        doError = (doError && events.error == null);
      else if (!doError)
        return false;

      domain = this.domain;

      // If there is no 'error' event listener then throw.
      if (doError) {
        er = arguments[1];
        if (domain) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain;
          er.domainThrown = false;
          domain.emit('error', er);
        } else if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          // At least give some kind of context to the user
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
          err.context = er;
          throw err;
        }
        return false;
      }

      handler = events[type];

      if (!handler)
        return false;

      var isFn = typeof handler === 'function';
      len = arguments.length;
      switch (len) {
        // fast cases
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        // slower
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = target._events;
      if (!events) {
        events = target._events = new EventHandlers();
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener) {
          target.emit('newListener', type,
                      listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (!existing) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] = prepend ? [listener, existing] :
                                              [existing, listener];
        } else {
          // If we've already got an array, just append.
          if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
        }

        // Check for listener leak
        if (!existing.warned) {
          m = $getMaxListeners(target);
          if (m && m > 0 && existing.length > m) {
            existing.warned = true;
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                                existing.length + ' ' + type + ' listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            emitWarning(w);
          }
        }
      }

      return target;
    }
    function emitWarning(e) {
      typeof console.warn === 'function' ? console.warn(e) : console.log(e);
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
        function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };

    function _onceWrap(target, type, listener) {
      var fired = false;
      function g() {
        target.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(target, arguments);
        }
      }
      g.listener = listener;
      return g;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
        function prependOnceListener(type, listener) {
          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };

    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener =
        function removeListener(type, listener) {
          var list, events, position, i, originalListener;

          if (typeof listener !== 'function')
            throw new TypeError('"listener" argument must be a function');

          events = this._events;
          if (!events)
            return this;

          list = events[type];
          if (!list)
            return this;

          if (list === listener || (list.listener && list.listener === listener)) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else {
              delete events[type];
              if (events.removeListener)
                this.emit('removeListener', type, list.listener || listener);
            }
          } else if (typeof list !== 'function') {
            position = -1;

            for (i = list.length; i-- > 0;) {
              if (list[i] === listener ||
                  (list[i].listener && list[i].listener === listener)) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list[0] = undefined;
              if (--this._eventsCount === 0) {
                this._events = new EventHandlers();
                return this;
              } else {
                delete events[type];
              }
            } else {
              spliceOne(list, position);
            }

            if (events.removeListener)
              this.emit('removeListener', type, originalListener || listener);
          }

          return this;
        };
        
    // Alias for removeListener added in NodeJS 10.0
    // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
    EventEmitter.prototype.off = function(type, listener){
        return this.removeListener(type, listener);
    };

    EventEmitter.prototype.removeAllListeners =
        function removeAllListeners(type) {
          var listeners, events;

          events = this._events;
          if (!events)
            return this;

          // not listening for removeListener, no need to emit
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = new EventHandlers();
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = new EventHandlers();
              else
                delete events[type];
            }
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            var keys = Object.keys(events);
            for (var i = 0, key; i < keys.length; ++i) {
              key = keys[i];
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = new EventHandlers();
            this._eventsCount = 0;
            return this;
          }

          listeners = events[type];

          if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            do {
              this.removeListener(type, listeners[listeners.length - 1]);
            } while (listeners[0]);
          }

          return this;
        };

    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;

      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === 'function')
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }

      return ret;
    };

    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount$1.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount$1;
    function listenerCount$1(type) {
      var events = this._events;

      if (events) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };

    // About 1.5x faster than the two-arg version of Array#splice().
    function spliceOne(list, index) {
      for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
        list[i] = list[k];
      list.pop();
    }

    function arrayClone(arr, i) {
      var copy = new Array(i);
      while (i--)
        copy[i] = arr[i];
      return copy;
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    function straight(path) {
        return path;
    }
    function manhattan(path, dimensions) {
        const dims = dimensions.map(dim => dim.name);
        const result = [];
        let prevItem;
        for (const item of path) {
            if (prevItem) {
                const x = dims.indexOf(item.x.name);
                const y = dims.indexOf(item.y.name);
                const prevX = dims.indexOf(prevItem.x.name);
                const prevY = dims.indexOf(prevItem.y.name);
                if (x !== prevX && y !== prevY) {
                    // if possible, don't cross the diagonal by always picking a point
                    // on the same side as (x, y)
                    let cornerX = x;
                    let cornerY = prevY;
                    for (const cx of [x, prevX]) {
                        for (const cy of [y, prevY]) {
                            const overlap = (cx === prevX && cy == prevY) || (cx === x && cy === y);
                            if (overlap)
                                continue;
                            const sideA = x > y && prevX > prevY && cx > cy;
                            const sideB = x < y && prevX < prevY && cx < cy;
                            if (sideA || sideB) {
                                cornerX = cx;
                                cornerY = cy;
                                break;
                            }
                        }
                    }
                    result.push(new ScatterView(dimensions[cornerX], dimensions[cornerY]));
                }
            }
            result.push(item);
            prevItem = item;
        }
        return result;
    }
    var DiagonalBias;
    (function (DiagonalBias) {
        DiagonalBias[DiagonalBias["Start"] = 0] = "Start";
        DiagonalBias[DiagonalBias["End"] = 1] = "End";
    })(DiagonalBias || (DiagonalBias = {}));
    function diagonalBiased(path, dimensions, bias) {
        const dims = dimensions.map(dim => dim.name);
        const result = [];
        let prevItem;
        for (const item of path) {
            if (prevItem) {
                const x = dims.indexOf(item.x.name);
                const y = dims.indexOf(item.y.name);
                const prevX = dims.indexOf(prevItem.x.name);
                const prevY = dims.indexOf(prevItem.y.name);
                const dx = x - prevX;
                const dy = y - prevY;
                if (dx && dy && Math.abs(dx) !== Math.abs(dy)) {
                    // has partial diagonal component (like _/)
                    let diagOffX, diagOffY;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        diagOffX = Math.sign(dx) * Math.abs(dy);
                        diagOffY = dy;
                    }
                    else {
                        diagOffX = dx;
                        diagOffY = Math.sign(dy) * Math.abs(dx);
                    }
                    if (bias === DiagonalBias.Start) {
                        const pointX = prevX + diagOffX;
                        const pointY = prevY + diagOffY;
                        result.push(new ScatterView(dimensions[pointX], dimensions[pointY]));
                    }
                    else {
                        const pointX = x - diagOffX;
                        const pointY = y - diagOffY;
                        result.push(new ScatterView(dimensions[pointX], dimensions[pointY]));
                    }
                }
            }
            result.push(item);
            prevItem = item;
        }
        return result;
    }
    function diagonalStart(path, dims) {
        return diagonalBiased(path, dims, DiagonalBias.Start);
    }
    function diagonalEnd(path, dims) {
        return diagonalBiased(path, dims, DiagonalBias.End);
    }
    function diagonalStairs(path, dimensions) {
        const dims = dimensions.map(dim => dim.name);
        const result = [];
        let prevItem;
        for (const item of path) {
            if (prevItem) {
                const x = dims.indexOf(item.x.name);
                const y = dims.indexOf(item.y.name);
                const prevX = dims.indexOf(prevItem.x.name);
                const prevY = dims.indexOf(prevItem.y.name);
                // 0 - horizontal; 1 - vertical
                let orientation = Math.abs(x - prevX) > Math.abs(y - prevY) ? 0 : 1;
                let cursorX = prevX;
                let cursorY = prevY;
                let moves = 0;
                while (cursorX !== x || cursorY !== y) {
                    const current = [cursorX, cursorY][orientation];
                    const target = [x, y][orientation];
                    const possibleMoves = [];
                    if (current > 0)
                        possibleMoves.push(-1);
                    if (current < dims.length - 1)
                        possibleMoves.push(1);
                    if (!possibleMoves.length)
                        break;
                    let move = possibleMoves[0];
                    for (const potentialMove of possibleMoves) {
                        const currentDist = Math.abs(target - (current + move));
                        const pmDist = Math.abs(target - (current + potentialMove));
                        if (pmDist < currentDist) {
                            move = potentialMove;
                        }
                    }
                    if (orientation === 0)
                        cursorX += move;
                    else
                        cursorY += move;
                    if (cursorX === x && cursorY === y)
                        break; // don't duplicate last view
                    result.push(new ScatterView(dimensions[cursorX], dimensions[cursorY]));
                    orientation ^= 1; // flip orientation to create stairs
                    // this algorithm will hopefully always halt, but just in case
                    if (moves++ > 1000)
                        break;
                }
            }
            result.push(item);
            prevItem = item;
        }
        return result;
    }

    class ScatterplotMatrix extends EventEmitter {
        constructor() {
            super();
            this._data = [];
            this._dimensions = [];
            this._width = 200;
            this._height = 200;
            this._labelPadding = 20;
            this._canvasScale = 1;
            this._rotateLabels = false;
            this._dirtyRerenderTimeout = -1;
            this.onPlotTransitionChange = () => {
                this._transition = this._plot.transition() || undefined;
                this.setDirty();
            };
            this.onPlotTimeUpdate = () => {
                this.renderCurrentView();
            };
            this._container = d3Selection.create('div')
                .attr('class', 'd3st-scatterplot-matrix')
                .style('display', 'inline-block');
            this._svgContainer = this._container.append('svg')
                .attr('class', 'd3st-inner-plot')
                .style('overflow', 'visible');
            this._svgContainer.append('g').attr('class', 'd3st-plot-axis d3st-plot-axis-top');
            this._svgContainer.append('g').attr('class', 'd3st-plot-axis d3st-plot-axis-left');
            this._svgContainer.selectAll('.d3st-plot-axis')
                .attr('font-family', 'sans-serif')
                .attr('font-size', '10');
            this._matrixPlotsCtx = this._svgContainer
                .append('foreignObject')
                .attr('class', 'd3st-plot-canvas-container')
                .style('pointer-events', 'none')
                .append('xhtml:canvas')
                .attr('class', 'd3st-plot-canvas')
                .node()
                .getContext('2d');
            this._transPath = new TransitionPath();
            this._svgContainer.node().appendChild(this._transPath.node.node());
            this._transBuilder = new TransitionBuilder();
            this._container.node().appendChild(this._transBuilder.node());
            this._svgContainer.node().appendChild(this._transBuilder.path.node.node());
            this._matrixCells = new MatrixCells();
            this._svgContainer.node().appendChild(this._matrixCells.cells.node());
            this._matrixCells.on('select', (x, y) => this._transBuilder.onSelect(x, y));
            this._transBuilder.on('beginBuild', () => {
                this._matrixCells.transitionBuilderDidBegin();
                this._transPath.setVisible(false);
            });
            this._transBuilder.on('endBuild', (didCommit) => {
                this._matrixCells.transitionBuilderDidEnd();
                this._transPath.forceClear();
                if (!didCommit)
                    this._transPath.renderPaths();
                this._transPath.setVisible(true);
            });
            this._transBuilder.on('transition', (transition) => {
                this._transPath.forceClear();
                setTimeout(() => {
                    var _a, _b;
                    (_a = this._plot) === null || _a === void 0 ? void 0 : _a.transition(transition);
                    (_b = this._plot) === null || _b === void 0 ? void 0 : _b.playing(true);
                    this.render();
                }, 0);
            });
            this._transBuilder.on('createTransition', (transition, isRebuild) => {
                var _a, _b, _c, _d;
                const time = (_a = this._plot) === null || _a === void 0 ? void 0 : _a.transitionTime();
                (_b = this._plot) === null || _b === void 0 ? void 0 : _b.transition(transition);
                if (isRebuild) {
                    // keep time
                    (_d = (_c = this._plot) === null || _c === void 0 ? void 0 : _c.transitionTime(time)) === null || _d === void 0 ? void 0 : _d.updateLastRender();
                }
            });
        }
        node() {
            return this._container.node();
        }
        size(width, height) {
            if (typeof width === 'number') {
                this._width = width;
                this._height = typeof height === 'number' ? height : width;
                this.setDirty();
                return this;
            }
            return [this._width, this._height];
        }
        data(data) {
            if (data) {
                this._data = data;
                this.setDirty();
                return this;
            }
            return this._data;
        }
        dimensions(dimensions) {
            if (dimensions) {
                this._dimensions = dimensions;
                this.setDirty();
                return this;
            }
            return this._dimensions;
        }
        setDirty() {
            clearTimeout(this._dirtyRerenderTimeout);
            this._dirtyRerenderTimeout = window.setTimeout(() => {
                this.render();
            }, 50);
        }
        render() {
            var _a;
            this._svgContainer
                .attr('width', this._width)
                .attr('height', this._height);
            this._matrixCells.width = this._width - this._labelPadding;
            this._matrixCells.height = this._height - this._labelPadding;
            this._matrixCells.cells.attr('transform', `translate(${this._labelPadding}, ${this._labelPadding})`);
            this._matrixCells.dimensions = this._dimensions;
            const handlePath = (path) => {
                path.node.attr('transform', `translate(${this._labelPadding}, ${this._labelPadding})`);
                path.plotWidth = this._width - this._labelPadding;
                path.plotHeight = this._height - this._labelPadding;
                path.dimensions = this._dimensions;
            };
            handlePath(this._transPath);
            handlePath(this._transBuilder.path);
            this._transPath.views = (_a = this._transition) === null || _a === void 0 ? void 0 : _a.views;
            this._transBuilder.data = this._data;
            this._transBuilder.dimensions = this._dimensions;
            this._transBuilder.plot = this._plot;
            this._matrixCells.render();
            this._transPath.renderPaths();
            this.renderAxes();
            this.drawPlots();
            this.renderCurrentView();
        }
        transBuilder() {
            return this._transBuilder;
        }
        rotateLabels(rotate) {
            if (typeof rotate === 'boolean') {
                this._rotateLabels = rotate;
                this._container.selectAll('.axis-label').remove();
                this.renderAxes();
                return this;
            }
            return this._rotateLabels;
        }
        renderAxes() {
            const cellSizeX = (this._width - this._labelPadding) / this._dimensions.length;
            const cellSizeY = (this._height - this._labelPadding) / this._dimensions.length;
            getComputedStyle(this.node()).color;
            const top = this._container.select('.d3st-plot-axis-top')
                .attr('transform', `translate(${this._labelPadding},${this._labelPadding})`)
                .attr('text-anchor', 'start')
                .selectAll('.axis-label')
                .data(this._dimensions)
                .attr('x', (dim, idx) => idx * cellSizeX)
                .text(dim => dim.name.toString())
                .call(sel => sel.exit().remove())
                .enter()
                .append('text')
                .attr('class', 'axis-label')
                .attr('dominant-baseline', 'text-bottom')
                .style('fill', 'currentColor')
                .attr('dy', '-5')
                .attr('x', (dim, idx) => idx * cellSizeX)
                .text(dim => dim.name.toString());
            const left = this._container.select('.d3st-plot-axis-left')
                .attr('transform', `translate(${this._labelPadding},${this._labelPadding}) rotate(-90)`)
                .attr('text-anchor', 'end')
                .selectAll('.axis-label')
                .data(this._dimensions)
                .attr('x', (dim, idx) => -(this._height - this._labelPadding)
                + (this._dimensions.length - idx) * cellSizeY)
                .text(dim => dim.name.toString())
                .call(sel => sel.exit().remove())
                .enter()
                .append('text')
                .attr('class', 'axis-label')
                .attr('dominant-baseline', 'text-bottom')
                .attr('x', (dim, idx) => -(this._height - this._labelPadding)
                + (this._dimensions.length - idx) * cellSizeY)
                .attr('dy', '-5')
                .style('fill', 'currentColor')
                .text(dim => dim.name.toString());
            if (this._rotateLabels) {
                top.attr('transform', (dim, idx) => `rotate(-45, ${(idx + 0.3) * cellSizeX}, -10)`);
                left.attr('transform', (dim, idx) => `rotate(90, ${-(idx + 0.3) * cellSizeY}, -10)`);
            }
        }
        drawPlots() {
            const width = this._width - this._labelPadding;
            const height = this._height - this._labelPadding;
            this._canvasScale = Math.ceil(window.devicePixelRatio);
            this._container.select('.d3st-plot-canvas-container')
                .attr('x', this._labelPadding)
                .attr('y', this._labelPadding)
                .attr('width', width)
                .attr('height', height);
            this._container.select('.d3st-plot-canvas')
                .attr('width', width * this._canvasScale)
                .attr('height', height * this._canvasScale)
                .style('width', width + 'px')
                .style('height', height + 'px');
            const ctx = this._matrixPlotsCtx;
            ctx.save();
            ctx.scale(this._canvasScale, this._canvasScale);
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = ctx.strokeStyle = getComputedStyle(this.node()).color;
            const cellSizeX = width / this._dimensions.length;
            const cellSizeY = height / this._dimensions.length;
            // background grid
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.rect(0.5, 0.5, width - 1, height - 1);
            for (let i = 1; i < this._dimensions.length; i++) {
                ctx.moveTo(i * cellSizeX, 0);
                ctx.lineTo(i * cellSizeX, height);
                ctx.moveTo(0, i * cellSizeY);
                ctx.lineTo(width, i * cellSizeY);
            }
            ctx.stroke();
            ctx.restore();
            // individual scatterplots
            for (let y = 0; y < this._dimensions.length; y++) {
                for (let x = 0; x < this._dimensions.length; x++) {
                    const view = new ScatterView(this._dimensions[x], this._dimensions[y]);
                    ctx.beginPath();
                    for (const point of this._data) {
                        const pointX = view.getX(point);
                        const pointY = view.getY(point);
                        // don't draw out of bounds points because they would overlap with adjacent cells
                        if (pointX < 0 || pointY < 0 || pointX > 1 || pointY > 1)
                            continue;
                        const screenX = (x + pointX) * cellSizeX;
                        const screenY = (y + 1 - pointY) * cellSizeY;
                        ctx.moveTo(screenX, screenY);
                        ctx.arc(screenX, screenY, 0.5, 0, 2 * Math.PI);
                    }
                    ctx.fill();
                }
            }
            ctx.restore();
        }
        renderCurrentView() {
            if (this._plot) {
                this._matrixCells.currentTransition = this._plot.transition() || undefined;
                this._matrixCells.currentView = this._plot.view() || undefined;
                this._matrixCells.currentTransitionTime = this._plot.transitionTime();
            }
            else {
                this._matrixCells.currentTransition = undefined;
                this._matrixCells.currentView = undefined;
            }
            this._matrixCells.renderCurrentView();
        }
        connect(plot) {
            this.disconnect();
            this._plot = plot;
            this._plot.on('transitionChange', this.onPlotTransitionChange);
            this._plot.on('transitionTimeUpdate', this.onPlotTimeUpdate);
            this.onPlotTransitionChange();
            this.onPlotTimeUpdate();
            return this;
        }
        plot() {
            return this._plot;
        }
        disconnect() {
            if (this._plot) {
                this._plot.removeListener('transitionChange', this.onPlotTransitionChange);
                this._plot.removeListener('transitionTimeUpdate', this.onPlotTimeUpdate);
            }
            return this;
        }
    }
    /** Handles matrix cell outlines and interaction. */
    class MatrixCells extends EventEmitter {
        constructor() {
            super();
            this.dimensions = [];
            this.width = 100;
            this.height = 100;
            this.currentTransitionTime = 0;
            this.currentStrokeWidth = 0;
            this.cells = d3Selection.create('svg:g')
                .attr('class', 'd3st-matrix-cells');
        }
        render() {
            const cells = [];
            for (let y = 0; y < this.dimensions.length; y++) {
                for (let x = 0; x < this.dimensions.length; x++)
                    cells.push({ x, y });
            }
            const cellSizeX = this.width / this.dimensions.length;
            const cellSizeY = this.height / this.dimensions.length;
            this.cells.selectAll('.d3st-matrix-cell')
                .data(cells)
                .call(sel => sel.exit().remove())
                .call(sel => sel
                .enter()
                .append('g')
                .attr('class', 'd3st-matrix-cell')
                .call(sel => sel.append('rect')
                .attr('class', 'd3st-matrix-cell-cursor')
                .attr('fill', 'none')
                .attr('stroke', 'blue')
                .attr('stroke-width', 0))
                .call(sel => sel.append('rect')
                .attr('class', 'd3st-matrix-cell-hover')
                .attr('fill', 'none')
                .attr('stroke', 'currentColor')
                .attr('stroke-width', 0))
                .call(sel => sel.append('rect')
                .attr('class', 'd3st-matrix-cell-hitbox')
                .attr('fill', 'black')
                .style('opacity', '0')
                .on('mouseover', (event) => {
                const { x, y } = event.currentTarget.parentNode.dataset;
                this.hoverCell = { x: +x, y: +y };
                this.hoverCellDidChange();
            })
                .on('mouseout', (event) => {
                var _a, _b;
                const { x, y } = event.currentTarget.parentNode.dataset;
                const cell = { x: +x, y: +y };
                if (((_a = this.hoverCell) === null || _a === void 0 ? void 0 : _a.x) === cell.x && ((_b = this.hoverCell) === null || _b === void 0 ? void 0 : _b.y) === cell.y)
                    this.hoverCell = undefined;
                this.hoverCellDidChange();
            })
                .on('click', (event) => {
                const { x, y } = event.currentTarget.parentNode.dataset;
                this.emit('select', +x, +y);
            })));
            this.cells.selectAll('.d3st-matrix-cell')
                .data(cells)
                .attr('data-x', cell => cell.x)
                .attr('data-y', cell => cell.y)
                .attr('transform', cell => `translate(${cell.x * cellSizeX}, ${cell.y * cellSizeY})`)
                .call(sel => sel.selectAll('rect').attr('width', cellSizeX).attr('height', cellSizeY));
        }
        renderCurrentView() {
            this.cells.selectAll('.d3st-matrix-cell-cursor')
                .transition()
                .duration(400)
                .ease(d3Ease.easeExpOut)
                .attr('stroke-width', this.currentStrokeWidth);
            const dimIndex = (dim) => this.dimensions.map(d => d.name).indexOf(dim.name);
            const activeViews = [];
            if (this.currentTransition) {
                const views = this.currentTransition.views;
                const maxIndex = views.length - 1;
                const viewIndex = this.currentTransitionTime * maxIndex;
                const indexLo = Math.min(Math.floor(viewIndex), maxIndex);
                const indexHi = Math.min(Math.ceil(viewIndex), maxIndex);
                const t = indexLo === indexHi
                    ? 0
                    : (viewIndex - indexLo) / (indexHi - indexLo);
                activeViews.push({
                    x: dimIndex(views[indexLo].x),
                    y: dimIndex(views[indexLo].y),
                    z: 1 - t
                });
                if (indexLo !== indexHi) {
                    activeViews.push({
                        x: dimIndex(views[indexHi].x),
                        y: dimIndex(views[indexHi].y),
                        z: t
                    });
                }
            }
            else if (this.currentView) {
                activeViews.push({
                    x: dimIndex(this.currentView.x),
                    y: dimIndex(this.currentView.y),
                    z: 1
                });
            }
            for (const view of activeViews) {
                this.cells.select(`.d3st-matrix-cell[data-x="${view.x}"][data-y="${view.y}"]`)
                    .select('.d3st-matrix-cell-cursor')
                    .transition()
                    .duration(0)
                    .attr('stroke-width', Math.sqrt(view.z) * 3);
            }
        }
        hoverCellDidChange() {
            this.cells.selectAll('.d3st-matrix-cell-hover')
                .transition()
                .duration(400)
                .ease(d3Ease.easeExpOut)
                .attr('stroke-width', this.currentStrokeWidth);
            const cell = this.hoverCell;
            if (cell) {
                this.cells.select(`.d3st-matrix-cell[data-x="${cell.x}"][data-y="${cell.y}"]`)
                    .select('.d3st-matrix-cell-hover')
                    .transition()
                    .duration(0)
                    .attr('stroke-width', 3);
            }
        }
        waveEffect(strokeColor, strokeWidth, delay) {
            for (let y = 0; y < this.dimensions.length; y++) {
                for (let x = 0; x < this.dimensions.length; x++) {
                    this.cells.select(`.d3st-matrix-cell[data-x="${x}"][data-y="${y}"]`)
                        .select('.d3st-matrix-cell-hover')
                        .transition()
                        .delay(delay(x, y))
                        .duration(200)
                        .ease(d3Ease.easeExpInOut)
                        .attr('stroke', strokeColor)
                        .attr('stroke-width', 3)
                        .transition()
                        .duration(400)
                        .ease(d3Ease.easeExpOut)
                        .attr('stroke-width', strokeWidth);
                }
            }
        }
        transitionBuilderDidBegin() {
            const cornerX = 0;
            const cornerY = this.dimensions.length - 1;
            const timeScale = 250 / this.dimensions.length;
            this.currentStrokeWidth = 1;
            this.waveEffect('red', 1, (x, y) => Math.hypot(x - cornerX, (y - cornerY) / 2) * timeScale + Math.random() * 20);
        }
        transitionBuilderDidEnd() {
            const cornerX = 0;
            const cornerY = this.dimensions.length - 1;
            const timeScale = 250 / this.dimensions.length;
            const maxIndex = this.dimensions.length - 1;
            const maxDelay = Math.hypot(maxIndex - cornerX, (maxIndex - cornerY) / 2) * timeScale;
            this.currentStrokeWidth = 0;
            this.waveEffect('currentColor', 0, (x, y) => maxDelay - Math.hypot(x - cornerX, (y - cornerY) / 2) * timeScale);
        }
    }
    function pathToSegments(path) {
        const segments = [];
        let prevItem;
        for (const item of path) {
            if (prevItem) {
                segments.push({
                    x1: prevItem.x.name,
                    y1: prevItem.y.name,
                    x2: item.x.name,
                    y2: item.y.name
                });
            }
            prevItem = item;
        }
        return segments;
    }
    class TransitionPath {
        constructor() {
            this.plotWidth = 200;
            this.plotHeight = 200;
            this.dimensions = [];
            this.node = d3Selection.create('svg:g')
                .attr('class', 'd3st-transition-path')
                .attr('fill', 'none')
                .attr('stroke', 'currentColor')
                .attr('stroke-width', 3)
                .attr('stroke-linecap', 'round');
            this._actualPath = this.node.append('g')
                .attr('class', 'd3st-actual-path')
                .style('opacity', '0.25');
            this._innerPath = this.node.append('g')
                .attr('class', 'd3st-inner-path')
                .style('opacity', '0.5');
        }
        setVisible(visible) {
            this.node.transition()
                .duration(200)
                .attr('stroke-width', visible ? 3 : 0);
        }
        forceClear() {
            this.node.selectAll('.path-segment, .stop-point').remove();
        }
        renderPaths() {
            let actualPath = [];
            let path = [];
            if (this.views) {
                path = [...this.views];
                actualPath = this.postTransform ? this.postTransform(path, this.dimensions) : path;
            }
            const actualPathSegments = actualPath.length ? pathToSegments(actualPath) : [];
            const pathSegments = pathToSegments(path);
            const cellSizeX = this.plotWidth / this.dimensions.length;
            const cellSizeY = this.plotHeight / this.dimensions.length;
            const dims = this.dimensions.map(dim => dim.name);
            const getX = (name) => (dims.indexOf(name) + 0.5) * cellSizeX;
            const getY = (name) => (dims.indexOf(name) + 0.5) * cellSizeY;
            const renderSegments = (sel) => sel
                .attr('x1', segment => getX(segment.x1))
                .attr('y1', segment => getY(segment.y1))
                .attr('x2', segment => getX(segment.x2))
                .attr('y2', segment => getY(segment.y2))
                .call(sel => sel.exit().remove())
                .call(sel => sel.enter()
                .append('line')
                .attr('class', 'path-segment')
                .attr('x1', segment => getX(segment.x1))
                .attr('y1', segment => getY(segment.y1))
                .attr('x2', segment => getX(segment.x1))
                .attr('y2', segment => getY(segment.y1))
                .transition()
                .attr('x2', segment => getX(segment.x2))
                .attr('y2', segment => getY(segment.y2)));
            this._actualPath.selectAll('.path-segment')
                .data(actualPathSegments)
                .call(renderSegments);
            this._innerPath.selectAll('.path-segment')
                .data(pathSegments)
                .call(renderSegments);
            this._innerPath.selectAll('.stop-point')
                .data(path)
                .attr('cx', c => getX(c.x.name))
                .attr('cy', c => getY(c.y.name))
                .call(sel => sel.exit().remove())
                .enter()
                .append('circle')
                .attr('class', 'stop-point')
                .attr('cx', c => getX(c.x.name))
                .attr('cy', c => getY(c.y.name))
                .attr('r', 0)
                .transition()
                .attr('r', 2);
        }
    }
    const TRANSITION_TYPES = {
        straight: StraightTransition,
        spline: SplineTransition,
        rotation: RotationTransition,
    };
    const makeIcon = (content) => `<svg xmlns="http://www.w3.org/2000/xml" viewBox="0 0 24 24" width="14" height="14"><g stroke="currentColor" stroke-width="2" fill="none">${content}</g></svg>`;
    const TRANSFORM_TYPES = {
        straight: {
            icon: makeIcon(`<line x1="3.5" y1="20.5" x2="20.5" y2="3.5"></line><polyline points="16 3 21 3 21 8"></polyline>`),
            transform: straight
        },
        manhattan: {
            icon: makeIcon(`<polyline points="2.5 19.5 17.5 19.5 17.5 4.5"></polyline><polyline points="14 7 17.5 3.5 21 7"></polyline>`),
            transform: manhattan
        },
        diagonalStart: {
            icon: makeIcon(`<polyline points="3 20 11.5 7 19.5 7"></polyline><polyline points="17 4 20 7 17 10"></polyline>`),
            transform: diagonalStart
        },
        diagonalEnd: {
            icon: makeIcon(`<polyline points="3.5 19 12 19 19.5 6"></polyline><polyline points="15.5 6.5 20 5.5 21 10"></polyline>`),
            transform: diagonalEnd
        },
        diagonalStairs: {
            icon: makeIcon(`<polyline points="2 21 8 21 8 16 13 16 13 11 18 11 18 4.5"></polyline><polyline points="21 7 18 4 15 7"></polyline>`),
            transform: diagonalStairs
        },
    };
    class TransitionBuilder extends EventEmitter {
        constructor() {
            super();
            this.data = [];
            this.dimensions = [];
            this.buildingTransition = false;
            this.transType = Object.keys(TRANSITION_TYPES)[0];
            this.tfType = Object.keys(TRANSFORM_TYPES)[0];
            this.transParams = {};
            this.onTransParamsChange = (params) => {
                this.transParams[this.transType] = params;
                this.renderParams();
            };
            this.toggleBuilder = () => {
                if (this.buildingTransition)
                    this.end();
                else
                    this.begin();
            };
            this.begin = () => {
                this._modeButton.textContent = 'Cancel';
                this._buildButton.textContent = 'Build';
                this.emit('beginBuild');
                this.buildingTransition = true;
                this.path.setVisible(true);
                this.path.views = [];
                this.path.renderPaths();
            };
            this.end = (didCommit = false) => {
                this._modeButton.textContent = 'Build Transition';
                this._buildButton.textContent = 'Rebuild With New Parameters';
                this.emit('endBuild', didCommit);
                this.buildingTransition = false;
                this.path.setVisible(false);
            };
            this.commit = () => {
                var _a;
                let views;
                let isRebuild = false;
                if (this.buildingTransition) {
                    views = this.path.views;
                }
                else {
                    const currentTrans = (_a = this.plot) === null || _a === void 0 ? void 0 : _a.transition();
                    if (!currentTrans)
                        return;
                    views = currentTrans.views;
                    isRebuild = true;
                }
                if (!views.length)
                    return;
                this.end(true);
                const transition = this.buildTransition(views);
                transition.prepare().then(() => {
                    this.emit('createTransition', transition, isRebuild);
                });
            };
            this._node = document.createElement('div');
            this._node.className = 'd3st-transition-builder';
            this._modeButton = document.createElement('button');
            this._node.appendChild(this._modeButton);
            this._modeButton.textContent = 'Build Transition';
            this._modeButton.addEventListener('click', this.toggleBuilder);
            this._buildButton = document.createElement('button');
            this._node.appendChild(this._buildButton);
            this._buildButton.textContent = 'Rebuild With New Parameters';
            this._buildButton.addEventListener('click', this.commit);
            this._builderSettings = document.createElement('div');
            this._node.appendChild(this._builderSettings);
            {
                const typeSelect = document.createElement('select');
                for (const id in TRANSITION_TYPES) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = id;
                    typeSelect.appendChild(option);
                }
                typeSelect.addEventListener('change', () => {
                    this.transType = typeSelect.value;
                    this.renderParams();
                });
                this._builderSettings.appendChild(typeSelect);
                const pathTransformSelect = document.createElement('span');
                Object.assign(pathTransformSelect.style, {
                    display: 'inline-block',
                    borderRadius: '4px',
                    overflow: 'hidden',
                    verticalAlign: 'middle',
                    border: '1px solid rgba(0, 0, 0, 0.2)'
                });
                let selectedOption = null;
                for (const id in TRANSFORM_TYPES) {
                    const option = document.createElement('button');
                    option.value = id;
                    option.title = id;
                    option.innerHTML = TRANSFORM_TYPES[id].icon;
                    pathTransformSelect.appendChild(option);
                    Object.assign(option.style, {
                        margin: '0',
                        color: 'inherit',
                        background: 'none',
                        border: 'none',
                        padding: '2px 4px'
                    });
                    if (!selectedOption) {
                        selectedOption = option;
                        selectedOption.style.background = '#000';
                        selectedOption.style.color = '#fff';
                    }
                    option.addEventListener('click', () => {
                        selectedOption.style.background = 'none';
                        selectedOption.style.color = 'inherit';
                        selectedOption = option;
                        selectedOption.style.background = '#000';
                        selectedOption.style.color = '#fff';
                        this.tfType = id;
                        this.renderParams();
                    });
                }
                this._builderSettings.appendChild(pathTransformSelect);
                this._transParams = document.createElement('div');
                this._builderSettings.appendChild(this._transParams);
            }
            this.path = new TransitionPath();
            this.path._innerPath.attr('stroke', 'red').style('opacity', 1);
            this.path.setVisible(false);
        }
        node() {
            return this._node;
        }
        getTransConstructor() {
            return TRANSITION_TYPES[this.transType];
        }
        getPathPostTransform() {
            const { transform } = TRANSFORM_TYPES[this.tfType];
            if (this.getTransConstructor().requiresCommonDimensions) {
                return (path, dims) => manhattan(transform(path, dims), dims);
            }
            return transform;
        }
        renderParams() {
            renderTransitionParams(this._transParams, this.getTransConstructor().params, this.transParams[this.transType] || {}, this.onTransParamsChange);
            this.path.postTransform = this.getPathPostTransform();
            this.path.renderPaths();
        }
        buildTransition(path) {
            const Trans = this.getTransConstructor();
            const postTransform = this.getPathPostTransform();
            if (postTransform)
                path = postTransform(path, this.dimensions);
            return new Trans(path, {
                data: this.data,
                ...(this.transParams[this.transType] || {})
            });
        }
        onSelect(x, y) {
            var _a;
            const xDim = this.dimensions[x];
            const yDim = this.dimensions[y];
            const view = new ScatterView(xDim, yDim);
            if (this.buildingTransition) {
                (_a = this.path.views) === null || _a === void 0 ? void 0 : _a.push(view);
                this.path.renderPaths();
            }
            else if (this.plot) {
                const path = [];
                path.push(this.plot.closestView());
                path.push(view);
                const transition = this.buildTransition(path);
                transition.prepare().then(() => {
                    this.emit('transition', transition);
                });
            }
        }
    }
    function renderTransitionParams(node, params, values, onChange) {
        var _a, _b, _c, _d, _e, _f;
        let domCursor = 0;
        let didRenderNew = false;
        node._values = values;
        const currentChildren = [];
        for (let i = 0; i < node.children.length; i++)
            currentChildren.push(node.children[i]);
        for (const key in params) {
            const param = params[key];
            const itemId = param.type + ' ' + key;
            if (((_b = (_a = currentChildren[domCursor]) === null || _a === void 0 ? void 0 : _a.dataset) === null || _b === void 0 ? void 0 : _b.id) !== itemId) {
                (_d = (_c = currentChildren[domCursor]) === null || _c === void 0 ? void 0 : _c.parentNode) === null || _d === void 0 ? void 0 : _d.removeChild(currentChildren[domCursor]);
                const onParamChange = (thunk) => {
                    onChange({
                        ...node._values,
                        [key]: thunk(node._values[key])
                    });
                };
                const newNode = document.createElement('div');
                newNode.className = 'd3st-transition-param';
                newNode.dataset.id = itemId;
                const defaultValue = createTransitionParam(newNode, param, onParamChange);
                if (!(key in values))
                    values[key] = defaultValue;
                node.insertBefore(newNode, currentChildren[domCursor + 1]);
                currentChildren[domCursor] = newNode;
                didRenderNew = true;
            }
            updateTransitionParam(currentChildren[domCursor], param, key, values);
            domCursor++;
        }
        if (didRenderNew) {
            onChange(values);
        }
        for (let i = domCursor; i < currentChildren.length; i++) {
            (_f = (_e = currentChildren[i]) === null || _e === void 0 ? void 0 : _e.parentNode) === null || _f === void 0 ? void 0 : _f.removeChild(currentChildren[i]);
        }
    }
    function createTransitionParam(node, param, onChange) {
        if (param.type === 'number') {
            const container = document.createElement('div');
            container.className = 'd3st-tp-number';
            node.appendChild(container);
            Object.assign(container.style, {
                position: 'relative',
                padding: '4px',
                cursor: 'ew-resize',
                background: 'rgba(0, 0, 0, 0.1)'
            });
            const sliderValue = document.createElement('div');
            sliderValue.className = 'd3st-tp-n-value';
            container.appendChild(sliderValue);
            Object.assign(sliderValue.style, {
                position: 'absolute',
                inset: '0',
                background: 'currentColor',
                opacity: '0.2',
                transformOrigin: '0 0'
            });
            const label = document.createElement('span');
            label.className = 'd3st-tp-n-label';
            Object.assign(label.style, {
                font: '10px sans-serif'
            });
            container.appendChild(label);
            const input = document.createElement('input');
            input.type = 'number';
            Object.assign(input.style, {
                font: '10px sans-serif',
                position: 'absolute',
                inset: '0',
                display: 'none'
            });
            container.appendChild(input);
            let inputMode = false;
            let pointerIsDown = false;
            let lastPointerX = 0;
            let movedDistance = 0;
            let currentValue = 0;
            container.addEventListener('pointerdown', e => {
                if (inputMode)
                    return;
                e.preventDefault();
                pointerIsDown = true;
                lastPointerX = e.clientX;
                movedDistance = 0;
                onChange(value => currentValue = value);
                container.setPointerCapture(e.pointerId);
            });
            container.addEventListener('pointermove', e => {
                e.preventDefault();
                if (!pointerIsDown)
                    return;
                const delta = (e.clientX - lastPointerX);
                lastPointerX = e.clientX;
                const valueDelta = delta / container.getBoundingClientRect().width * (param.domain[1] - param.domain[0]);
                movedDistance += Math.abs(delta);
                if (movedDistance >= 2) {
                    currentValue += valueDelta;
                    onChange(value => {
                        return Math.min(Math.max(param.round ? Math.round(currentValue) : currentValue, param.domain[0]), param.domain[1]);
                    });
                }
            });
            container.addEventListener('pointerup', e => {
                if (!pointerIsDown)
                    return;
                pointerIsDown = false;
                container.releasePointerCapture(e.pointerId);
                if (movedDistance < 2) {
                    inputMode = true;
                    input.style.display = 'block';
                    onChange(value => input.value = value);
                    input.focus();
                }
            });
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    if (Number.isFinite(+input.value)) {
                        onChange(() => {
                            return Math.min(Math.max(param.round ? Math.round(+input.value) : +input.value, param.domain[0]), param.domain[1]);
                        });
                    }
                    input.blur();
                }
                else if (e.key === 'Escape')
                    input.blur();
            });
            input.addEventListener('blur', () => {
                inputMode = false;
                input.style.display = 'none';
            });
            return param.default;
        }
        else if (param.type === 'bool') {
            const checkbox = document.createElement('input');
            checkbox.className = 'd3st-tp-b-checkbox';
            checkbox.type = 'checkbox';
            checkbox.id = Math.random().toString();
            node.appendChild(checkbox);
            node.appendChild(document.createTextNode(' '));
            const label = document.createElement('label');
            label.className = 'd3st-tp-b-label';
            label.setAttribute('for', checkbox.id);
            label.style.font = '10px sans-serif';
            node.appendChild(label);
            checkbox.addEventListener('change', () => {
                onChange(() => checkbox.checked);
            });
            return param.default;
        }
        else if (param.type === 'enum') {
            const id = Math.random().toString();
            const label = document.createElement('label');
            label.className = 'd3st-tp-b-label';
            label.setAttribute('for', id);
            label.style.font = '10px sans-serif';
            node.appendChild(label);
            const select = document.createElement('select');
            select.id = id;
            select.className = 'd3st-tp-e-select';
            let index = 0;
            for (const variant of param.variants) {
                const option = document.createElement('option');
                option.textContent = variant.label;
                option.value = (index++).toString();
                select.appendChild(option);
            }
            node.appendChild(select);
            select.addEventListener('change', () => {
                onChange(() => param.variants[+select.value].value);
            });
            return param.variants[param.default].value;
        }
        else if (param.type === 'group') {
            const header = document.createElement('div');
            header.className = 'd3st-tp-g-header';
            node.appendChild(header);
            const label = document.createElement('label');
            label.className = 'd3st-tp-g-label';
            label.style.font = '10px sans-serif';
            header.appendChild(label);
            const contents = document.createElement('ul');
            contents.className = 'd3st-tp-g-contents';
            node.appendChild(contents);
            Object.assign(contents.style, {
                listStyle: 'none',
                padding: '0',
                margin: '0',
                paddingLeft: '16px'
            });
            const defaults = {};
            for (const itemId in param.contents) {
                const itemNode = document.createElement('li');
                itemNode.className = 'd3st-tp-g-item';
                itemNode.dataset.id = itemId;
                contents.appendChild(itemNode);
                defaults[itemId] = createTransitionParam(itemNode, param.contents[itemId], (thunk) => onChange(v => ({
                    ...v,
                    [itemId]: thunk(v[itemId])
                })));
            }
            if (param.nullable) {
                header.insertBefore(document.createTextNode(' '), header.firstChild);
                const checkbox = document.createElement('input');
                checkbox.className = 'd3st-tp-g-checkbox';
                checkbox.type = 'checkbox';
                checkbox.id = Math.random().toString();
                header.insertBefore(checkbox, header.firstChild);
                label.setAttribute('for', checkbox.id);
                let values = defaults;
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        onChange(() => values);
                    }
                    else {
                        onChange(v => {
                            values = v;
                            return null;
                        });
                    }
                });
                return null;
            }
            else {
                return defaults;
            }
        }
        else if (param.type === 'derived') {
            node.style.display = 'none';
            node._paramOnChange = onChange;
        }
    }
    function updateTransitionParam(node, param, paramId, values, topValues = values) {
        var _a;
        if (param.shouldShow) {
            const shouldShow = param.shouldShow(values);
            if (shouldShow)
                node.style.display = 'block';
            else
                node.style.display = 'none';
        }
        if (param.type === 'number') {
            const sliderValue = node.querySelector('.d3st-tp-n-value');
            const label = node.querySelector('.d3st-tp-n-label');
            const scale = (values[paramId] - param.domain[0]) / (param.domain[1] - param.domain[0]);
            sliderValue.style.transform = `scaleX(${scale})`;
            label.textContent = paramId + ': ' + (param.round ? Math.round(values[paramId]) : values[paramId].toFixed(2));
        }
        else if (param.type === 'bool') {
            const checkbox = node.querySelector('.d3st-tp-b-checkbox');
            const label = node.querySelector('.d3st-tp-b-label');
            checkbox.checked = values[paramId];
            label.textContent = paramId;
        }
        else if (param.type === 'enum') {
            const select = node.querySelector('.d3st-tp-e-select');
            const label = node.querySelector('.d3st-tp-b-label');
            select.value = param.variants.map(v => v.value).indexOf(values[paramId]).toString();
            label.textContent = paramId;
        }
        else if (param.type === 'group') {
            const label = node.querySelector('.d3st-tp-g-label');
            const contents = node.querySelector('.d3st-tp-g-contents');
            label.textContent = paramId;
            if (param.nullable) {
                const checkbox = node.querySelector('.d3st-tp-g-checkbox');
                checkbox.checked = values[paramId] !== null;
            }
            if (values[paramId] !== null) {
                contents.style.display = '';
                const nodes = {};
                for (let i = 0; i < contents.children.length; i++) {
                    const child = contents.children[i];
                    if ((_a = child.dataset) === null || _a === void 0 ? void 0 : _a.id)
                        nodes[child.dataset.id] = child;
                }
                for (const itemId in param.contents) {
                    updateTransitionParam(nodes[itemId], param.contents[itemId], itemId, values[paramId] || {}, values);
                }
            }
            else {
                contents.style.display = 'none';
            }
        }
        else if (param.type === 'derived') {
            const derived = param.derive(topValues);
            if (values[paramId] !== derived) {
                node._paramOnChange(() => derived);
            }
        }
    }
    function scatterplotMatrix() {
        return new ScatterplotMatrix();
    }

    /**
     * A scatterplot.
     */
    class Scatterplot extends EventEmitter {
        constructor() {
            super(...arguments);
            this._data = [];
            // Position and size on drawing area.
            this._x = 0;
            this._y = 0;
            this._width = 200;
            this._height = 200;
            // How much padding to add for axes.
            this._axisPaddingTop = 0;
            this._axisPaddingLeft = 0;
            this._axisPaddingRight = 0;
            this._axisPaddingBottom = 0;
            this._currentTransitionTime = 0;
            this._playing = false;
            this._playingBackwards = false;
            this._speed = 1;
            /** Used to determine whether effectiveViewChange should be fired. */
            this._prevViewUpdate = null;
            /**
             * Returns the new selection of circles.
             * @param container the container
             */
            this.createCircles = (container) => {
                // empty existing content
                container.selectAll('.d3st-data').remove();
                // create new circles
                return this._circles = container
                    .selectAll('.d3st-data')
                    .data(this._data)
                    .enter()
                    .append('circle')
                    .attr('class', 'd3st-data')
                    .attr('r', 1)
                    .style('fill', 'black')
                    .call(this.updateCircles);
            };
            /**
             * Updates a previously created selection of circles.
             * @param circles the selection of circles
             */
            this.updateCircles = (circles) => {
                return circles
                    .attr('cx', dataPoint => this.normalizedXToDrawing(this.dataPointX(dataPoint)).toString())
                    .attr('cy', dataPoint => this.normalizedYToDrawing(this.dataPointY(dataPoint)).toString());
            };
            /**
             * Transitions a previously created selection of circles with the given D3 transition.
             * Note that this will not interact with transitionTime.
             *
             * @param circles the selection of circles
             */
            this.transitionCircles = (circles) => {
                if (!this._currentTransition)
                    throw new Error('cannot transition: no transition loaded');
                if (!this._currentTransition.isReady)
                    throw new Error('cannot transition: transition is not ready. call ScatterTransition#prepare() first');
                const transition = this._currentTransition;
                return circles
                    .attrTween('cx', (dataPoint) => t => this.normalizedXToDrawing(transition.getX(t, dataPoint)).toString())
                    .attrTween('cy', (dataPoint) => t => this.normalizedYToDrawing(transition.getY(t, dataPoint)).toString());
            };
            this._lastFrameTime = 0;
            /** Toggles playback. */
            this.togglePlayback = () => {
                this.playing(!this.playing());
            };
            this.playbackFrame = () => {
                if (!this._playing)
                    return;
                const transition = this.transition();
                if (!transition) {
                    this.playing(false);
                    return;
                }
                const deltaTime = (Date.now() - this._lastFrameTime) / 1000;
                this._lastFrameTime = Date.now();
                const transitionCount = transition.views.length - 1;
                const direction = this._playingBackwards ? -1 : 1;
                const newTime = this.transitionTime() + this._speed * direction * deltaTime / transitionCount;
                this.transitionTime(newTime);
                this.updateLastRender();
                const shouldStop = (direction * this._speed) > 0 ? newTime >= 1 : newTime <= 0;
                if (shouldStop)
                    requestAnimationFrame(() => this.playing(false));
                else
                    requestAnimationFrame(this.playbackFrame);
            };
            //#endregion
        }
        x(value) {
            if (value !== undefined) {
                this._x = value;
                this.emit('dimensionsChange');
                return this;
            }
            return this._x;
        }
        y(value) {
            if (value !== undefined) {
                this._y = value;
                this.emit('dimensionsChange');
                return this;
            }
            return this._y;
        }
        width(value) {
            if (value !== undefined) {
                this._width = value;
                this.emit('dimensionsChange');
                return this;
            }
            return this._width;
        }
        height(value) {
            if (value !== undefined) {
                this._height = value;
                this.emit('dimensionsChange');
                return this;
            }
            return this._height;
        }
        pos(x, y) {
            if (x !== undefined && y !== undefined) {
                this._x = x;
                this._y = y;
                this.emit('dimensionsChange');
                return this;
            }
            return [this._x, this._y];
        }
        size(width, height) {
            if (width !== undefined && height !== undefined) {
                this._width = width;
                this._height = height;
                this.emit('dimensionsChange');
                return this;
            }
            return [this._width, this._height];
        }
        rect(x, y, width, height) {
            return this.pos(x, y).size(width, height);
        }
        data(data) {
            if (data) {
                this._data = data;
                this.emit('dataChange');
                return this;
            }
            return this._data;
        }
        axisPadding(top, right, bottom, left) {
            this._axisPaddingTop = top;
            this._axisPaddingLeft = left;
            this._axisPaddingRight = right;
            this._axisPaddingBottom = bottom;
            this.emit('dimensionsChange');
            return this;
        }
        view(viewOrX, y, padding) {
            if (viewOrX && viewOrX instanceof ScatterView) {
                this.setCurrentView(viewOrX);
                return this;
            }
            else if (viewOrX && y) {
                const x = viewOrX;
                const xDim = x instanceof Dimension
                    ? x
                    : Dimension.fromData(x, this._data, padding);
                const yDim = y instanceof Dimension
                    ? y
                    : Dimension.fromData(y, this._data, padding);
                this.setCurrentView(new ScatterView(xDim, yDim));
                return this;
            }
            return this.getCurrentView();
        }
        getCurrentView() {
            if (!this._currentView) {
                if (this._data.length) {
                    console.warn('No scatterplot view set! Creating something random. To set a view, use .view(...)');
                }
                const keys = Object.keys(this._data[0] || {});
                const x = keys[0] || 'x';
                const y = keys[1] || 'y';
                this._currentView = new ScatterView(Dimension.fromData(x, this._data), Dimension.fromData(y, this._data));
            }
            return this._currentView;
        }
        setCurrentView(view) {
            this.clearTransition();
            this._currentView = view;
            this.emit('viewChange');
        }
        transition(transitionOrType, params) {
            if (!transitionOrType)
                return this._currentTransition || null;
            if ('isReady' in transitionOrType) {
                this._currentTransition = transitionOrType;
                this.transitionTime(0);
                this.emit('transitionChange');
                this.updateLastRender();
                return this;
            }
            return new ScatterplotTransitionBuilder(this, transitionOrType, params);
        }
        /** Finishes the transition and applies the final view as the current view. */
        finishTransition() {
            if (!this._currentTransition)
                throw new Error('cannot finish transition: no transition loaded');
            const transitionViews = this._currentTransition.views;
            this.setCurrentView(transitionViews[transitionViews.length - 1]);
            return this;
        }
        /** Clears the current transition. */
        clearTransition() {
            this._currentTransition = undefined;
            this.emit('transitionChange');
            return this;
        }
        /**
         * Returns the current view as specified by the transition (if the current time happens to
         * land on one), or null.
         */
        getCurrentTransitionView() {
            const transition = this.transition();
            if (!transition)
                return this.getCurrentView();
            if (transition.hasMeaningfulIntermediates) {
                const transitionCount = transition.views.length - 1;
                const viewTime = this._currentTransitionTime * transitionCount;
                const closestView = Math.round(viewTime);
                if (Math.abs(viewTime - closestView) < 1e-2) {
                    return transition.views[closestView];
                }
            }
            else if (Math.abs(this._currentTransitionTime - Math.round(this._currentTransitionTime)) < 1e-2) {
                return transition.views[Math.round(this._currentTransitionTime)];
            }
            return null;
        }
        closestView() {
            const transition = this.transition();
            if (!transition)
                return this.getCurrentView();
            const transitionCount = transition.views.length - 1;
            const viewTime = this._currentTransitionTime * transitionCount;
            const closestView = Math.round(viewTime);
            return transition.views[closestView];
        }
        transitionTime(time) {
            if (typeof time === 'number') {
                this._currentTransitionTime = clamp(time, 0, 1);
                this.emit('transitionTimeUpdate');
                const currentView = this.getCurrentTransitionView();
                if (currentView !== this._prevViewUpdate) {
                    this.emit('effectiveViewChange', currentView);
                    this._prevViewUpdate = currentView;
                }
                return this;
            }
            return this._currentTransitionTime;
        }
        //#endregion
        /** Returns the X drawing position for a normalized point position. */
        normalizedXToDrawing(x) {
            return this._x + this._axisPaddingLeft + x * (this._width - this._axisPaddingLeft - this._axisPaddingRight);
        }
        /** Returns the Y drawing position for a normalized point position. */
        normalizedYToDrawing(y) {
            return this._y + this._axisPaddingTop + (1 - y) * (this._height - this._axisPaddingTop - this._axisPaddingBottom);
        }
        /** Returns the 2D drawing position for a normalized point position. */
        normalizedToDrawing(position) {
            return {
                x: this.normalizedXToDrawing(position.x),
                y: this.normalizedYToDrawing(position.y)
            };
        }
        /** Returns the normalized point position for an X drawing position. */
        drawingToNormalizedX(x) {
            return (x - this._x - this._axisPaddingLeft) / (this._width - this._axisPaddingLeft - this._axisPaddingRight);
        }
        /** Returns the normalized point position for a Y drawing position. */
        drawingToNormalizedY(y) {
            return (-y - this._y - this._axisPaddingTop) / (this._height - this._axisPaddingTop - this._axisPaddingBottom) + 1;
        }
        /** Returns the normalized point position for a 2D drawing position. */
        drawingToNormalized(position) {
            return {
                x: this.drawingToNormalizedX(position.x),
                y: this.drawingToNormalizedY(position.y)
            };
        }
        /** Returns the domain point position for a normalized X point position */
        normalizedToDomainX(x) {
            let view = this.getCurrentTransitionView();
            if (!(view instanceof ScatterView)) {
                throw "Can't map between domain and normalized coordinates without a view.";
            }
            return view.x.expand(x);
        }
        /** Returns the domain point position for a normalized Y point position */
        normalizedToDomainY(y) {
            let view = this.getCurrentTransitionView();
            if (!(view instanceof ScatterView)) {
                throw "Can't map between domain and normalized coordinates without a view.";
            }
            return view.y.expand(y);
        }
        /** Returns the domain point position for a normalized 2D point position */
        normalizedToDomain(position) {
            let view = this.getCurrentTransitionView();
            if (!(view instanceof ScatterView)) {
                throw "Can't map between domain and normalized coordinates without a view.";
            }
            return {
                x: view.x.expand(position.x),
                y: view.y.expand(position.y)
            };
        }
        /** Returns the domain point position for an X drawing position */
        drawingToDomainX(x) {
            return this.normalizedToDomainX(this.drawingToNormalizedX(x));
        }
        /** Returns the domain point position for a Y drawing position */
        drawingToDomainY(y) {
            return this.normalizedToDomainY(this.drawingToNormalizedY(y));
        }
        /** Returns the domain point position for a 2D drawing position */
        drawingToDomain(position) {
            return this.normalizedToDomain(this.drawingToNormalized(position));
        }
        /** Returns the current normalized X position of the given data point. */
        dataPointX(dataPoint) {
            if (this._currentTransition && this._currentTransition.isReady) {
                return this._currentTransition.getX(this._currentTransitionTime, dataPoint);
            }
            return this.getCurrentView().getX(dataPoint);
        }
        /** Returns the current normalized Y position of the given data point. */
        dataPointY(dataPoint) {
            if (this._currentTransition && this._currentTransition.isReady) {
                return this._currentTransition.getY(this._currentTransitionTime, dataPoint);
            }
            return this.getCurrentView().getY(dataPoint);
        }
        /**
         * Updates the last rendered dataset with the new view.
         */
        updateLastRender() {
            var _a;
            (_a = this._circles) === null || _a === void 0 ? void 0 : _a.call(this.updateCircles);
        }
        speed(value) {
            if (typeof value === 'number') {
                this._speed = value;
                this.emit('speedChange', value);
                return this;
            }
            return this._speed;
        }
        playing(value, backwards = false) {
            if (value !== undefined) {
                if (this._playing === value)
                    return this;
                this._playing = value;
                if (this._playing) {
                    this._lastFrameTime = Date.now();
                    this._playingBackwards = backwards;
                    this.playbackFrame();
                    this.emit('play');
                }
                else {
                    this._playingBackwards = false;
                    this.emit('pause');
                }
                return this;
            }
            return this._playing;
        }
        playingBackwards() {
            return this._playingBackwards;
        }
    }
    /**
     * Builds a scatterplot transition.
     */
    class ScatterplotTransitionBuilder {
        constructor(plot, type, params) {
            this.plot = plot;
            this.type = type;
            this.params = params;
            this.views = [];
        }
        toView(viewOrX, y, padding) {
            if (viewOrX instanceof ScatterView) {
                this.views.push(viewOrX);
            }
            else {
                if (!y)
                    throw new Error('Missing dimension Y');
                const xDim = viewOrX instanceof Dimension
                    ? viewOrX
                    : Dimension.fromData(viewOrX, this.plot.data(), padding);
                const yDim = y instanceof Dimension
                    ? y
                    : Dimension.fromData(y, this.plot.data(), padding);
                this.views.push(new ScatterView(xDim, yDim));
            }
            return this;
        }
        toX(x, padding) {
            const lastView = this.views[this.views.length - 1] || this.plot.view();
            const xDim = x instanceof Dimension ? x : Dimension.fromData(x, this.plot.data(), padding);
            this.views.push(new ScatterView(xDim, lastView.y));
            return this;
        }
        toY(y, padding) {
            const lastView = this.views[this.views.length - 1] || this.plot.view();
            const yDim = y instanceof Dimension ? y : Dimension.fromData(y, this.plot.data(), padding);
            this.views.push(new ScatterView(lastView.x, yDim));
            return this;
        }
        /** Adds several new stages transitioning to each of the given views. */
        toViews(views) {
            this.views.push(...views);
            return this;
        }
        /**
         * Builds and prepares the transition.
         * When done, the transition will be loaded into the owner scatterplot.
         */
        async build() {
            // typescript doesn't like this assignment for some reason
            // @ts-ignore
            this.params = this.params || {};
            // automatically provide data to transitions
            // @ts-ignore
            this.params.data = this.plot.data();
            const transition = this.plot.closestView().transitionTo(this.type, this.params, ...this.views);
            await transition.prepare();
            return this.plot.transition(transition);
        }
    }
    /**
     * Creates a new scatterplot.
     */
    function scatterplot() {
        return new Scatterplot();
    }

    const icons = {
        play: 'M6,3L22,12L6,21',
        pause: 'M4,3L10,3L10,21L4,21Z M14,3L20,3L20,21L14,21Z',
        snapLeft: 'M20,3L8,12L20,21Z M3,3L8,3L8,21L3,21Z',
        snapRight: 'M4,3L16,12L4,21Z M16,3L21,3L21,21L16,21Z',
    };
    /**
     * A slider control for scatterplot transitions.
     */
    class TimelineSlider {
        constructor() {
            this._interactive = false;
            this._playBackwards = false;
            this.plotTransitionDidChange = () => {
                var _a;
                const transition = (_a = this._plot) === null || _a === void 0 ? void 0 : _a.transition();
                if (transition) {
                    // has a transition
                    this._node.style('opacity', '1');
                    const viewCount = transition.hasMeaningfulIntermediates ? transition.views.length : 2;
                    this.renderSliderTicks(viewCount);
                    this._interactive = true;
                }
                else {
                    this._node.style('opacity', '0.5');
                    this.renderSliderTicks(0);
                    this._interactive = false;
                }
            };
            this.plotTransitionDidUpdateTime = () => {
                var _a;
                const thumbPos = ((_a = this._plot) === null || _a === void 0 ? void 0 : _a.transitionTime()) || 0;
                this._node
                    .select('.d3st-slider-thumb')
                    .style('left', `calc(calc(calc(100% - 20px) * ${thumbPos}) + 10px)`);
            };
            this.plotStartedPlaying = () => {
                this._playButtonIcon.attr('d', icons.pause);
                this.updatePlayBackwardsDisplay();
            };
            this.plotStoppedPlaying = () => {
                this._playButtonIcon.attr('d', icons.play);
                this.updatePlayBackwardsDisplay();
            };
            this.plotSpeedDidChange = () => {
                this.renderSpeed();
            };
            this.onThumbPointerDown = (e) => {
                if (!this._plot || !this._interactive)
                    return;
                e.preventDefault();
                const plot = this._plot;
                const sliderTrack = this._node.select('.d3st-slider-track').node();
                const thumb = this._node.select('.d3st-slider-thumb').node();
                thumb.setPointerCapture(e.pointerId);
                const sliderTrackRect = sliderTrack.getBoundingClientRect();
                const startPos = (e.clientX - sliderTrackRect.x) / sliderTrackRect.width;
                const startTime = plot.transitionTime();
                const onMove = (e) => {
                    e.preventDefault();
                    const newPos = (e.clientX - sliderTrackRect.x) / sliderTrackRect.width;
                    plot.transitionTime(startTime + (newPos - startPos));
                    this.snapToClosestViewIfWithinTolerance(3 / sliderTrackRect.width);
                    plot.updateLastRender();
                };
                const onUp = (e) => {
                    e.preventDefault();
                    thumb.releasePointerCapture(e.pointerId);
                    thumb.removeEventListener('pointermove', onMove);
                    thumb.removeEventListener('pointerup', onUp);
                };
                thumb.addEventListener('pointermove', onMove);
                thumb.addEventListener('pointerup', onUp);
            };
            this.speedPointerDblClickTime = 0;
            this.onSpeedPointerDown = (e) => {
                if (!this._plot)
                    return;
                e.preventDefault();
                const plot = this._plot;
                const speedSlider = this._node.select('.d3st-slider-speed').node();
                speedSlider.setPointerCapture(e.pointerId);
                const trackRect = speedSlider.getBoundingClientRect();
                const startPosScreen = e.clientX;
                const startPos = (e.clientX - trackRect.x) / trackRect.width;
                const startSpeed = plot.speed();
                let didMove = false;
                const onMove = (e) => {
                    e.preventDefault();
                    const newPos = (e.clientX - trackRect.x) / trackRect.width;
                    plot.speed(Math.max(0, startSpeed + (newPos - startPos) * 2));
                    if (Math.abs(e.clientX - startPosScreen) > 2) {
                        didMove = true;
                    }
                };
                const onUp = (e) => {
                    e.preventDefault();
                    speedSlider.releasePointerCapture(e.pointerId);
                    speedSlider.removeEventListener('pointermove', onMove);
                    speedSlider.removeEventListener('pointerup', onUp);
                    if (!didMove) {
                        const prevDownTime = this.speedPointerDblClickTime;
                        const thisDownTime = this.speedPointerDblClickTime = Date.now();
                        if (thisDownTime - prevDownTime < 400) {
                            plot.speed(1); // reset on double-click
                        }
                    }
                    else {
                        this.speedPointerDblClickTime = 0;
                    }
                };
                speedSlider.addEventListener('pointermove', onMove);
                speedSlider.addEventListener('pointerup', onUp);
            };
            this.togglePlayback = () => {
                const plot = this._plot;
                if (!plot)
                    return;
                if (plot.playing()) {
                    plot.playing(false);
                }
                else {
                    let didRewind = false;
                    if (!this._playBackwards && plot.transitionTime() === 1) {
                        // rewind
                        plot.transitionTime(0);
                        didRewind = true;
                    }
                    if (this._playBackwards && plot.transitionTime() === 0) {
                        // rewind (backwards)
                        plot.transitionTime(1);
                        didRewind = true;
                    }
                    if (didRewind) {
                        // show initial image for a bit
                        plot.updateLastRender();
                        this.plotStartedPlaying(); // pretend we're already playing
                        setTimeout(() => {
                            plot.playing(true, this._playBackwards);
                        }, 300);
                    }
                    else {
                        plot.playing(true, this._playBackwards);
                    }
                }
            };
            /** Snaps time to the previous view in the transition. */
            this.snapToPrevView = () => {
                const plot = this._plot;
                const transition = plot === null || plot === void 0 ? void 0 : plot.transition();
                if (!plot || !transition)
                    return;
                const transitionCount = transition.hasMeaningfulIntermediates ? transition.views.length - 1 : 1;
                const viewTime = plot.transitionTime() * transitionCount;
                const newTime = Math.floor(viewTime - 1e-9) / transitionCount;
                plot.transitionTime(newTime);
                plot.updateLastRender();
            };
            /** Snaps time to the next view in the transition. */
            this.snapToNextView = () => {
                const plot = this._plot;
                const transition = plot === null || plot === void 0 ? void 0 : plot.transition();
                if (!plot || !transition)
                    return;
                const transitionCount = transition.hasMeaningfulIntermediates ? transition.views.length - 1 : 1;
                const viewTime = plot.transitionTime() * transitionCount;
                const newTime = Math.ceil(viewTime + 1e-9) / transitionCount;
                plot.transitionTime(newTime);
                plot.updateLastRender();
            };
            const slider = d3Selection.create('div')
                .attr('class', 'd3st-timeline-slider')
                .style('display', 'flex')
                .style('position', 'relative')
                .style('align-items', 'center');
            const sliderButtons = slider.append('div')
                .attr('class', 'd3st-slider-buttons')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('flex-shrink', '0');
            const createButton = (button) => {
                button
                    .attr('class', 'd3st-slider-button')
                    .attr('type', 'button')
                    .style('width', '32px')
                    .style('height', '32px')
                    .style('border', 'none')
                    .style('padding', '0')
                    .style('box-sizing', 'border-box')
                    .style('display', 'inline-flex')
                    .style('justify-content', 'center')
                    .style('align-items', 'center')
                    .style('background', 'none')
                    .style('color', 'inherit')
                    .on('pointerdown', () => button.style('opacity', '0.5'))
                    .on('pointerup', () => button.style('opacity', ''));
            };
            sliderButtons.append('button')
                .call(createButton)
                .on('click', this.snapToPrevView)
                .append('svg')
                .attr('width', '24')
                .attr('height', '24')
                .append('path')
                .attr('fill', 'currentColor')
                .attr('d', icons.snapLeft);
            this._playButtonSvg = sliderButtons.append('button')
                .call(createButton)
                .on('click', this.togglePlayback)
                .append('svg')
                .style('transition', 'all 0.3s cubic-bezier(0.4, 0.3, 0, 1.5)')
                .attr('width', '24')
                .attr('height', '24');
            this._playButtonIcon = this._playButtonSvg
                .append('path')
                .attr('fill', 'currentColor')
                .attr('d', icons.play);
            window.addEventListener('keydown', e => {
                this.playBackwards(e.altKey);
            });
            window.addEventListener('keyup', e => {
                this.playBackwards(e.altKey);
            });
            sliderButtons.append('button')
                .call(createButton)
                .on('click', this.snapToNextView)
                .append('svg')
                .attr('width', '24')
                .attr('height', '24')
                .append('path')
                .attr('fill', 'currentColor')
                .attr('d', icons.snapRight);
            const sliderTrack = slider.append('div')
                .attr('class', 'd3st-slider-track')
                .style('position', 'relative')
                .style('flex', '1')
                .style('height', '20px');
            sliderTrack.append('div')
                .attr('class', 'd3st-slider-rail')
                .style('position', 'absolute')
                .style('top', '50%')
                .style('left', '10px')
                .style('right', '10px')
                .style('margin-top', '-1px')
                .style('height', '2px')
                .style('background', 'currentColor');
            sliderTrack.append('div')
                .attr('class', 'd3st-slider-ticks');
            sliderTrack.append('div')
                .attr('class', 'd3st-slider-thumb')
                .style('position', 'absolute')
                .style('width', '20px')
                .style('height', '20px')
                .style('margin-left', '-10px')
                .style('border-radius', '10px')
                .style('background', 'currentColor')
                .on('pointerdown', this.onThumbPointerDown);
            const speedSlider = slider.append('div')
                .attr('class', 'd3st-slider-speed')
                .style('position', 'relative')
                .style('width', '100px')
                .style('height', '22px')
                .style('background', 'rgba(0, 0, 0, 0.1)')
                .style('clip-path', 'polygon(0 80%, 100% 0, 100% 100%, 0 100%)')
                .style('cursor', 'ew-resize')
                .on('pointerdown', this.onSpeedPointerDown);
            speedSlider.append('div')
                .attr('class', 'd3st-slider-speed-value')
                .style('position', 'absolute')
                .style('width', '100%')
                .style('height', '100%')
                .style('transform-origin', '0 0')
                .style('background', 'rgba(0, 0, 0, 0.2)');
            speedSlider.append('div')
                .attr('class', 'd3st-slider-speed-label')
                .style('position', 'absolute')
                .style('right', '8px')
                .style('bottom', '2px')
                .style('pointer-events', 'none')
                .style('font', '10px sans-serif');
            this._node = slider;
        }
        renderSliderTicks(viewCount) {
            const sliderTicks = [];
            for (let i = 0; i < viewCount; i++)
                sliderTicks.push(i / (viewCount - 1));
            this._node.select('.d3st-slider-ticks')
                .selectAll('.d3st-slider-tick')
                .data(sliderTicks)
                .style('left', d => `calc(calc(${d} * calc(100% - 20px)) + 10px)`)
                .call(sel => sel.exit().remove())
                .enter()
                .append('div')
                .attr('class', 'd3st-slider-tick')
                .style('position', 'absolute')
                .style('width', '2px')
                .style('height', '18px')
                .style('left', d => `calc(calc(${d} * calc(100% - 20px)) + 10px)`)
                .style('margin-left', '-1px')
                .style('background', 'currentColor');
        }
        renderSpeed() {
            if (!this._plot)
                return;
            const speed = this._plot.speed();
            this._node.select('.d3st-slider-speed-value')
                .style('transform', `scaleX(${speed / 2})`);
            this._node.select('.d3st-slider-speed-label')
                .text(`speed: ${Math.round(speed * 100) / 100}/s`);
        }
        /**
         * Connects this slider to a scatterplot.
         * Will disconnect from any previously connected scatterplot, if applicable.
         * @param plot the scatterplot
         */
        connect(plot) {
            this.disconnect();
            this._plot = plot;
            this._plot.on('transitionChange', this.plotTransitionDidChange);
            this._plot.on('play', this.plotStartedPlaying);
            this._plot.on('pause', this.plotStoppedPlaying);
            this._plot.on('transitionTimeUpdate', this.plotTransitionDidUpdateTime);
            this._plot.on('speedChange', this.plotSpeedDidChange);
            this.plotTransitionDidChange();
            this.plotTransitionDidUpdateTime();
            this.plotSpeedDidChange();
            return this;
        }
        /** Disconnects this slider from any currently connected scatterplot. */
        disconnect() {
            if (this._plot) {
                this._plot.removeListener('transitionChange', this.plotTransitionDidChange);
                this._plot.removeListener('transitionTimeUpdate', this.plotTransitionDidUpdateTime);
                this._plot.removeListener('play', this.plotStartedPlaying);
                this._plot.removeListener('pause', this.plotStoppedPlaying);
                this._plot.removeListener('speedChange', this.plotSpeedDidChange);
                this._plot = undefined;
            }
            return this;
        }
        /** Returns this slider's node. */
        node() {
            return this._node.node();
        }
        updatePlayBackwardsDisplay() {
            const plot = this._plot;
            if (!plot)
                return;
            if (plot.playing() ? plot.playingBackwards() : this._playBackwards) {
                this._playButtonSvg.style('transform', 'rotate(-180deg)');
            }
            else {
                this._playButtonSvg.style('transform', '');
            }
        }
        playBackwards(value) {
            if (value !== undefined) {
                this._playBackwards = value;
                this.updatePlayBackwardsDisplay();
                return this;
            }
            return this._playBackwards;
        }
        /** Snaps time to the closest view if time is within the given tolernace. */
        snapToClosestViewIfWithinTolerance(tolerance) {
            const plot = this._plot;
            const transition = plot === null || plot === void 0 ? void 0 : plot.transition();
            if (!plot || !transition)
                return;
            const transitionCount = transition.hasMeaningfulIntermediates ? transition.views.length - 1 : 1;
            const viewTime = plot.transitionTime() * transitionCount;
            const closestView = Math.round(viewTime);
            if (Math.abs(viewTime - closestView) <= tolerance * transitionCount) {
                plot.transitionTime(closestView / transitionCount);
                plot.updateLastRender();
            }
        }
    }
    function timelineSlider() {
        return new TimelineSlider();
    }

    var global$1 = (typeof global !== "undefined" ? global :
      typeof self !== "undefined" ? self :
      typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray$1 = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer$1.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer$1.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer$1(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer$1 (arg, encodingOrOffset, length) {
      if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
        return new Buffer$1(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer$1.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer$1._augment = function (arr) {
      arr.__proto__ = Buffer$1.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer$1.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      Buffer$1.prototype.__proto__ = Uint8Array.prototype;
      Buffer$1.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer$1.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer$1.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer$1.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer$1.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer$1.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray$1(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer$1.isBuffer = isBuffer$1;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer$1.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer$1.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer$1.concat = function concat (list, length) {
      if (!isArray$1(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer$1.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer$1.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer$1.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer$1.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer$1.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer$1.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer$1.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer$1.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer$1.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer$1.compare(this, b) === 0
    };

    Buffer$1.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer$1.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer$1.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer$1.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer$1.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer$1.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer$1.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer$1(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer$1.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer$1(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer$1(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var browser$1 = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var inherits;
    if (typeof Object.create === 'function'){
      inherits = function inherits(ctor, superCtor) {
        // implementation from standard node.js 'util' module
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    var inherits$1 = inherits;

    var formatRegExp = /%[sdj%]/g;
    function format(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject$2(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    }

    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    function deprecate(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global$1.process)) {
        return function() {
          return deprecate(fn, msg).apply(this, arguments);
        };
      }

      if (browser$1.noDeprecation === true) {
        return fn;
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    }

    var debugs = {};
    var debugEnviron;
    function debuglog(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = browser$1.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = 0;
          debugs[set] = function() {
            var msg = format.apply(null, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    }

    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        _extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isSymbol$1(arg) {
      return typeof arg === 'symbol';
    }

    function isUndefined(arg) {
      return arg === void 0;
    }

    function isRegExp(re) {
      return isObject$2(re) && objectToString(re) === '[object RegExp]';
    }

    function isObject$2(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    function isDate(d) {
      return isObject$2(d) && objectToString(d) === '[object Date]';
    }

    function isError(e) {
      return isObject$2(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }

    function isBuffer(maybeBuf) {
      return Buffer$1.isBuffer(maybeBuf);
    }

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    function log() {
      console.log('%s - %s', timestamp(), format.apply(null, arguments));
    }

    function _extend(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject$2(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var util = {
      inherits: inherits$1,
      _extend: _extend,
      log: log,
      isBuffer: isBuffer,
      isPrimitive: isPrimitive,
      isFunction: isFunction,
      isError: isError,
      isDate: isDate,
      isObject: isObject$2,
      isRegExp: isRegExp,
      isUndefined: isUndefined,
      isSymbol: isSymbol$1,
      isString: isString,
      isNumber: isNumber,
      isNullOrUndefined: isNullOrUndefined,
      isNull: isNull,
      isBoolean: isBoolean,
      isArray: isArray,
      inspect: inspect,
      deprecate: deprecate,
      format: format,
      debuglog: debuglog
    };

    function BufferList() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    BufferList.prototype.push = function (v) {
      var entry = { data: v, next: null };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    };

    BufferList.prototype.unshift = function (v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    };

    BufferList.prototype.shift = function () {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    };

    BufferList.prototype.clear = function () {
      this.head = this.tail = null;
      this.length = 0;
    };

    BufferList.prototype.join = function (s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }return ret;
    };

    BufferList.prototype.concat = function (n) {
      if (this.length === 0) return Buffer$1.alloc(0);
      if (this.length === 1) return this.head.data;
      var ret = Buffer$1.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };

    // Copyright Joyent, Inc. and other Node contributors.
    var isBufferEncoding = Buffer$1.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         };


    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    function StringDecoder(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }

      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer$1(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    }

    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;

        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;

        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }

        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);

        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;

        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }

      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);

      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }

      charStr += buffer.toString(this.encoding, 0, end);

      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }

      // or just emit the charStr
      return charStr;
    };

    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;

      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];

        // See http://en.wikipedia.org/wiki/UTF-8#Description

        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }

        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }

        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };

    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);

      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }

      return res;
    };

    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }

    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }

    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }

    Readable.ReadableState = ReadableState;

    var debug = debuglog('stream');
    inherits$1(Readable, EventEmitter);

    function prependListener(emitter, event, fn) {
      // Sadly this is not cacheable as some libraries bundle their own
      // event emitter implementation with them.
      if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
      } else {
        // This is a hack to make sure that our error handler is attached before any
        // userland ones.  NEVER DO THIS. This is here only because this code needs
        // to continue to work with older versions of Node.js that do not include
        // the prependListener() method. The goal is to eventually remove this hack.
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
    }
    function listenerCount (emitter, type) {
      return emitter.listeners(type).length;
    }
    function ReadableState(options, stream) {

      options = options || {};

      // object stream flag. Used to make read(n) ignore n and to
      // make all the buffer merging and length checks go away
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

      // the point at which it stops calling _read() to fill the buffer
      // Note: 0 is a valid value, means "don't call _read preemptively ever"
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      // A linked list is used to store data chunks instead of an array because the
      // linked list can remove elements from the beginning faster than
      // array.shift()
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // when piping, we only care about 'readable' events that happen
      // after read()ing all the bytes and not getting any pushback.
      this.ranOut = false;

      // the number of writers that are awaiting a drain event in .pipe()s
      this.awaitDrain = 0;

      // if true, a maybeReadMore has been scheduled
      this.readingMore = false;

      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {

      if (!(this instanceof Readable)) return new Readable(options);

      this._readableState = new ReadableState(options, this);

      // legacy
      this.readable = true;

      if (options && typeof options.read === 'function') this._read = options.read;

      EventEmitter.call(this);
    }

    // Manually shove something into the read() buffer.
    // This returns true if the highWaterMark has not been hit yet,
    // similar to how Writable.write() returns true if you should
    // write() some more.
    Readable.prototype.push = function (chunk, encoding) {
      var state = this._readableState;

      if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer$1.from(chunk, encoding);
          encoding = '';
        }
      }

      return readableAddChunk(this, state, chunk, encoding, false);
    };

    // Unshift should *always* be something directly out of read()
    Readable.prototype.unshift = function (chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, '', true);
    };

    Readable.prototype.isPaused = function () {
      return this._readableState.flowing === false;
    };

    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit('error', er);
      } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error('stream.push() after EOF');
          stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
          var _e = new Error('stream.unshift() after end event');
          stream.emit('error', _e);
        } else {
          var skipAdd;
          if (state.decoder && !addToFront && !encoding) {
            chunk = state.decoder.write(chunk);
            skipAdd = !state.objectMode && chunk.length === 0;
          }

          if (!addToFront) state.reading = false;

          // Don't add to the buffer if we've decoded to an empty string chunk and
          // we're not in object mode
          if (!skipAdd) {
            // if we want the data now, just emit it.
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              // update the buffer info.
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

              if (state.needReadable) emitReadable(stream);
            }
          }

          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }

      return needMoreData(state);
    }

    // if it's past the high water mark, we can push in some more.
    // Also, if we have no data yet, we can stand some
    // more bytes.  This is to work around cases where hwm=0,
    // such as the repl.  Also, if the push() triggered a
    // readable event, and the user called read(largeNumber) such that
    // needReadable was set, then we ought to push more, so that another
    // 'readable' event will be triggered.
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }

    // backwards compatibility.
    Readable.prototype.setEncoding = function (enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };

    // Don't raise the hwm > 8MB
    var MAX_HWM = 0x800000;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }

    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
      }
      // If we're asking for more than the current hwm, then raise the hwm.
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      // Don't have enough
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }

    // you can override either this method, or the async _read(n) below.
    Readable.prototype.read = function (n) {
      debug('read', n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;

      if (n !== 0) state.emittedReadable = false;

      // if we're doing read(0) to trigger a readable event, but we
      // already have a bunch of data in the buffer, then just trigger
      // the 'readable' event and move on.
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
        return null;
      }

      n = howMuchToRead(n, state);

      // if we've ended, and we're now clear, then finish it up.
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }

      // All the actual chunk generation logic needs to be
      // *below* the call to _read.  The reason is that in certain
      // synthetic stream cases, such as passthrough streams, _read
      // may be a completely synchronous operation which may change
      // the state of the read buffer, providing enough data when
      // before there was *not* enough.
      //
      // So, the steps are:
      // 1. Figure out what the state of things will be after we do
      // a read from the buffer.
      //
      // 2. If that resulting state will trigger a _read, then call _read.
      // Note that this may be asynchronous, or synchronous.  Yes, it is
      // deeply ugly to write APIs this way, but that still doesn't mean
      // that the Readable class should behave improperly, as streams are
      // designed to be sync/async agnostic.
      // Take note if the _read call is sync or async (ie, if the read call
      // has returned yet), so that we know whether or not it's safe to emit
      // 'readable' etc.
      //
      // 3. Actually pull the requested chunks out of the buffer and return.

      // if we need a readable event, then we need to do some reading.
      var doRead = state.needReadable;
      debug('need readable', doRead);

      // if we currently have less than the highWaterMark, then also read some
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
      }

      // however, if we've ended, then there's no point, and if we're already
      // reading, then it's unnecessary.
      if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
      } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }

      var ret;
      if (n > 0) ret = fromList(n, state);else ret = null;

      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }

      if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;

        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
      }

      if (ret !== null) this.emit('data', ret);

      return ret;
    };

    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      return er;
    }

    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;

      // emit 'readable' now to make sure it gets picked up.
      emitReadable(stream);
    }

    // Don't emit readable right away in sync mode, because this can trigger
    // another read() call => stack overflow.  This way, it might trigger
    // a nextTick recursion warning, but that's not so bad.
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
      }
    }

    function emitReadable_(stream) {
      debug('emit readable');
      stream.emit('readable');
      flow(stream);
    }

    // at this point, the user has presumably seen the 'readable' event,
    // and called read() to consume some data.  that may have triggered
    // in turn another _read(n) call, in which case reading = true if
    // it's in progress.
    // However, if we're not ended, or reading, and the length < hwm,
    // then go ahead and try to read some more preemptively.
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        nextTick(maybeReadMore_, stream, state);
      }
    }

    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
          // didn't get any data, stop spinning.
          break;else len = state.length;
      }
      state.readingMore = false;
    }

    // abstract method.  to be overridden in specific implementation classes.
    // call cb(er, data) where data is <= n in length.
    // for virtual (non-string, non-buffer) streams, "length" is somewhat
    // arbitrary, and perhaps not very meaningful.
    Readable.prototype._read = function (n) {
      this.emit('error', new Error('not implemented'));
    };

    Readable.prototype.pipe = function (dest, pipeOpts) {
      var src = this;
      var state = this._readableState;

      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

      var doEnd = (!pipeOpts || pipeOpts.end !== false);

      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

      dest.on('unpipe', onunpipe);
      function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
          cleanup();
        }
      }

      function onend() {
        debug('onend');
        dest.end();
      }

      // when the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      var ondrain = pipeOnDrain(src);
      dest.on('drain', ondrain);

      var cleanedUp = false;
      function cleanup() {
        debug('cleanup');
        // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);

        cleanedUp = true;

        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }

      // If the user pushes more data while we're writing to dest then we'll end up
      // in ondata again. However, we only want to increase awaitDrain once because
      // dest will only emit one 'drain' event for the multiple writes.
      // => Introduce a guard on increasing awaitDrain.
      var increasedAwaitDrain = false;
      src.on('data', ondata);
      function ondata(chunk) {
        debug('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          // If the user unpiped during `dest.write()`, it is possible
          // to get stuck in a permanently paused state if that write
          // also returned false.
          // => Check whether `dest` is still a piping destination.
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }

      // if the dest has an error, then stop piping into it.
      // however, don't suppress the throwing behavior for this.
      function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
      }

      // Make sure our error handler is attached before userland ones.
      prependListener(dest, 'error', onerror);

      // Both close and finish should trigger unpipe, but only once.
      function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
      }
      dest.once('close', onclose);
      function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
      }
      dest.once('finish', onfinish);

      function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
      }

      // tell the dest that it's being piped to
      dest.emit('pipe', src);

      // start the flow if it hasn't been started already.
      if (!state.flowing) {
        debug('pipe resume');
        src.resume();
      }

      return dest;
    };

    function pipeOnDrain(src) {
      return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && src.listeners('data').length) {
          state.flowing = true;
          flow(src);
        }
      };
    }

    Readable.prototype.unpipe = function (dest) {
      var state = this._readableState;

      // if we're not piping anywhere, then do nothing.
      if (state.pipesCount === 0) return this;

      // just one destination.  most common case.
      if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;

        if (!dest) dest = state.pipes;

        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit('unpipe', this);
        return this;
      }

      // slow case. multiple pipe destinations.

      if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;

        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit('unpipe', this);
        }return this;
      }

      // try to find the right one.
      var i = indexOf(state.pipes, dest);
      if (i === -1) return this;

      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];

      dest.emit('unpipe', this);

      return this;
    };

    // set up data events if they are asked for
    // Ensure readable listeners eventually get something
    Readable.prototype.on = function (ev, fn) {
      var res = EventEmitter.prototype.on.call(this, ev, fn);

      if (ev === 'data') {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }

      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;

    function nReadingNextTick(self) {
      debug('readable nexttick read 0');
      self.read(0);
    }

    // pause() and resume() are remnants of the legacy readable stream API
    // If the user uses them, then switch into old mode.
    Readable.prototype.resume = function () {
      var state = this._readableState;
      if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };

    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        nextTick(resume_, stream, state);
      }
    }

    function resume_(stream, state) {
      if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
      }

      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit('resume');
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }

    Readable.prototype.pause = function () {
      debug('call pause flowing=%j', this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
      }
      return this;
    };

    function flow(stream) {
      var state = stream._readableState;
      debug('flow', state.flowing);
      while (state.flowing && stream.read() !== null) {}
    }

    // wrap an old-style stream as the async data source.
    // This is *not* part of the readable stream interface.
    // It is an ugly unfortunate mess of history.
    Readable.prototype.wrap = function (stream) {
      var state = this._readableState;
      var paused = false;

      var self = this;
      stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) self.push(chunk);
        }

        self.push(null);
      });

      stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder) chunk = state.decoder.write(chunk);

        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

        var ret = self.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });

      // proxy all the other methods.
      // important when wrapping filters and duplexes.
      for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
          this[i] = function (method) {
            return function () {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }

      // proxy certain important events.
      var events = ['error', 'close', 'destroy', 'pause', 'resume'];
      forEach(events, function (ev) {
        stream.on(ev, self.emit.bind(self, ev));
      });

      // when we try to consume some more bytes, simply unpause the
      // underlying stream.
      self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };

      return self;
    };

    // exposed for testing purposes only.
    Readable._fromList = fromList;

    // Pluck off n bytes from an array of buffers.
    // Length is the combined lengths of all the buffers in the list.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromList(n, state) {
      // nothing buffered
      if (state.length === 0) return null;

      var ret;
      if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
      }

      return ret;
    }

    // Extracts only enough buffered data to satisfy the amount requested.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
      } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }

    // Copies a specified amount of characters from the list of buffered data
    // chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    // Copies a specified amount of bytes from the list of buffered data chunks.
    // This function is designed to be inlinable, so please take care when making
    // changes to the function body.
    function copyFromBuffer(n, list) {
      var ret = Buffer$1.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }

    function endReadable(stream) {
      var state = stream._readableState;

      // If we get here before consuming all the bytes, then that is a
      // bug in node.  Should never happen.
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

      if (!state.endEmitted) {
        state.ended = true;
        nextTick(endReadableNT, state, stream);
      }
    }

    function endReadableNT(state, stream) {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    }

    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }

    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }

    // A bit simpler than readable streams.
    Writable.WritableState = WritableState;
    inherits$1(Writable, EventEmitter);

    function nop() {}

    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }

    function WritableState(options, stream) {
      Object.defineProperty(this, 'buffer', {
        get: deprecate(function () {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
      });
      options = options || {};

      // object stream flag to indicate whether or not this stream
      // contains buffers or objects.
      this.objectMode = !!options.objectMode;

      if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

      // the point at which write() starts returning false
      // Note: 0 is a valid value, means that we always return false if
      // the entire buffer is not flushed immediately on write()
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

      // cast to ints.
      this.highWaterMark = ~ ~this.highWaterMark;

      this.needDrain = false;
      // at the start of calling end()
      this.ending = false;
      // when end() has been called, and returned
      this.ended = false;
      // when 'finish' is emitted
      this.finished = false;

      // should we decode strings into buffers before passing to _write?
      // this is here so that some node-core streams can optimize string
      // handling at a lower level.
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;

      // Crypto is kind of old and crusty.  Historically, its default string
      // encoding is 'binary' so we have to make this configurable.
      // Everything else in the universe uses 'utf8', though.
      this.defaultEncoding = options.defaultEncoding || 'utf8';

      // not an actual buffer we keep track of, but a measurement
      // of how much we're waiting to get pushed to some underlying
      // socket or file.
      this.length = 0;

      // a flag to see when we're in the middle of a write.
      this.writing = false;

      // when true all writes will be buffered until .uncork() call
      this.corked = 0;

      // a flag to be able to tell if the onwrite cb is called immediately,
      // or on a later tick.  We set this to true at first, because any
      // actions that shouldn't happen until "later" should generally also
      // not happen before the first write call.
      this.sync = true;

      // a flag to know if we're processing previously buffered items, which
      // may call the _write() callback in the same tick, so that we don't
      // end up in an overlapped onwrite situation.
      this.bufferProcessing = false;

      // the callback that's passed to _write(chunk,cb)
      this.onwrite = function (er) {
        onwrite(stream, er);
      };

      // the callback that the user supplies to write(chunk,encoding,cb)
      this.writecb = null;

      // the amount that is being written when _write is called.
      this.writelen = 0;

      this.bufferedRequest = null;
      this.lastBufferedRequest = null;

      // number of pending user-supplied write callbacks
      // this must be 0 before 'finish' can be emitted
      this.pendingcb = 0;

      // emit prefinish if the only thing we're waiting for is _write cbs
      // This is relevant for synchronous Transform streams
      this.prefinished = false;

      // True if the error was already emitted and should not be thrown again
      this.errorEmitted = false;

      // count buffered requests
      this.bufferedRequestCount = 0;

      // allocate the first CorkedRequest, there is always
      // one allocated and free to use, and we maintain at most two
      this.corkedRequestsFree = new CorkedRequest(this);
    }

    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    function Writable(options) {

      // Writable ctor is applied to Duplexes, though they're not
      // instanceof Writable, they're instanceof Readable.
      if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

      this._writableState = new WritableState(options, this);

      // legacy.
      this.writable = true;

      if (options) {
        if (typeof options.write === 'function') this._write = options.write;

        if (typeof options.writev === 'function') this._writev = options.writev;
      }

      EventEmitter.call(this);
    }

    // Otherwise people can pipe Writable streams, which is just wrong.
    Writable.prototype.pipe = function () {
      this.emit('error', new Error('Cannot pipe, not readable'));
    };

    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      // TODO: defer error events consistently everywhere, not just the cb
      stream.emit('error', er);
      nextTick(cb, er);
    }

    // If we get something that is not a buffer, string, null, or undefined,
    // and we're not in objectMode, then that's an error.
    // Otherwise stream chunks are all considered to be of length=1, and the
    // watermarks determine how many objects to keep in the buffer, rather than
    // how many bytes or characters.
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      // Always throw error if a null is written
      // if we are not in object mode then throw
      // if it is not a buffer, string, or undefined.
      if (chunk === null) {
        er = new TypeError('May not write null values to stream');
      } else if (!Buffer$1.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
      }
      if (er) {
        stream.emit('error', er);
        nextTick(cb, er);
        valid = false;
      }
      return valid;
    }

    Writable.prototype.write = function (chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;

      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

      if (typeof cb !== 'function') cb = nop;

      if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }

      return ret;
    };

    Writable.prototype.cork = function () {
      var state = this._writableState;

      state.corked++;
    };

    Writable.prototype.uncork = function () {
      var state = this._writableState;

      if (state.corked) {
        state.corked--;

        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };

    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      // node::ParseEncoding() requires lower case.
      if (typeof encoding === 'string') encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };

    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer$1.from(chunk, encoding);
      }
      return chunk;
    }

    // if we're already writing something, then just put this
    // in the queue, and wait our turn.  Otherwise, call _write
    // If we return false, then we need a drain event, so set that flag.
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);

      if (Buffer$1.isBuffer(chunk)) encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;

      state.length += len;

      var ret = state.length < state.highWaterMark;
      // we must ensure that previous needDrain will not be reset to false.
      if (!ret) state.needDrain = true;

      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }

      return ret;
    }

    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }

    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) nextTick(cb, er);else cb(er);

      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }

    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }

    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;

      onwriteStateUpdate(state);

      if (er) onwriteError(stream, state, sync, er, cb);else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);

        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }

        if (sync) {
          /*<replacement>*/
            nextTick(afterWrite, stream, state, finished, cb);
          /*</replacement>*/
        } else {
            afterWrite(stream, state, finished, cb);
          }
      }
    }

    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }

    // Must force callback to be called on nextTick, so that we don't
    // emit 'drain' before the write() consumer gets the 'false' return
    // value, and has a chance to attach a 'drain' listener.
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }

    // if there's something in the buffer waiting, then process it
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;

      if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;

        var count = 0;
        while (entry) {
          buffer[count] = entry;
          entry = entry.next;
          count += 1;
        }

        doWrite(stream, state, true, state.length, buffer, '', holder.finish);

        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
      } else {
        // Slow case, write chunks one-by-one
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;

          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          // if we didn't call the onwrite immediately, then
          // it means that we need to wait until it does.
          // also, that means that the chunk and cb are currently
          // being processed, so move the buffer counter past them.
          if (state.writing) {
            break;
          }
        }

        if (entry === null) state.lastBufferedRequest = null;
      }

      state.bufferedRequestCount = 0;
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }

    Writable.prototype._write = function (chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };

    Writable.prototype._writev = null;

    Writable.prototype.end = function (chunk, encoding, cb) {
      var state = this._writableState;

      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }

      if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

      // .end() fully uncorks
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }

      // ignore unnecessary end() calls.
      if (!state.ending && !state.finished) endWritable(this, state, cb);
    };

    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }

    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }

    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }

    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) nextTick(cb);else stream.once('finish', cb);
      }
      state.ended = true;
      stream.writable = false;
    }

    // It seems a linked list but it is not
    // there will be only 2 of these for each stream
    function CorkedRequest(state) {
      var _this = this;

      this.next = null;
      this.entry = null;

      this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        if (state.corkedRequestsFree) {
          state.corkedRequestsFree.next = _this;
        } else {
          state.corkedRequestsFree = _this;
        }
      };
    }

    inherits$1(Duplex, Readable);

    var keys = Object.keys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);

      Readable.call(this, options);
      Writable.call(this, options);

      if (options && options.readable === false) this.readable = false;

      if (options && options.writable === false) this.writable = false;

      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

      this.once('end', onend);
    }

    // the no-half-open enforcer
    function onend() {
      // if we allow half-open state, or if the writable side ended,
      // then we're ok.
      if (this.allowHalfOpen || this._writableState.ended) return;

      // no more data can be written.
      // But allow more writes to happen in this tick.
      nextTick(onEndNT, this);
    }

    function onEndNT(self) {
      self.end();
    }

    // a transform stream is a readable/writable stream where you do
    inherits$1(Transform, Duplex);

    function TransformState(stream) {
      this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
      };

      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
      this.writeencoding = null;
    }

    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;

      var cb = ts.writecb;

      if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

      ts.writechunk = null;
      ts.writecb = null;

      if (data !== null && data !== undefined) stream.push(data);

      cb(er);

      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);

      Duplex.call(this, options);

      this._transformState = new TransformState(this);

      // when the writable side finishes, then flush out anything remaining.
      var stream = this;

      // start out asking for a readable event once data is transformed.
      this._readableState.needReadable = true;

      // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.
      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;

        if (typeof options.flush === 'function') this._flush = options.flush;
      }

      this.once('prefinish', function () {
        if (typeof this._flush === 'function') this._flush(function (er) {
          done(stream, er);
        });else done(stream);
      });
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };

    // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.
    Transform.prototype._transform = function (chunk, encoding, cb) {
      throw new Error('Not implemented');
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };

    // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.
    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    function done(stream, er) {
      if (er) return stream.emit('error', er);

      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided
      var ws = stream._writableState;
      var ts = stream._transformState;

      if (ws.length) throw new Error('Calling transform done when ws.length != 0');

      if (ts.transforming) throw new Error('Calling transform done when still transforming');

      return stream.push(null);
    }

    inherits$1(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);

      Transform.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };

    inherits$1(Stream, EventEmitter);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;

    // Backwards-compat with node 0.4.x
    Stream.Stream = Stream;

    // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.

    function Stream() {
      EventEmitter.call(this);
    }

    Stream.prototype.pipe = function(dest, options) {
      var source = this;

      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }

      source.on('data', ondata);

      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }

      dest.on('drain', ondrain);

      // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }

      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
      }


      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === 'function') dest.destroy();
      }

      // don't leave dangling pipes when there are errors.
      function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }

      source.on('error', onerror);
      dest.on('error', onerror);

      // remove all the event listeners that were added.
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);

        source.removeListener('end', onend);
        source.removeListener('close', onclose);

        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);

        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);

        dest.removeListener('close', cleanup);
      }

      source.on('end', cleanup);
      source.on('close', cleanup);

      dest.on('close', cleanup);

      dest.emit('pipe', source);

      // Allow for unix-like usage: A.pipe(B).pipe(C)
      return dest;
    };

    const Generator = function(options = {}){
      // Convert Stream Readable options if underscored
      if(options.high_water_mark){
        options.highWaterMark = options.high_water_mark;
      }
      if(options.object_mode){
        options.objectMode = options.object_mode;
      }
      // Call parent constructor
      Stream.Readable.call(this, options);
      // Clone and camelize options
      this.options = {};
      for(const k in options){
        this.options[Generator.camelize(k)] = options[k];
      }
      // Normalize options
      const dft = {
        columns: 8,
        delimiter: ',',
        duration: null,
        encoding: null,
        end: null,
        eof: false,
        fixedSize: false,
        length: -1,
        maxWordLength: 16,
        rowDelimiter: '\n',
        seed: false,
        sleep: 0,
      };
      for(const k in dft){
        if(this.options[k] === undefined){
          this.options[k] = dft[k];
        }
      }
      // Default values
      if(this.options.eof === true){
        this.options.eof = this.options.rowDelimiter;
      }
      // State
      this._ = {
        start_time: this.options.duration ? Date.now() : null,
        fixed_size_buffer: '',
        count_written: 0,
        count_created: 0,
      };
      if(typeof this.options.columns === 'number'){
        this.options.columns = new Array(this.options.columns);
      }
      const accepted_header_types = Object.keys(Generator).filter((t) => (!['super_', 'camelize'].includes(t)));
      for(let i = 0; i < this.options.columns.length; i++){
        const v = this.options.columns[i] || 'ascii';
        if(typeof v === 'string'){
          if(!accepted_header_types.includes(v)){
            throw Error(`Invalid column type: got "${v}", default values are ${JSON.stringify(accepted_header_types)}`);
          }
          this.options.columns[i] = Generator[v];
        }
      }
      return this;
    };
    util.inherits(Generator, Stream.Readable);

    // Generate a random number between 0 and 1 with 2 decimals. The function is idempotent if it detect the "seed" option.
    Generator.prototype.random = function(){
      if(this.options.seed){
        return this.options.seed = this.options.seed * Math.PI * 100 % 100 / 100;
      }else {
        return Math.random();
      }
    };
    // Stop the generation.
    Generator.prototype.end = function(){
      this.push(null);
    };
    // Put new data into the read queue.
    Generator.prototype._read = function(size){
      // Already started
      const data = [];
      let length = this._.fixed_size_buffer.length;
      if(length !== 0){
        data.push(this._.fixed_size_buffer);
      }
      // eslint-disable-next-line
      while(true){
        // Time for some rest: flush first and stop later
        if((this._.count_created === this.options.length) || (this.options.end && Date.now() > this.options.end) || (this.options.duration && Date.now() > this._.start_time + this.options.duration)){
          // Flush
          if(data.length){
            if(this.options.objectMode){
              for(const record of data){
                this.__push(record);
              }
            }else {
              this.__push(data.join('') + (this.options.eof ? this.options.eof : ''));
            }
            this._.end = true;
          }else {
            this.push(null);
          }
          return;
        }
        // Create the record
        let record = [];
        let recordLength;
        this.options.columns.forEach((fn) => {
          record.push(fn(this));
        });
        // Obtain record length
        if(this.options.objectMode){
          recordLength = 0;
          // recordLength is currently equal to the number of columns
          // This is wrong and shall equal to 1 record only
          for(const column of record)
            recordLength += column.length;
        }else {
          // Stringify the record
          record = (this._.count_created === 0 ? '' : this.options.rowDelimiter)+record.join(this.options.delimiter);
          recordLength = record.length;
        }
        this._.count_created++;
        if(length + recordLength > size){
          if(this.options.objectMode){
            data.push(record);
            for(const record of data){
              this.__push(record);
            }
          }else {
            if(this.options.fixedSize){
              this._.fixed_size_buffer = record.substr(size - length);
              data.push(record.substr(0, size - length));
            }else {
              data.push(record);
            }
            this.__push(data.join(''));
          }
          return;
        }
        length += recordLength;
        data.push(record);
      }
    };
    // Put new data into the read queue.
    Generator.prototype.__push = function(record){
      const push = () => {
        this._.count_written++;
        this.push(record);
        if(this._.end === true){
          return this.push(null);
        }
      };
      this.options.sleep > 0 ? setTimeout(push, this.options.sleep) : push();
    };
    // Generate an ASCII value.
    Generator.ascii = function(gen){
      // Column
      const column = [];
      const nb_chars = Math.ceil(gen.random() * gen.options.maxWordLength);
      for(let i=0; i<nb_chars; i++){
        const char = Math.floor(gen.random() * 32);
        column.push(String.fromCharCode(char + (char < 16 ? 65 : 97 - 16)));
      }
      return column.join('');
    };
    // Generate an integer value.
    Generator.int = function(gen){
      return Math.floor(gen.random() * Math.pow(2, 52));
    };
    // Generate an boolean value.
    Generator.bool = function(gen){
      return Math.floor(gen.random() * 2);
    };
    // Camelize option properties
    Generator.camelize = function(str){
      return str.replace(/_([a-z])/gi, function(_, match){
        return match.toUpperCase();
      });
    };

    class ResizeableBuffer{
      constructor(size=100){
        this.size = size;
        this.length = 0;
        this.buf = Buffer$1.allocUnsafe(size);
      }
      prepend(val){
        if(Buffer$1.isBuffer(val)){
          const length = this.length + val.length;
          if(length >= this.size){
            this.resize();
            if(length >= this.size){
              throw Error('INVALID_BUFFER_STATE');
            }
          }
          const buf = this.buf;
          this.buf = Buffer$1.allocUnsafe(this.size);
          val.copy(this.buf, 0);
          buf.copy(this.buf, val.length);
          this.length += val.length;
        }else {
          const length = this.length++;
          if(length === this.size){
            this.resize();
          }
          const buf = this.clone();
          this.buf[0] = val;
          buf.copy(this.buf,1, 0, length);
        }
      }
      append(val){
        const length = this.length++;
        if(length === this.size){
          this.resize();
        }
        this.buf[length] = val;
      }
      clone(){
        return Buffer$1.from(this.buf.slice(0, this.length));
      }
      resize(){
        const length = this.length;
        this.size = this.size * 2;
        const buf = Buffer$1.allocUnsafe(this.size);
        this.buf.copy(buf,0, 0, length);
        this.buf = buf;
      }
      toString(encoding){
        if(encoding){
          return this.buf.slice(0, this.length).toString(encoding);
        }else {
          return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
      }
      toJSON(){
        return this.toString('utf8');
      }
      reset(){
        this.length = 0;
      }
    }

    // white space characters
    // https://en.wikipedia.org/wiki/Whitespace_character
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
    // \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
    const tab = 9;
    const nl = 10; // \n, 0x0A in hexadecimal, 10 in decimal
    const np = 12;
    const cr = 13; // \r, 0x0D in hexadcimal, 13 in decimal
    const space = 32;
    const boms = {
      // Note, the following are equals:
      // Buffer.from("\ufeff")
      // Buffer.from([239, 187, 191])
      // Buffer.from('EFBBBF', 'hex')
      'utf8': Buffer$1.from([239, 187, 191]),
      // Note, the following are equals:
      // Buffer.from "\ufeff", 'utf16le
      // Buffer.from([255, 254])
      'utf16le': Buffer$1.from([255, 254])
    };

    class CsvError$1 extends Error {
      constructor(code, message, options, ...contexts) {
        if(Array.isArray(message)) message = message.join(' ');
        super(message);
        if(Error.captureStackTrace !== undefined){
          Error.captureStackTrace(this, CsvError$1);
        }
        this.code = code;
        for(const context of contexts){
          for(const key in context){
            const value = context[key];
            this[key] = Buffer$1.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
          }
        }
      }
    }

    const underscore$1 = function(str){
      return str.replace(/([A-Z])/g, function(_, match){
        return '_' + match.toLowerCase();
      });
    };

    const isObject$1 = function(obj){
      return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));
    };

    const isRecordEmpty = function(record){
      return record.every((field) => field == null || field.toString && field.toString().trim() === '');
    };

    const normalizeColumnsArray = function(columns){
      const normalizedColumns = [];
      for(let i = 0, l = columns.length; i < l; i++){
        const column = columns[i];
        if(column === undefined || column === null || column === false){
          normalizedColumns[i] = { disabled: true };
        }else if(typeof column === 'string'){
          normalizedColumns[i] = { name: column };
        }else if(isObject$1(column)){
          if(typeof column.name !== 'string'){
            throw new CsvError$1('CSV_OPTION_COLUMNS_MISSING_NAME', [
              'Option columns missing name:',
              `property "name" is required at position ${i}`,
              'when column is an object literal'
            ]);
          }
          normalizedColumns[i] = column;
        }else {
          throw new CsvError$1('CSV_INVALID_COLUMN_DEFINITION', [
            'Invalid column definition:',
            'expect a string or a literal object,',
            `got ${JSON.stringify(column)} at position ${i}`
          ]);
        }
      }
      return normalizedColumns;
    };

    class Parser extends Transform {
      constructor(opts = {}){
        super({...{readableObjectMode: true}, ...opts, encoding: null});
        this.__originalOptions = opts;
        this.__normalizeOptions(opts);
      }
      __normalizeOptions(opts){
        const options = {};
        // Merge with user options
        for(const opt in opts){
          options[underscore$1(opt)] = opts[opt];
        }
        // Normalize option `encoding`
        // Note: defined first because other options depends on it
        // to convert chars/strings into buffers.
        if(options.encoding === undefined || options.encoding === true){
          options.encoding = 'utf8';
        }else if(options.encoding === null || options.encoding === false){
          options.encoding = null;
        }else if(typeof options.encoding !== 'string' && options.encoding !== null){
          throw new CsvError$1('CSV_INVALID_OPTION_ENCODING', [
            'Invalid option encoding:',
            'encoding must be a string or null to return a buffer,',
            `got ${JSON.stringify(options.encoding)}`
          ], options);
        }
        // Normalize option `bom`
        if(options.bom === undefined || options.bom === null || options.bom === false){
          options.bom = false;
        }else if(options.bom !== true){
          throw new CsvError$1('CSV_INVALID_OPTION_BOM', [
            'Invalid option bom:', 'bom must be true,',
            `got ${JSON.stringify(options.bom)}`
          ], options);
        }
        // Normalize option `cast`
        let fnCastField = null;
        if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){
          options.cast = undefined;
        }else if(typeof options.cast === 'function'){
          fnCastField = options.cast;
          options.cast = true;
        }else if(options.cast !== true){
          throw new CsvError$1('CSV_INVALID_OPTION_CAST', [
            'Invalid option cast:', 'cast must be true or a function,',
            `got ${JSON.stringify(options.cast)}`
          ], options);
        }
        // Normalize option `cast_date`
        if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){
          options.cast_date = false;
        }else if(options.cast_date === true){
          options.cast_date = function(value){
            const date = Date.parse(value);
            return !isNaN(date) ? new Date(date) : value;
          };
        }else {
          throw new CsvError$1('CSV_INVALID_OPTION_CAST_DATE', [
            'Invalid option cast_date:', 'cast_date must be true or a function,',
            `got ${JSON.stringify(options.cast_date)}`
          ], options);
        }
        // Normalize option `columns`
        let fnFirstLineToHeaders = null;
        if(options.columns === true){
          // Fields in the first line are converted as-is to columns
          fnFirstLineToHeaders = undefined;
        }else if(typeof options.columns === 'function'){
          fnFirstLineToHeaders = options.columns;
          options.columns = true;
        }else if(Array.isArray(options.columns)){
          options.columns = normalizeColumnsArray(options.columns);
        }else if(options.columns === undefined || options.columns === null || options.columns === false){
          options.columns = false;
        }else {
          throw new CsvError$1('CSV_INVALID_OPTION_COLUMNS', [
            'Invalid option columns:',
            'expect an array, a function or true,',
            `got ${JSON.stringify(options.columns)}`
          ], options);
        }
        // Normalize option `group_columns_by_name`
        if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){
          options.group_columns_by_name = false;
        }else if(options.group_columns_by_name !== true){
          throw new CsvError$1('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [
            'Invalid option group_columns_by_name:',
            'expect an boolean,',
            `got ${JSON.stringify(options.group_columns_by_name)}`
          ], options);
        }else if(options.columns === false){
          throw new CsvError$1('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [
            'Invalid option group_columns_by_name:',
            'the `columns` mode must be activated.'
          ], options);
        }
        // Normalize option `comment`
        if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){
          options.comment = null;
        }else {
          if(typeof options.comment === 'string'){
            options.comment = Buffer$1.from(options.comment, options.encoding);
          }
          if(!Buffer$1.isBuffer(options.comment)){
            throw new CsvError$1('CSV_INVALID_OPTION_COMMENT', [
              'Invalid option comment:',
              'comment must be a buffer or a string,',
              `got ${JSON.stringify(options.comment)}`
            ], options);
          }
        }
        // Normalize option `delimiter`
        const delimiter_json = JSON.stringify(options.delimiter);
        if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];
        if(options.delimiter.length === 0){
          throw new CsvError$1('CSV_INVALID_OPTION_DELIMITER', [
            'Invalid option delimiter:',
            'delimiter must be a non empty string or buffer or array of string|buffer,',
            `got ${delimiter_json}`
          ], options);
        }
        options.delimiter = options.delimiter.map(function(delimiter){
          if(delimiter === undefined || delimiter === null || delimiter === false){
            return Buffer$1.from(',', options.encoding);
          }
          if(typeof delimiter === 'string'){
            delimiter = Buffer$1.from(delimiter, options.encoding);
          }
          if(!Buffer$1.isBuffer(delimiter) || delimiter.length === 0){
            throw new CsvError$1('CSV_INVALID_OPTION_DELIMITER', [
              'Invalid option delimiter:',
              'delimiter must be a non empty string or buffer or array of string|buffer,',
              `got ${delimiter_json}`
            ], options);
          }
          return delimiter;
        });
        // Normalize option `escape`
        if(options.escape === undefined || options.escape === true){
          options.escape = Buffer$1.from('"', options.encoding);
        }else if(typeof options.escape === 'string'){
          options.escape = Buffer$1.from(options.escape, options.encoding);
        }else if (options.escape === null || options.escape === false){
          options.escape = null;
        }
        if(options.escape !== null){
          if(!Buffer$1.isBuffer(options.escape)){
            throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
          }
        }
        // Normalize option `from`
        if(options.from === undefined || options.from === null){
          options.from = 1;
        }else {
          if(typeof options.from === 'string' && /\d+/.test(options.from)){
            options.from = parseInt(options.from);
          }
          if(Number.isInteger(options.from)){
            if(options.from < 0){
              throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
            }
          }else {
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
          }
        }
        // Normalize option `from_line`
        if(options.from_line === undefined || options.from_line === null){
          options.from_line = 1;
        }else {
          if(typeof options.from_line === 'string' && /\d+/.test(options.from_line)){
            options.from_line = parseInt(options.from_line);
          }
          if(Number.isInteger(options.from_line)){
            if(options.from_line <= 0){
              throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
            }
          }else {
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
          }
        }
        // Normalize options `ignore_last_delimiters`
        if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){
          options.ignore_last_delimiters = false;
        }else if(typeof options.ignore_last_delimiters === 'number'){
          options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
          if(options.ignore_last_delimiters === 0){
            options.ignore_last_delimiters = false;
          }
        }else if(typeof options.ignore_last_delimiters !== 'boolean'){
          throw new CsvError$1('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [
            'Invalid option `ignore_last_delimiters`:',
            'the value must be a boolean value or an integer,',
            `got ${JSON.stringify(options.ignore_last_delimiters)}`
          ], options);
        }
        if(options.ignore_last_delimiters === true && options.columns === false){
          throw new CsvError$1('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [
            'The option `ignore_last_delimiters`',
            'requires the activation of the `columns` option'
          ], options);
        }
        // Normalize option `info`
        if(options.info === undefined || options.info === null || options.info === false){
          options.info = false;
        }else if(options.info !== true){
          throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
        }
        // Normalize option `max_record_size`
        if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){
          options.max_record_size = 0;
        }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0);else if(typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)){
          options.max_record_size = parseInt(options.max_record_size);
        }else {
          throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
        }
        // Normalize option `objname`
        if(options.objname === undefined || options.objname === null || options.objname === false){
          options.objname = undefined;
        }else if(Buffer$1.isBuffer(options.objname)){
          if(options.objname.length === 0){
            throw new Error(`Invalid Option: objname must be a non empty buffer`);
          }
          if(options.encoding === null);else {
            options.objname = options.objname.toString(options.encoding);
          }
        }else if(typeof options.objname === 'string'){
          if(options.objname.length === 0){
            throw new Error(`Invalid Option: objname must be a non empty string`);
          }
          // Great, nothing to do
        }else if(typeof options.objname === 'number');else {
          throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
        }
        if(options.objname !== undefined){
          if(typeof options.objname === 'number'){
            if(options.columns !== false){
              throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');
            }
          }else { // A string or a buffer
            if(options.columns === false){
              throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');
            }
          }
        }
        // Normalize option `on_record`
        if(options.on_record === undefined || options.on_record === null){
          options.on_record = undefined;
        }else if(typeof options.on_record !== 'function'){
          throw new CsvError$1('CSV_INVALID_OPTION_ON_RECORD', [
            'Invalid option `on_record`:',
            'expect a function,',
            `got ${JSON.stringify(options.on_record)}`
          ], options);
        }
        // Normalize option `quote`
        if(options.quote === null || options.quote === false || options.quote === ''){
          options.quote = null;
        }else {
          if(options.quote === undefined || options.quote === true){
            options.quote = Buffer$1.from('"', options.encoding);
          }else if(typeof options.quote === 'string'){
            options.quote = Buffer$1.from(options.quote, options.encoding);
          }
          if(!Buffer$1.isBuffer(options.quote)){
            throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
          }
        }
        // Normalize option `raw`
        if(options.raw === undefined || options.raw === null || options.raw === false){
          options.raw = false;
        }else if(options.raw !== true){
          throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
        }
        // Normalize option `record_delimiter`
        if(options.record_delimiter === undefined){
          options.record_delimiter = [];
        }else if(typeof options.record_delimiter === 'string' || Buffer$1.isBuffer(options.record_delimiter)){
          if(options.record_delimiter.length === 0){
            throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [
              'Invalid option `record_delimiter`:',
              'value must be a non empty string or buffer,',
              `got ${JSON.stringify(options.record_delimiter)}`
            ], options);
          }
          options.record_delimiter = [options.record_delimiter];
        }else if(!Array.isArray(options.record_delimiter)){
          throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [
            'Invalid option `record_delimiter`:',
            'value must be a string, a buffer or array of string|buffer,',
            `got ${JSON.stringify(options.record_delimiter)}`
          ], options);
        }
        options.record_delimiter = options.record_delimiter.map(function(rd, i){
          if(typeof rd !== 'string' && ! Buffer$1.isBuffer(rd)){
            throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [
              'Invalid option `record_delimiter`:',
              'value must be a string, a buffer or array of string|buffer',
              `at index ${i},`,
              `got ${JSON.stringify(rd)}`
            ], options);
          }else if(rd.length === 0){
            throw new CsvError$1('CSV_INVALID_OPTION_RECORD_DELIMITER', [
              'Invalid option `record_delimiter`:',
              'value must be a non empty string or buffer',
              `at index ${i},`,
              `got ${JSON.stringify(rd)}`
            ], options);
          }
          if(typeof rd === 'string'){
            rd = Buffer$1.from(rd, options.encoding);
          }
          return rd;
        });
        // Normalize option `relax_column_count`
        if(typeof options.relax_column_count === 'boolean');else if(options.relax_column_count === undefined || options.relax_column_count === null){
          options.relax_column_count = false;
        }else {
          throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
        }
        if(typeof options.relax_column_count_less === 'boolean');else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){
          options.relax_column_count_less = false;
        }else {
          throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
        }
        if(typeof options.relax_column_count_more === 'boolean');else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){
          options.relax_column_count_more = false;
        }else {
          throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
        }
        // Normalize option `relax_quotes`
        if(typeof options.relax_quotes === 'boolean');else if(options.relax_quotes === undefined || options.relax_quotes === null){
          options.relax_quotes = false;
        }else {
          throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
        }
        // Normalize option `skip_empty_lines`
        if(typeof options.skip_empty_lines === 'boolean');else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){
          options.skip_empty_lines = false;
        }else {
          throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
        }
        // Normalize option `skip_records_with_empty_values`
        if(typeof options.skip_records_with_empty_values === 'boolean');else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){
          options.skip_records_with_empty_values = false;
        }else {
          throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
        }
        // Normalize option `skip_records_with_error`
        if(typeof options.skip_records_with_error === 'boolean');else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){
          options.skip_records_with_error = false;
        }else {
          throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
        }
        // Normalize option `rtrim`
        if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){
          options.rtrim = false;
        }else if(options.rtrim !== true){
          throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
        }
        // Normalize option `ltrim`
        if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){
          options.ltrim = false;
        }else if(options.ltrim !== true){
          throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
        }
        // Normalize option `trim`
        if(options.trim === undefined || options.trim === null || options.trim === false){
          options.trim = false;
        }else if(options.trim !== true){
          throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
        }
        // Normalize options `trim`, `ltrim` and `rtrim`
        if(options.trim === true && opts.ltrim !== false){
          options.ltrim = true;
        }else if(options.ltrim !== true){
          options.ltrim = false;
        }
        if(options.trim === true && opts.rtrim !== false){
          options.rtrim = true;
        }else if(options.rtrim !== true){
          options.rtrim = false;
        }
        // Normalize option `to`
        if(options.to === undefined || options.to === null){
          options.to = -1;
        }else {
          if(typeof options.to === 'string' && /\d+/.test(options.to)){
            options.to = parseInt(options.to);
          }
          if(Number.isInteger(options.to)){
            if(options.to <= 0){
              throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
            }
          }else {
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
          }
        }
        // Normalize option `to_line`
        if(options.to_line === undefined || options.to_line === null){
          options.to_line = -1;
        }else {
          if(typeof options.to_line === 'string' && /\d+/.test(options.to_line)){
            options.to_line = parseInt(options.to_line);
          }
          if(Number.isInteger(options.to_line)){
            if(options.to_line <= 0){
              throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
            }
          }else {
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
          }
        }
        this.info = {
          bytes: 0,
          comment_lines: 0,
          empty_lines: 0,
          invalid_field_length: 0,
          lines: 1,
          records: 0
        };
        this.options = options;
        this.state = {
          bomSkipped: false,
          bufBytesStart: 0,
          castField: fnCastField,
          commenting: false,
          // Current error encountered by a record
          error: undefined,
          enabled: options.from_line === 1,
          escaping: false,
          escapeIsQuote: Buffer$1.isBuffer(options.escape) && Buffer$1.isBuffer(options.quote) && Buffer$1.compare(options.escape, options.quote) === 0,
          // columns can be `false`, `true`, `Array`
          expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
          field: new ResizeableBuffer(20),
          firstLineToHeaders: fnFirstLineToHeaders,
          needMoreDataSize: Math.max(
            // Skip if the remaining buffer smaller than comment
            options.comment !== null ? options.comment.length : 0,
            // Skip if the remaining buffer can be delimiter
            ...options.delimiter.map((delimiter) => delimiter.length),
            // Skip if the remaining buffer can be escape sequence
            options.quote !== null ? options.quote.length : 0,
          ),
          previousBuf: undefined,
          quoting: false,
          stop: false,
          rawBuffer: new ResizeableBuffer(100),
          record: [],
          recordHasError: false,
          record_length: 0,
          recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map((v) => v.length)),
          trimChars: [Buffer$1.from(' ', options.encoding)[0], Buffer$1.from('\t', options.encoding)[0]],
          wasQuoting: false,
          wasRowDelimiter: false
        };
      }
      // Implementation of `Transform._transform`
      _transform(buf, encoding, callback){
        if(this.state.stop === true){
          return;
        }
        const err = this.__parse(buf, false);
        if(err !== undefined){
          this.state.stop = true;
        }
        callback(err);
      }
      // Implementation of `Transform._flush`
      _flush(callback){
        if(this.state.stop === true){
          return;
        }
        const err = this.__parse(undefined, true);
        callback(err);
      }
      // Central parser implementation
      __parse(nextBuf, end){
        const {bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;
        let {record_delimiter} = this.options;
        const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;
        let buf;
        if(previousBuf === undefined){
          if(nextBuf === undefined){
            // Handle empty string
            this.push(null);
            return;
          }else {
            buf = nextBuf;
          }
        }else if(previousBuf !== undefined && nextBuf === undefined){
          buf = previousBuf;
        }else {
          buf = Buffer$1.concat([previousBuf, nextBuf]);
        }
        // Handle UTF BOM
        if(bomSkipped === false){
          if(bom === false){
            this.state.bomSkipped = true;
          }else if(buf.length < 3){
            // No enough data
            if(end === false){
              // Wait for more data
              this.state.previousBuf = buf;
              return;
            }
          }else {
            for(const encoding in boms){
              if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){
                // Skip BOM
                const bomLength = boms[encoding].length;
                this.state.bufBytesStart += bomLength;
                buf = buf.slice(bomLength);
                // Renormalize original options with the new encoding
                this.__normalizeOptions({...this.__originalOptions, encoding: encoding});
                break;
              }
            }
            this.state.bomSkipped = true;
          }
        }
        const bufLen = buf.length;
        let pos;
        for(pos = 0; pos < bufLen; pos++){
          // Ensure we get enough space to look ahead
          // There should be a way to move this out of the loop
          if(this.__needMoreData(pos, bufLen, end)){
            break;
          }
          if(this.state.wasRowDelimiter === true){
            this.info.lines++;
            this.state.wasRowDelimiter = false;
          }
          if(to_line !== -1 && this.info.lines > to_line){
            this.state.stop = true;
            this.push(null);
            return;
          }
          // Auto discovery of record_delimiter, unix, mac and windows supported
          if(this.state.quoting === false && record_delimiter.length === 0){
            const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
            if(record_delimiterCount){
              record_delimiter = this.options.record_delimiter;
            }
          }
          const chr = buf[pos];
          if(raw === true){
            rawBuffer.append(chr);
          }
          if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){
            this.state.wasRowDelimiter = true;
          }
          // Previous char was a valid escape char
          // treat the current char as a regular char
          if(this.state.escaping === true){
            this.state.escaping = false;
          }else {
            // Escape is only active inside quoted fields
            // We are quoting, the char is an escape chr and there is a chr to escape
            // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
            if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){
              if(escapeIsQuote){
                if(this.__isQuote(buf, pos+escape.length)){
                  this.state.escaping = true;
                  pos += escape.length - 1;
                  continue;
                }
              }else {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            }
            // Not currently escaping and chr is a quote
            // TODO: need to compare bytes instead of single char
            if(this.state.commenting === false && this.__isQuote(buf, pos)){
              if(this.state.quoting === true){
                const nextChr = buf[pos+quote.length];
                const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);
                const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);
                const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);
                const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);
                // Escape a quote
                // Treat next char as a regular character
                if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){
                  pos += escape.length - 1;
                }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  pos += quote.length - 1;
                  continue;
                }else if(relax_quotes === false){
                  const err = this.__error(
                    new CsvError$1('CSV_INVALID_CLOSING_QUOTE', [
                      'Invalid Closing Quote:',
                      `got "${String.fromCharCode(nextChr)}"`,
                      `at line ${this.info.lines}`,
                      'instead of delimiter, record delimiter, trimable character',
                      '(if activated) or comment',
                    ], this.options, this.__infoField())
                  );
                  if(err !== undefined) return err;
                }else {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  this.state.field.prepend(quote);
                  pos += quote.length - 1;
                }
              }else {
                if(this.state.field.length !== 0){
                  // In relax_quotes mode, treat opening quote preceded by chrs as regular
                  if(relax_quotes === false){
                    const err = this.__error(
                      new CsvError$1('INVALID_OPENING_QUOTE', [
                        'Invalid Opening Quote:',
                        `a quote is found inside a field at line ${this.info.lines}`,
                      ], this.options, this.__infoField(), {
                        field: this.state.field,
                      })
                    );
                    if(err !== undefined) return err;
                  }
                }else {
                  this.state.quoting = true;
                  pos += quote.length - 1;
                  continue;
                }
              }
            }
            if(this.state.quoting === false){
              const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
              if(recordDelimiterLength !== 0){
                // Do not emit comments which take a full line
                const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);
                if(skipCommentLine){
                  this.info.comment_lines++;
                  // Skip full comment line
                }else {
                  // Activate records emition if above from_line
                  if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){
                    this.state.enabled = true;
                    this.__resetField();
                    this.__resetRecord();
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  // Skip if line is empty and skip_empty_lines activated
                  if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){
                    this.info.empty_lines++;
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  this.info.bytes = this.state.bufBytesStart + pos;
                  const errField = this.__onField();
                  if(errField !== undefined) return errField;
                  this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                  const errRecord = this.__onRecord();
                  if(errRecord !== undefined) return errRecord;
                  if(to !== -1 && this.info.records >= to){
                    this.state.stop = true;
                    this.push(null);
                    return;
                  }
                }
                this.state.commenting = false;
                pos += recordDelimiterLength - 1;
                continue;
              }
              if(this.state.commenting){
                continue;
              }
              const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);
              if(commentCount !== 0){
                this.state.commenting = true;
                continue;
              }
              const delimiterLength = this.__isDelimiter(buf, pos, chr);
              if(delimiterLength !== 0){
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if(errField !== undefined) return errField;
                pos += delimiterLength - 1;
                continue;
              }
            }
          }
          if(this.state.commenting === false){
            if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){
              const err = this.__error(
                new CsvError$1('CSV_MAX_RECORD_SIZE', [
                  'Max Record Size:',
                  'record exceed the maximum number of tolerated bytes',
                  `of ${max_record_size}`,
                  `at line ${this.info.lines}`,
                ], this.options, this.__infoField())
              );
              if(err !== undefined) return err;
            }
          }
          const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr);
          // rtrim in non quoting is handle in __onField
          const rappend = rtrim === false || this.state.wasQuoting === false;
          if(lappend === true && rappend === true){
            this.state.field.append(chr);
          }else if(rtrim === true && !this.__isCharTrimable(chr)){
            const err = this.__error(
              new CsvError$1('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [
                'Invalid Closing Quote:',
                'found non trimable byte after quote',
                `at line ${this.info.lines}`,
              ], this.options, this.__infoField())
            );
            if(err !== undefined) return err;
          }
        }
        if(end === true){
          // Ensure we are not ending in a quoting state
          if(this.state.quoting === true){
            const err = this.__error(
              new CsvError$1('CSV_QUOTE_NOT_CLOSED', [
                'Quote Not Closed:',
                `the parsing is finished with an opening quote at line ${this.info.lines}`,
              ], this.options, this.__infoField())
            );
            if(err !== undefined) return err;
          }else {
            // Skip last line if it has no characters
            if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if(errField !== undefined) return errField;
              const errRecord = this.__onRecord();
              if(errRecord !== undefined) return errRecord;
            }else if(this.state.wasRowDelimiter === true){
              this.info.empty_lines++;
            }else if(this.state.commenting === true){
              this.info.comment_lines++;
            }
          }
        }else {
          this.state.bufBytesStart += pos;
          this.state.previousBuf = buf.slice(pos);
        }
        if(this.state.wasRowDelimiter === true){
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
      }
      __onRecord(){
        const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;
        const {enabled, record} = this.state;
        if(enabled === false){
          return this.__resetRecord();
        }
        // Convert the first line into column names
        const recordLength = record.length;
        if(columns === true){
          if(skip_records_with_empty_values === true && isRecordEmpty(record)){
            this.__resetRecord();
            return;
          }
          return this.__firstLineToColumns(record);
        }
        if(columns === false && this.info.records === 0){
          this.state.expectedRecordLength = recordLength;
        }
        if(recordLength !== this.state.expectedRecordLength){
          const err = columns === false ?
            new CsvError$1('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [
              'Invalid Record Length:',
              `expect ${this.state.expectedRecordLength},`,
              `got ${recordLength} on line ${this.info.lines}`,
            ], this.options, this.__infoField(), {
              record: record,
            })
            :
            new CsvError$1('CSV_RECORD_INCONSISTENT_COLUMNS', [
              'Invalid Record Length:',
              `columns length is ${columns.length},`, // rename columns
              `got ${recordLength} on line ${this.info.lines}`,
            ], this.options, this.__infoField(), {
              record: record,
            });
          if(relax_column_count === true ||
            (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||
            (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){
            this.info.invalid_field_length++;
            this.state.error = err;
          // Error is undefined with skip_records_with_error
          }else {
            const finalErr = this.__error(err);
            if(finalErr) return finalErr;
          }
        }
        if(skip_records_with_empty_values === true && isRecordEmpty(record)){
          this.__resetRecord();
          return;
        }
        if(this.state.recordHasError === true){
          this.__resetRecord();
          this.state.recordHasError = false;
          return;
        }
        this.info.records++;
        if(from === 1 || this.info.records >= from){
          const {objname} = this.options;
          // With columns, records are object
          if(columns !== false){
            const obj = {};
            // Transform record array to an object
            for(let i = 0, l = record.length; i < l; i++){
              if(columns[i] === undefined || columns[i].disabled) continue;
              // Turn duplicate columns into an array
              if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {
                if (Array.isArray(obj[columns[i].name])) {
                  obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                } else {
                  obj[columns[i].name] = [obj[columns[i].name], record[i]];
                }
              } else {
                obj[columns[i].name] = record[i];
              }
            }
            // Without objname (default)
            if(raw === true || info === true){
              const extRecord = Object.assign(
                {record: obj},
                (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),
                (info === true ? {info: this.__infoRecord()}: {})
              );
              const err = this.__push(
                objname === undefined ? extRecord : [obj[objname], extRecord]
              );
              if(err){
                return err;
              }
            }else {
              const err = this.__push(
                objname === undefined ? obj : [obj[objname], obj]
              );
              if(err){
                return err;
              }
            }
          // Without columns, records are array
          }else {
            if(raw === true || info === true){
              const extRecord = Object.assign(
                {record: record},
                raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},
                info === true ? {info: this.__infoRecord()}: {}
              );
              const err = this.__push(
                objname === undefined ? extRecord : [record[objname], extRecord]
              );
              if(err){
                return err;
              }
            }else {
              const err = this.__push(
                objname === undefined ? record : [record[objname], record]
              );
              if(err){
                return err;
              }
            }
          }
        }
        this.__resetRecord();
      }
      __firstLineToColumns(record){
        const {firstLineToHeaders} = this.state;
        try{
          const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);
          if(!Array.isArray(headers)){
            return this.__error(
              new CsvError$1('CSV_INVALID_COLUMN_MAPPING', [
                'Invalid Column Mapping:',
                'expect an array from column function,',
                `got ${JSON.stringify(headers)}`
              ], this.options, this.__infoField(), {
                headers: headers,
              })
            );
          }
          const normalizedHeaders = normalizeColumnsArray(headers);
          this.state.expectedRecordLength = normalizedHeaders.length;
          this.options.columns = normalizedHeaders;
          this.__resetRecord();
          return;
        }catch(err){
          return err;
        }
      }
      __resetRecord(){
        if(this.options.raw === true){
          this.state.rawBuffer.reset();
        }
        this.state.error = undefined;
        this.state.record = [];
        this.state.record_length = 0;
      }
      __onField(){
        const {cast, encoding, rtrim, max_record_size} = this.options;
        const {enabled, wasQuoting} = this.state;
        // Short circuit for the from_line options
        if(enabled === false){
          return this.__resetField();
        }
        let field = this.state.field.toString(encoding);
        if(rtrim === true && wasQuoting === false){
          field = field.trimRight();
        }
        if(cast === true){
          const [err, f] = this.__cast(field);
          if(err !== undefined) return err;
          field = f;
        }
        this.state.record.push(field);
        // Increment record length if record size must not exceed a limit
        if(max_record_size !== 0 && typeof field === 'string'){
          this.state.record_length += field.length;
        }
        this.__resetField();
      }
      __resetField(){
        this.state.field.reset();
        this.state.wasQuoting = false;
      }
      __push(record){
        const {on_record} = this.options;
        if(on_record !== undefined){
          const info = this.__infoRecord();
          try{
            record = on_record.call(null, record, info);
          }catch(err){
            return err;
          }
          if(record === undefined || record === null){ return; }
        }
        this.push(record);
      }
      // Return a tuple with the error and the casted value
      __cast(field){
        const {columns, relax_column_count} = this.options;
        const isColumns = Array.isArray(columns);
        // Dont loose time calling cast
        // because the final record is an object
        // and this field can't be associated to a key present in columns
        if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){
          return [undefined, undefined];
        }
        if(this.state.castField !== null){
          try{
            const info = this.__infoField();
            return [undefined, this.state.castField.call(null, field, info)];
          }catch(err){
            return [err];
          }
        }
        if(this.__isFloat(field)){
          return [undefined, parseFloat(field)];
        }else if(this.options.cast_date !== false){
          const info = this.__infoField();
          return [undefined, this.options.cast_date.call(null, field, info)];
        }
        return [undefined, field];
      }
      // Helper to test if a character is a space or a line delimiter
      __isCharTrimable(chr){
        return chr === space || chr === tab || chr === cr || chr === nl || chr === np;
      }
      // Keep it in case we implement the `cast_int` option
      // __isInt(value){
      //   // return Number.isInteger(parseInt(value))
      //   // return !isNaN( parseInt( obj ) );
      //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
      // }
      __isFloat(value){
        return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery
      }
      __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){
        if(sourceBuf[0] !== firstByte) return 0;
        const sourceLength = sourceBuf.length;
        for(let i = 1; i < sourceLength; i++){
          if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;
        }
        return sourceLength;
      }
      __needMoreData(i, bufLen, end){
        if(end) return false;
        const {quote} = this.options;
        const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;
        const numOfCharLeft = bufLen - i - 1;
        const requiredLength = Math.max(
          needMoreDataSize,
          // Skip if the remaining buffer smaller than record delimiter
          recordDelimiterMaxLength,
          // Skip if the remaining buffer can be record delimiter following the closing quote
          // 1 is for quote.length
          quoting ? (quote.length + recordDelimiterMaxLength) : 0,
        );
        return numOfCharLeft < requiredLength;
      }
      __isDelimiter(buf, pos, chr){
        const {delimiter, ignore_last_delimiters} = this.options;
        if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){
          return 0;
        }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){
          return 0;
        }
        loop1: for(let i = 0; i < delimiter.length; i++){
          const del = delimiter[i];
          if(del[0] === chr){
            for(let j = 1; j < del.length; j++){
              if(del[j] !== buf[pos+j]) continue loop1;
            }
            return del.length;
          }
        }
        return 0;
      }
      __isRecordDelimiter(chr, buf, pos){
        const {record_delimiter} = this.options;
        const recordDelimiterLength = record_delimiter.length;
        loop1: for(let i = 0; i < recordDelimiterLength; i++){
          const rd = record_delimiter[i];
          const rdLength = rd.length;
          if(rd[0] !== chr){
            continue;
          }
          for(let j = 1; j < rdLength; j++){
            if(rd[j] !== buf[pos+j]){
              continue loop1;
            }
          }
          return rd.length;
        }
        return 0;
      }
      __isEscape(buf, pos, chr){
        const {escape} = this.options;
        if(escape === null) return false;
        const l = escape.length;
        if(escape[0] === chr){
          for(let i = 0; i < l; i++){
            if(escape[i] !== buf[pos+i]){
              return false;
            }
          }
          return true;
        }
        return false;
      }
      __isQuote(buf, pos){
        const {quote} = this.options;
        if(quote === null) return false;
        const l = quote.length;
        for(let i = 0; i < l; i++){
          if(quote[i] !== buf[pos+i]){
            return false;
          }
        }
        return true;
      }
      __autoDiscoverRecordDelimiter(buf, pos){
        const {encoding} = this.options;
        const chr = buf[pos];
        if(chr === cr){
          if(buf[pos+1] === nl){
            this.options.record_delimiter.push(Buffer$1.from('\r\n', encoding));
            this.state.recordDelimiterMaxLength = 2;
            return 2;
          }else {
            this.options.record_delimiter.push(Buffer$1.from('\r', encoding));
            this.state.recordDelimiterMaxLength = 1;
            return 1;
          }
        }else if(chr === nl){
          this.options.record_delimiter.push(Buffer$1.from('\n', encoding));
          this.state.recordDelimiterMaxLength = 1;
          return 1;
        }
        return 0;
      }
      __error(msg){
        const {encoding, raw, skip_records_with_error} = this.options;
        const err = typeof msg === 'string' ? new Error(msg) : msg;
        if(skip_records_with_error){
          this.state.recordHasError = true;
          this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
          return undefined;
        }else {
          return err;
        }
      }
      __infoDataSet(){
        return {
          ...this.info,
          columns: this.options.columns
        };
      }
      __infoRecord(){
        const {columns, raw, encoding} = this.options;
        return {
          ...this.__infoDataSet(),
          error: this.state.error,
          header: columns === true,
          index: this.state.record.length,
          raw: raw ? this.state.rawBuffer.toString(encoding) : undefined
        };
      }
      __infoField(){
        const {columns} = this.options;
        const isColumns = Array.isArray(columns);
        return {
          ...this.__infoRecord(),
          column: isColumns === true ?
            (columns.length > this.state.record.length ?
              columns[this.state.record.length].name :
              null
            ) :
            this.state.record.length,
          quoting: this.state.wasQuoting,
        };
      }
    }

    const parse = function(data, options={}){
      if(typeof data === 'string'){
        data = Buffer$1.from(data);
      }
      const records = options && options.objname ? {} : [];
      const parser = new Parser(options);
      parser.push = function(record){
        if(record === null){
          return;
        }
        if(options.objname === undefined)
          records.push(record);
        else {
          records[record[0]] = record[1];
        }
      };
      const err1 = parser.__parse(data, false);
      if(err1 !== undefined) throw err1;
      const err2 = parser.__parse(undefined, true);
      if(err2 !== undefined) throw err2;
      return records;
    };

    const bom_utf8 = Buffer$1.from([239, 187, 191]);

    class CsvError extends Error {
      constructor(code, message, ...contexts) {
        if(Array.isArray(message)) message = message.join(' ');
        super(message);
        if(Error.captureStackTrace !== undefined){
          Error.captureStackTrace(this, CsvError);
        }
        this.code = code;
        for(const context of contexts){
          for(const key in context){
            const value = context[key];
            this[key] = Buffer$1.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
          }
        }
      }
    }

    const isObject = function(obj){
      return typeof obj === 'object' && obj !== null && ! Array.isArray(obj);
    };

    const underscore = function(str){
      return str.replace(/([A-Z])/g, function(_, match){
        return '_' + match.toLowerCase();
      });
    };

    // Lodash implementation of `get`

    const charCodeOfDot = '.'.charCodeAt(0);
    const reEscapeChar = /\\(\\)?/g;
    const rePropName = RegExp(
      // Match anything that isn't a dot or bracket.
      '[^.[\\]]+' + '|' +
      // Or match property names within brackets.
      '\\[(?:' +
        // Match a non-string expression.
        '([^"\'][^[]*)' + '|' +
        // Or match strings (supports escaping characters).
        '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
      ')\\]'+ '|' +
      // Or match "" as the space between consecutive dots or empty brackets.
      '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))'
      , 'g');
    const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    const reIsPlainProp = /^\w*$/;
    const getTag = function(value){
      return Object.prototype.toString.call(value);
    };
    const isSymbol = function(value){
      const type = typeof value;
      return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]');
    };
    const isKey = function(value, object){
      if(Array.isArray(value)){
        return false;
      }
      const type = typeof value;
      if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    };
    const stringToPath = function(string){
      const result = [];
      if(string.charCodeAt(0) === charCodeOfDot){
        result.push('');
      }
      string.replace(rePropName, function(match, expression, quote, subString){
        let key = match;
        if(quote){
          key = subString.replace(reEscapeChar, '$1');
        }else if(expression){
          key = expression.trim();
        }
        result.push(key);
      });
      return result;
    };
    const castPath = function(value, object){
      if(Array.isArray(value)){
        return value;
      } else {
        return isKey(value, object) ? [value] : stringToPath(value);
      }
    };
    const toKey = function(value){
      if(typeof value === 'string' || isSymbol(value))
        return value;
      const result = `${value}`;
      // eslint-disable-next-line
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    };
    const get = function(object, path){
      path = castPath(path, object);
      let index = 0;
      const length = path.length;
      while(object != null && index < length){
        object = object[toKey(path[index++])];
      }
      return (index && index === length) ? object : undefined;
    };

    class Stringifier extends Transform {
      constructor(opts = {}){
        super({...{writableObjectMode: true}, ...opts});
        const options = {};
        let err;
        // Merge with user options
        for(const opt in opts){
          options[underscore(opt)] = opts[opt];
        }
        if((err = this.normalize(options)) !== undefined) throw err;
        switch(options.record_delimiter){
        case 'auto':
          options.record_delimiter = null;
          break;
        case 'unix':
          options.record_delimiter = "\n";
          break;
        case 'mac':
          options.record_delimiter = "\r";
          break;
        case 'windows':
          options.record_delimiter = "\r\n";
          break;
        case 'ascii':
          options.record_delimiter = "\u001e";
          break;
        case 'unicode':
          options.record_delimiter = "\u2028";
          break;
        }
        // Expose options
        this.options = options;
        // Internal state
        this.state = {
          stop: false
        };
        // Information
        this.info = {
          records: 0
        };
      }
      normalize(options){
        // Normalize option `bom`
        if(options.bom === undefined || options.bom === null || options.bom === false){
          options.bom = false;
        }else if(options.bom !== true){
          return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [
            'option `bom` is optional and must be a boolean value,',
            `got ${JSON.stringify(options.bom)}`
          ]);
        }
        // Normalize option `delimiter`
        if(options.delimiter === undefined || options.delimiter === null){
          options.delimiter = ',';
        }else if(Buffer$1.isBuffer(options.delimiter)){
          options.delimiter = options.delimiter.toString();
        }else if(typeof options.delimiter !== 'string'){
          return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [
            'option `delimiter` must be a buffer or a string,',
            `got ${JSON.stringify(options.delimiter)}`
          ]);
        }
        // Normalize option `quote`
        if(options.quote === undefined || options.quote === null){
          options.quote = '"';
        }else if(options.quote === true){
          options.quote = '"';
        }else if(options.quote === false){
          options.quote = '';
        }else if (Buffer$1.isBuffer(options.quote)){
          options.quote = options.quote.toString();
        }else if(typeof options.quote !== 'string'){
          return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [
            'option `quote` must be a boolean, a buffer or a string,',
            `got ${JSON.stringify(options.quote)}`
          ]);
        }
        // Normalize option `quoted`
        if(options.quoted === undefined || options.quoted === null){
          options.quoted = false;
        }
        // Normalize option `quoted_empty`
        if(options.quoted_empty === undefined || options.quoted_empty === null){
          options.quoted_empty = undefined;
        }
        // Normalize option `quoted_match`
        if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){
          options.quoted_match = null;
        }else if(!Array.isArray(options.quoted_match)){
          options.quoted_match = [options.quoted_match];
        }
        if(options.quoted_match){
          for(const quoted_match of options.quoted_match){
            const isString = typeof quoted_match === 'string';
            const isRegExp = quoted_match instanceof RegExp;
            if(!isString && !isRegExp){
              return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);
            }
          }
        }
        // Normalize option `quoted_string`
        if(options.quoted_string === undefined || options.quoted_string === null){
          options.quoted_string = false;
        }
        // Normalize option `eof`
        if(options.eof === undefined || options.eof === null){
          options.eof = true;
        }
        // Normalize option `escape`
        if(options.escape === undefined || options.escape === null){
          options.escape = '"';
        }else if(Buffer$1.isBuffer(options.escape)){
          options.escape = options.escape.toString();
        }else if(typeof options.escape !== 'string'){
          return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);
        }
        if (options.escape.length > 1){
          return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);
        }
        // Normalize option `header`
        if(options.header === undefined || options.header === null){
          options.header = false;
        }
        // Normalize option `columns`
        const [err, columns] = this.normalize_columns(options.columns);
        if(err) return err;
        options.columns = columns;
        // Normalize option `quoted`
        if(options.quoted === undefined || options.quoted === null){
          options.quoted = false;
        }
        // Normalize option `cast`
        if(options.cast === undefined || options.cast === null){
          options.cast = {};
        }
        // Normalize option cast.bigint
        if(options.cast.bigint === undefined || options.cast.bigint === null){
          // Cast boolean to string by default
          options.cast.bigint = value => '' + value;
        }
        // Normalize option cast.boolean
        if(options.cast.boolean === undefined || options.cast.boolean === null){
          // Cast boolean to string by default
          options.cast.boolean = value => value ? '1' : '';
        }
        // Normalize option cast.date
        if(options.cast.date === undefined || options.cast.date === null){
          // Cast date to timestamp string by default
          options.cast.date = value => '' + value.getTime();
        }
        // Normalize option cast.number
        if(options.cast.number === undefined || options.cast.number === null){
          // Cast number to string using native casting by default
          options.cast.number = value => '' + value;
        }
        // Normalize option cast.object
        if(options.cast.object === undefined || options.cast.object === null){
          // Stringify object as JSON by default
          options.cast.object = value => JSON.stringify(value);
        }
        // Normalize option cast.string
        if(options.cast.string === undefined || options.cast.string === null){
          // Leave string untouched
          options.cast.string = function(value){return value;};
        }
        // Normalize option `record_delimiter`
        if(options.record_delimiter === undefined || options.record_delimiter === null){
          options.record_delimiter = '\n';
        }else if(Buffer$1.isBuffer(options.record_delimiter)){
          options.record_delimiter = options.record_delimiter.toString();
        }else if(typeof options.record_delimiter !== 'string'){
          return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`);
        }
      }
      _transform(chunk, encoding, callback){
        if(this.state.stop === true){
          return;
        }
        const err = this.__transform(chunk);
        if(err !== undefined){
          this.state.stop = true;
        }
        callback(err);
      }
      _flush(callback){
        if(this.state.stop === true){
          // Note, Node.js 12 call flush even after an error, we must prevent
          // `callback` from being called in flush without any error.
          return;
        }
        if(this.info.records === 0){
          this.bom();
          const err = this.headers();
          if(err) callback(err);
        }
        callback();
      }
      __transform(chunk){
        // Chunk validation
        if(!Array.isArray(chunk) && typeof chunk !== 'object'){
          return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
        }
        // Detect columns from the first record
        if(this.info.records === 0){
          if(Array.isArray(chunk)){
            if(this.options.header === true && this.options.columns === undefined){
              return Error('Undiscoverable Columns: header option requires column option or object records');
            }
          }else if(this.options.columns === undefined){
            const [err, columns] = this.normalize_columns(Object.keys(chunk));
            if(err) return;
            this.options.columns = columns;
          }
        }
        // Emit the header
        if(this.info.records === 0){
          this.bom();
          const err = this.headers();
          if(err) return err;
        }
        // Emit and stringify the record if an object or an array
        try{
          this.emit('record', chunk, this.info.records);
        }catch(err){
          return err;
        }
        // Convert the record into a string
        let err, chunk_string;
        if(this.options.eof){
          [err, chunk_string] = this.stringify(chunk);
          if(err) return err;
          if(chunk_string === undefined){
            return;
          }else {
            chunk_string = chunk_string + this.options.record_delimiter;
          }
        }else {
          [err, chunk_string] = this.stringify(chunk);
          if(err) return err;
          if(chunk_string === undefined){
            return;
          }else {
            if(this.options.header || this.info.records){
              chunk_string = this.options.record_delimiter + chunk_string;
            }
          }
        }
        // Emit the csv
        this.info.records++;
        this.push(chunk_string);
      }
      stringify(chunk, chunkIsHeader=false){
        if(typeof chunk !== 'object'){
          return [undefined, chunk];
        }
        const {columns} = this.options;
        const record = [];
        // Record is an array
        if(Array.isArray(chunk)){
          // We are getting an array but the user has specified output columns. In
          // this case, we respect the columns indexes
          if(columns){
            chunk.splice(columns.length);
          }
          // Cast record elements
          for(let i=0; i<chunk.length; i++){
            const field = chunk[i];
            const [err, value] = this.__cast(field, {
              index: i, column: i, records: this.info.records, header: chunkIsHeader
            });
            if(err) return [err];
            record[i] = [value, field];
          }
        // Record is a literal object
        // `columns` is always defined: it is either provided or discovered.
        }else {
          for(let i=0; i<columns.length; i++){
            const field = get(chunk, columns[i].key);
            const [err, value] = this.__cast(field, {
              index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader
            });
            if(err) return [err];
            record[i] = [value, field];
          }
        }
        let csvrecord = '';
        for(let i=0; i<record.length; i++){
          let options, err;
          // eslint-disable-next-line
          let [value, field] = record[i];
          if(typeof value === "string"){
            options = this.options;
          }else if(isObject(value)){
            options = value;
            value = options.value;
            delete options.value;
            if(typeof value !== "string" && value !== undefined && value !== null){
              if(err) return [Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)];
            }
            options = {...this.options, ...options};
            if((err = this.normalize(options)) !== undefined){
              return [err];
            }
          }else if(value === undefined || value === null){
            options = this.options;
          }else {
            return [Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)];
          }
          const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter} = options;
          if(value){
            if(typeof value !== 'string'){
              return [Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)];
            }
            const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
            const containsQuote = (quote !== '') && value.indexOf(quote) >= 0;
            const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote);
            const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
            const quotedString = quoted_string && typeof field === 'string';
            let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {
              if(typeof quoted_match === 'string'){
                return value.indexOf(quoted_match) !== -1;
              }else {
                return quoted_match.test(value);
              }
            });
            quotedMatch = quotedMatch && quotedMatch.length > 0;
            const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
            if(shouldQuote === true && containsEscape === true){
              const regexp = escape === '\\'
                ? new RegExp(escape + escape, 'g')
                : new RegExp(escape, 'g');
              value = value.replace(regexp, escape + escape);
            }
            if(containsQuote === true){
              const regexp = new RegExp(quote,'g');
              value = value.replace(regexp, escape + quote);
            }
            if(shouldQuote === true){
              value = quote + value + quote;
            }
            csvrecord += value;
          }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){
            csvrecord += quote + quote;
          }
          if(i !== record.length - 1){
            csvrecord += delimiter;
          }
        }
        return [undefined, csvrecord];
      }
      bom(){
        if(this.options.bom !== true){
          return;
        }
        this.push(bom_utf8);
      }
      headers(){
        if(this.options.header === false){
          return;
        }
        if(this.options.columns === undefined){
          return;
        }
        let err;
        let headers = this.options.columns.map(column => column.header);
        if(this.options.eof){
          [err, headers] = this.stringify(headers, true);
          headers += this.options.record_delimiter;
        }else {
          [err, headers] = this.stringify(headers);
        }
        if(err) return err;
        this.push(headers);
      }
      __cast(value, context){
        const type = typeof value;
        try{
          if(type === 'string'){ // Fine for 99% of the cases
            return [undefined, this.options.cast.string(value, context)];
          }else if(type === 'bigint'){
            return [undefined, this.options.cast.bigint(value, context)];
          }else if(type === 'number'){
            return [undefined, this.options.cast.number(value, context)];
          }else if(type === 'boolean'){
            return [undefined, this.options.cast.boolean(value, context)];
          }else if(value instanceof Date){
            return [undefined, this.options.cast.date(value, context)];
          }else if(type === 'object' && value !== null){
            return [undefined, this.options.cast.object(value, context)];
          }else {
            return [undefined, value, value];
          }
        }catch(err){
          return [err];
        }
      }
      normalize_columns(columns){
        if(columns === undefined || columns === null){
          return [];
        }
        if(typeof columns !== 'object'){
          return [Error('Invalid option "columns": expect an array or an object')];
        }
        if(!Array.isArray(columns)){
          const newcolumns = [];
          for(const k in columns){
            newcolumns.push({
              key: k,
              header: columns[k]
            });
          }
          columns = newcolumns;
        }else {
          const newcolumns = [];
          for(const column of columns){
            if(typeof column === 'string'){
              newcolumns.push({
                key: column,
                header: column
              });
            }else if(typeof column === 'object' && column !== undefined && !Array.isArray(column)){
              if(!column.key){
                return [Error('Invalid column definition: property "key" is required')];
              }
              if(column.header === undefined){
                column.header = column.key;
              }
              newcolumns.push(column);
            }else {
              return [Error('Invalid column definition: expect a string or an object')];
            }
          }
          columns = newcolumns;
        }
        return [undefined, columns];
      }
    }

    const stringify = function(records, options={}){
      const data = [];
      const stringifier = new Stringifier(options);
      stringifier.push = function(record){
        if(record === null){
          return;
        }
        data.push(record.toString());
      };
      for(const record of records){
        const err = stringifier.__transform(record, null);
        if(err !== undefined) throw err;
      }
      return data.join('');
    };

    const Transformer = function(options = {}, handler){
      this.options = options;
      if(options.consume === undefined || options.consume === null){
        this.options.consume = false;
      }
      this.options.objectMode = true;
      if(options.parallel === undefined || options.parallel === null){
        this.options.parallel = 100;
      }
      if(options.params === undefined || options.params === null){
        options.params = null;
      }
      this.handler = handler;
      Stream.Transform.call(this, this.options);
      this.state = {
        running: 0,
        started: 0,
        finished: 0
      };
      return this;
    };

    util.inherits(Transformer, Stream.Transform);

    Transformer.prototype._transform = function(chunk, encoding, cb){
      this.state.started++;
      this.state.running++;
      if(this.state.running < this.options.parallel){
        cb();
        cb = null; // Cancel further callback execution
      }
      try {
        let l = this.handler.length;
        if(this.options.params !== null){  
          l--;
        }
        if(l === 1){ // sync
          this.__done(null, [this.handler.call(this, chunk, this.options.params)], cb);
        }else if(l === 2){ // async
          const callback = (err, ...chunks) =>
            this.__done(err, chunks, cb);
          this.handler.call(this, chunk, callback, this.options.params);
        }else {
          throw Error('Invalid handler arguments');
        }
        return false;
      }
      catch (err) {
        this.__done(err);
      }
    };
    Transformer.prototype._flush = function(cb){
      if(this.state.running === 0){
        cb();
      }else {
        this._ending = function(){
          cb();
        };
      }
    };
    Transformer.prototype.__done = function(err, chunks, cb){
      this.state.running--;
      if(err){
        return this.emit('error', err);
      }
      this.state.finished++;
      for(let chunk of chunks){
        if (typeof chunk === 'number'){
          chunk = `${chunk}`;
        }
        // We dont push empty string
        // See https://nodejs.org/api/stream.html#stream_readable_push
        if(chunk !== undefined && chunk !== null && chunk !== ''){
          this.push(chunk);
        }
      }
      if(cb){
        cb();
      }
      if(this._ending && this.state.running === 0){
        this._ending();
      }
    };

    /**
     * Prompts the user to specify data dimensions.
     */
    function runDimensionsModal(data, dimensions, nanDimensions) {
        return new Promise((resolve, reject) => {
            const modalContainer = document.createElement('div');
            Object.assign(modalContainer.style, {
                position: 'fixed',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                inset: '0',
                background: 'rgba(0, 0, 0, 0.1)',
                opacity: '0',
                transition: 'opacity 0.3s',
                zIndex: '1000'
            });
            document.body.appendChild(modalContainer);
            const modal = document.createElement('div');
            Object.assign(modal.style, {
                position: 'relative',
                background: 'white',
                color: 'black',
                border: '1px solid rgba(0, 0, 0, 0.1)',
                borderRadius: '8px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                font: '13px sans-serif',
                overflow: 'auto',
                maxHeight: '95vh'
            });
            modalContainer.className = 'd3st-data-import-modal-container';
            modalContainer.appendChild(modal);
            {
                const title = document.createElement('h2');
                title.style.marginTop = '0';
                title.style.marginBottom = '8px';
                title.style.padding = '8px 16px 0 16px';
                title.textContent = 'Import Data';
                modal.appendChild(title);
                const subtitle = document.createElement('h4');
                subtitle.style.marginTop = '0';
                subtitle.style.padding = '0 16px';
                subtitle.textContent = 'Specify how to import each data dimension.';
                subtitle.style.fontWeight = 'inherit';
                modal.appendChild(subtitle);
            }
            const dimSettings = [];
            {
                const dimContainer = document.createElement('ul');
                Object.assign(dimContainer.style, {
                    padding: '0',
                    margin: '0',
                    listStyle: 'none'
                });
                modal.appendChild(dimContainer);
                for (const dimName of dimensions) {
                    const isNan = nanDimensions.has(dimName);
                    const li = document.createElement('li');
                    Object.assign(li.style, {
                        padding: '4px 16px',
                        borderBottom: '1px solid rgba(0, 0, 0, 0.1)'
                    });
                    dimContainer.appendChild(li);
                    const details = document.createElement('div');
                    Object.assign(details.style, {
                        marginBottom: '4px'
                    });
                    li.appendChild(details);
                    const name = document.createElement('div');
                    name.style.fontWeight = '600';
                    details.appendChild(name);
                    name.textContent = dimName;
                    if (isNan) {
                        const isNanText = document.createElement('div');
                        isNanText.style.fontSize = 'smaller';
                        isNanText.style.marginTop = '2px';
                        details.appendChild(isNanText);
                        isNanText.textContent = '(not a number)';
                    }
                    const controls = document.createElement('div');
                    li.appendChild(controls);
                    const method = document.createElement('select');
                    controls.appendChild(method);
                    {
                        const ignore = document.createElement('option');
                        ignore.value = 'ignore';
                        ignore.textContent = 'Ignore';
                        method.appendChild(ignore);
                    }
                    let domainLo;
                    let domainHi;
                    let logChkbox;
                    if (!isNan) {
                        const read = document.createElement('option');
                        read.value = 'read';
                        read.textContent = 'Read';
                        read.selected = true;
                        method.appendChild(read);
                        const domain = document.createElement('div');
                        controls.appendChild(domain);
                        const label = document.createElement('span');
                        label.textContent = 'Domain: ';
                        domain.appendChild(label);
                        domainLo = document.createElement('input');
                        domain.appendChild(domainLo);
                        domainLo.type = 'number';
                        domainHi = document.createElement('input');
                        domain.appendChild(domainHi);
                        domainHi.type = 'number';
                        const inputStyle = {
                            width: '7em'
                        };
                        Object.assign(domainLo.style, inputStyle);
                        Object.assign(domainHi.style, inputStyle);
                        const defaultDomain = Dimension.fromData(dimName, data, 0.0).domain;
                        domainLo.value = defaultDomain[0].toString();
                        domainHi.value = defaultDomain[1].toString();
                        method.addEventListener('change', () => {
                            domain.style.display = method.value === 'read' ? '' : 'none';
                        });
                        const log = document.createElement('div');
                        logChkbox = document.createElement('input');
                        const logLabel = document.createElement('label');
                        logLabel.textContent = 'Log';
                        logChkbox.type = 'checkbox';
                        logLabel.htmlFor = logChkbox.id = Math.random().toString();
                        log.appendChild(logChkbox);
                        log.appendChild(document.createTextNode(' '));
                        log.appendChild(logLabel);
                        controls.appendChild(log);
                    }
                    dimSettings.push({
                        name: dimName,
                        method,
                        domainLo,
                        domainHi,
                        logChkbox,
                    });
                }
            }
            const close = () => {
                modalContainer.style.opacity = '0';
                modalContainer.style.pointerEvents = 'none';
                modalContainer.addEventListener('transitionend', () => {
                    var _a;
                    (_a = modalContainer.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(modalContainer);
                });
            };
            const confirm = () => {
                close();
                const dimensions = [];
                for (const dim of dimSettings) {
                    if (dim.method.value === 'read') {
                        const domainLo = +dim.domainLo.value;
                        const domainHi = +dim.domainHi.value;
                        const log = dim.logChkbox.checked;
                        const mapping = log ? Dimension.Log : Dimension.Linear;
                        dimensions.push(new Dimension(dim.name, [domainLo, domainHi], mapping));
                    }
                }
                resolve(dimensions);
            };
            {
                const buttons = document.createElement('div');
                buttons.style.padding = '8px 16px';
                buttons.style.textAlign = 'right';
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                buttons.appendChild(cancelButton);
                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Import';
                buttons.appendChild(confirmButton);
                cancelButton.addEventListener('click', () => {
                    close();
                    reject();
                });
                confirmButton.addEventListener('click', confirm);
                modal.appendChild(buttons);
            }
            requestAnimationFrame(() => {
                modalContainer.style.opacity = '1';
            });
        });
    }
    class FileIo extends EventEmitter {
        constructor() {
            super();
            this._node = document.createElement('div');
            const importButton = document.createElement('button');
            importButton.textContent = 'Import Data';
            this._node.appendChild(importButton);
            const loadPathButton = document.createElement('button');
            loadPathButton.textContent = 'Load Path';
            this._node.appendChild(loadPathButton);
            const storePathButton = document.createElement('button');
            storePathButton.textContent = 'Store Path';
            this._node.appendChild(storePathButton);
            const setUpImportButton = (button, onFile) => {
                button.addEventListener('dragover', event => {
                    event.preventDefault();
                    button.style.outline = '1px solid #00f';
                });
                button.addEventListener('dragleave', event => {
                    button.style.outline = '';
                });
                button.addEventListener('drop', event => {
                    var _a;
                    button.style.outline = '';
                    event.preventDefault();
                    const file = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.files[0];
                    if (!file) {
                        alert('Not a file');
                        return;
                    }
                    onFile(file);
                });
                button.addEventListener('click', () => {
                    const filePicker = document.createElement('input');
                    filePicker.type = 'file';
                    filePicker.accept = 'text/csv';
                    filePicker.addEventListener('change', () => {
                        const file = filePicker.files && filePicker.files[0];
                        if (!file)
                            return;
                        onFile(file);
                    });
                    filePicker.click();
                });
            };
            setUpImportButton(importButton, file => this.loadData(file));
            setUpImportButton(loadPathButton, file => this.loadPath(file));
            storePathButton.addEventListener('click', () => this.storePath());
        }
        node() {
            return this._node;
        }
        connect(target) {
            this._matrix = target;
            return this;
        }
        disconnect() {
            this._matrix = undefined;
            return this;
        }
        loadData(file) {
            const fileReader = new FileReader();
            fileReader.onload = () => {
                const input = parse(fileReader.result, { columns: true, skip_empty_lines: true });
                const dimensions = new Set(input.flatMap((entry) => Object.keys(entry)));
                const nanDimensions = new Set();
                const data = [];
                for (const entry of input) {
                    const item = {};
                    for (const dimension of dimensions) {
                        const num = +(entry[dimension].trim());
                        if (Number.isFinite(num)) {
                            item[dimension] = num;
                        }
                        else {
                            item[dimension] = entry[dimension];
                            if (entry[dimension].trim())
                                nanDimensions.add(dimension);
                        }
                    }
                    data.push(item);
                }
                runDimensionsModal(data, dimensions, nanDimensions).then(dimensions => {
                    this.emit('loadData', data, dimensions);
                    if (this._matrix) {
                        this._matrix.dimensions(dimensions).data(data);
                    }
                }).catch(() => { });
            };
            fileReader.readAsText(file);
        }
        loadPath(file) {
            const matrix = this._matrix;
            if (!matrix) {
                alert('File IO is not connected to anything');
                return;
            }
            const fileReader = new FileReader();
            fileReader.onload = () => {
                const input = parse(fileReader.result, { skip_empty_lines: true });
                const dims = matrix.dimensions();
                const dimNames = dims.map(dim => dim.name);
                const path = [];
                for (const pair of input) {
                    const x = dimNames.indexOf(pair[0]);
                    const y = dimNames.indexOf(pair[1]);
                    if (x === -1 || y === -1) {
                        alert('Unknown dimensions in pair: ' + pair[0] + ', ' + pair[1] + '.\nTry loading the data first.');
                        return;
                    }
                    path.push(new ScatterView(dims[x], dims[y]));
                }
                matrix.transBuilder().begin();
                matrix.transBuilder().path.views.push(...path);
                matrix.transBuilder().path.renderPaths();
            };
            fileReader.readAsText(file);
        }
        storePath() {
            const matrix = this._matrix;
            if (!matrix) {
                alert('File IO is not connected to anything');
                return;
            }
            const plot = matrix.plot();
            let views = null;
            if (matrix.transBuilder().buildingTransition) {
                views = matrix.transBuilder().path.views;
            }
            else if (plot) {
                const transition = plot.transition();
                if (transition) {
                    views = transition.views;
                }
            }
            if (views) {
                const path = [];
                for (const view of views) {
                    path.push([view.x.name, view.y.name]);
                }
                const blob = new Blob([stringify(path)]);
                const blobUrl = URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = blobUrl;
                downloadLink.download = 'path.csv';
                downloadLink.click();
                URL.revokeObjectURL(blobUrl);
            }
            else {
                alert('No path loaded');
            }
        }
    }
    function fileio() {
        return new FileIo();
    }

    var sControls = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ScatterplotMatrix: ScatterplotMatrix,
        scatterplotMatrix: scatterplotMatrix,
        Scatterplot: Scatterplot,
        scatterplot: scatterplot,
        TimelineSlider: TimelineSlider,
        timelineSlider: timelineSlider,
        FileIo: FileIo,
        fileio: fileio
    });

    const scatterTrans = {
        ...sTransitions,
        ...sData,
        ...sView,
        ...sControls
    };

    exports.scatterTrans = scatterTrans;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
